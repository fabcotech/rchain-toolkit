/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.casper = (function() {

    /**
     * Namespace casper.
     * @exports casper
     * @namespace
     */
    var casper = {};

    casper.HasBlockRequestProto = (function() {

        /**
         * Properties of a HasBlockRequestProto.
         * @memberof casper
         * @interface IHasBlockRequestProto
         * @property {Uint8Array|null} [hash] HasBlockRequestProto hash
         */

        /**
         * Constructs a new HasBlockRequestProto.
         * @memberof casper
         * @classdesc Represents a HasBlockRequestProto.
         * @implements IHasBlockRequestProto
         * @constructor
         * @param {casper.IHasBlockRequestProto=} [properties] Properties to set
         */
        function HasBlockRequestProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HasBlockRequestProto hash.
         * @member {Uint8Array} hash
         * @memberof casper.HasBlockRequestProto
         * @instance
         */
        HasBlockRequestProto.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new HasBlockRequestProto instance using the specified properties.
         * @function create
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {casper.IHasBlockRequestProto=} [properties] Properties to set
         * @returns {casper.HasBlockRequestProto} HasBlockRequestProto instance
         */
        HasBlockRequestProto.create = function create(properties) {
            return new HasBlockRequestProto(properties);
        };

        /**
         * Encodes the specified HasBlockRequestProto message. Does not implicitly {@link casper.HasBlockRequestProto.verify|verify} messages.
         * @function encode
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {casper.IHasBlockRequestProto} message HasBlockRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HasBlockRequestProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified HasBlockRequestProto message, length delimited. Does not implicitly {@link casper.HasBlockRequestProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {casper.IHasBlockRequestProto} message HasBlockRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HasBlockRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HasBlockRequestProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.HasBlockRequestProto} HasBlockRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HasBlockRequestProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.HasBlockRequestProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HasBlockRequestProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.HasBlockRequestProto} HasBlockRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HasBlockRequestProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HasBlockRequestProto message.
         * @function verify
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HasBlockRequestProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a HasBlockRequestProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.HasBlockRequestProto} HasBlockRequestProto
         */
        HasBlockRequestProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.HasBlockRequestProto)
                return object;
            var message = new $root.casper.HasBlockRequestProto();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a HasBlockRequestProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.HasBlockRequestProto
         * @static
         * @param {casper.HasBlockRequestProto} message HasBlockRequestProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HasBlockRequestProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this HasBlockRequestProto to JSON.
         * @function toJSON
         * @memberof casper.HasBlockRequestProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HasBlockRequestProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HasBlockRequestProto;
    })();

    casper.HasBlockProto = (function() {

        /**
         * Properties of a HasBlockProto.
         * @memberof casper
         * @interface IHasBlockProto
         * @property {Uint8Array|null} [hash] HasBlockProto hash
         */

        /**
         * Constructs a new HasBlockProto.
         * @memberof casper
         * @classdesc Represents a HasBlockProto.
         * @implements IHasBlockProto
         * @constructor
         * @param {casper.IHasBlockProto=} [properties] Properties to set
         */
        function HasBlockProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HasBlockProto hash.
         * @member {Uint8Array} hash
         * @memberof casper.HasBlockProto
         * @instance
         */
        HasBlockProto.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new HasBlockProto instance using the specified properties.
         * @function create
         * @memberof casper.HasBlockProto
         * @static
         * @param {casper.IHasBlockProto=} [properties] Properties to set
         * @returns {casper.HasBlockProto} HasBlockProto instance
         */
        HasBlockProto.create = function create(properties) {
            return new HasBlockProto(properties);
        };

        /**
         * Encodes the specified HasBlockProto message. Does not implicitly {@link casper.HasBlockProto.verify|verify} messages.
         * @function encode
         * @memberof casper.HasBlockProto
         * @static
         * @param {casper.IHasBlockProto} message HasBlockProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HasBlockProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified HasBlockProto message, length delimited. Does not implicitly {@link casper.HasBlockProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.HasBlockProto
         * @static
         * @param {casper.IHasBlockProto} message HasBlockProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HasBlockProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HasBlockProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.HasBlockProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.HasBlockProto} HasBlockProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HasBlockProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.HasBlockProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HasBlockProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.HasBlockProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.HasBlockProto} HasBlockProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HasBlockProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HasBlockProto message.
         * @function verify
         * @memberof casper.HasBlockProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HasBlockProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a HasBlockProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.HasBlockProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.HasBlockProto} HasBlockProto
         */
        HasBlockProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.HasBlockProto)
                return object;
            var message = new $root.casper.HasBlockProto();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a HasBlockProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.HasBlockProto
         * @static
         * @param {casper.HasBlockProto} message HasBlockProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HasBlockProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this HasBlockProto to JSON.
         * @function toJSON
         * @memberof casper.HasBlockProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HasBlockProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HasBlockProto;
    })();

    casper.BlockRequestProto = (function() {

        /**
         * Properties of a BlockRequestProto.
         * @memberof casper
         * @interface IBlockRequestProto
         * @property {Uint8Array|null} [hash] BlockRequestProto hash
         */

        /**
         * Constructs a new BlockRequestProto.
         * @memberof casper
         * @classdesc Represents a BlockRequestProto.
         * @implements IBlockRequestProto
         * @constructor
         * @param {casper.IBlockRequestProto=} [properties] Properties to set
         */
        function BlockRequestProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockRequestProto hash.
         * @member {Uint8Array} hash
         * @memberof casper.BlockRequestProto
         * @instance
         */
        BlockRequestProto.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new BlockRequestProto instance using the specified properties.
         * @function create
         * @memberof casper.BlockRequestProto
         * @static
         * @param {casper.IBlockRequestProto=} [properties] Properties to set
         * @returns {casper.BlockRequestProto} BlockRequestProto instance
         */
        BlockRequestProto.create = function create(properties) {
            return new BlockRequestProto(properties);
        };

        /**
         * Encodes the specified BlockRequestProto message. Does not implicitly {@link casper.BlockRequestProto.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockRequestProto
         * @static
         * @param {casper.IBlockRequestProto} message BlockRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequestProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified BlockRequestProto message, length delimited. Does not implicitly {@link casper.BlockRequestProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockRequestProto
         * @static
         * @param {casper.IBlockRequestProto} message BlockRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockRequestProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockRequestProto} BlockRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequestProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockRequestProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockRequestProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockRequestProto} BlockRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockRequestProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockRequestProto message.
         * @function verify
         * @memberof casper.BlockRequestProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockRequestProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a BlockRequestProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockRequestProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockRequestProto} BlockRequestProto
         */
        BlockRequestProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockRequestProto)
                return object;
            var message = new $root.casper.BlockRequestProto();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a BlockRequestProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockRequestProto
         * @static
         * @param {casper.BlockRequestProto} message BlockRequestProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockRequestProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this BlockRequestProto to JSON.
         * @function toJSON
         * @memberof casper.BlockRequestProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockRequestProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockRequestProto;
    })();

    casper.ForkChoiceTipRequestProto = (function() {

        /**
         * Properties of a ForkChoiceTipRequestProto.
         * @memberof casper
         * @interface IForkChoiceTipRequestProto
         */

        /**
         * Constructs a new ForkChoiceTipRequestProto.
         * @memberof casper
         * @classdesc Represents a ForkChoiceTipRequestProto.
         * @implements IForkChoiceTipRequestProto
         * @constructor
         * @param {casper.IForkChoiceTipRequestProto=} [properties] Properties to set
         */
        function ForkChoiceTipRequestProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ForkChoiceTipRequestProto instance using the specified properties.
         * @function create
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {casper.IForkChoiceTipRequestProto=} [properties] Properties to set
         * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto instance
         */
        ForkChoiceTipRequestProto.create = function create(properties) {
            return new ForkChoiceTipRequestProto(properties);
        };

        /**
         * Encodes the specified ForkChoiceTipRequestProto message. Does not implicitly {@link casper.ForkChoiceTipRequestProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {casper.IForkChoiceTipRequestProto} message ForkChoiceTipRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForkChoiceTipRequestProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ForkChoiceTipRequestProto message, length delimited. Does not implicitly {@link casper.ForkChoiceTipRequestProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {casper.IForkChoiceTipRequestProto} message ForkChoiceTipRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForkChoiceTipRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForkChoiceTipRequestProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForkChoiceTipRequestProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ForkChoiceTipRequestProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForkChoiceTipRequestProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForkChoiceTipRequestProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForkChoiceTipRequestProto message.
         * @function verify
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForkChoiceTipRequestProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ForkChoiceTipRequestProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto
         */
        ForkChoiceTipRequestProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ForkChoiceTipRequestProto)
                return object;
            return new $root.casper.ForkChoiceTipRequestProto();
        };

        /**
         * Creates a plain object from a ForkChoiceTipRequestProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ForkChoiceTipRequestProto
         * @static
         * @param {casper.ForkChoiceTipRequestProto} message ForkChoiceTipRequestProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForkChoiceTipRequestProto.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ForkChoiceTipRequestProto to JSON.
         * @function toJSON
         * @memberof casper.ForkChoiceTipRequestProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForkChoiceTipRequestProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForkChoiceTipRequestProto;
    })();

    casper.ApprovedBlockCandidateProto = (function() {

        /**
         * Properties of an ApprovedBlockCandidateProto.
         * @memberof casper
         * @interface IApprovedBlockCandidateProto
         * @property {casper.IBlockMessageProto|null} [block] ApprovedBlockCandidateProto block
         * @property {number|null} [requiredSigs] ApprovedBlockCandidateProto requiredSigs
         */

        /**
         * Constructs a new ApprovedBlockCandidateProto.
         * @memberof casper
         * @classdesc Represents an ApprovedBlockCandidateProto.
         * @implements IApprovedBlockCandidateProto
         * @constructor
         * @param {casper.IApprovedBlockCandidateProto=} [properties] Properties to set
         */
        function ApprovedBlockCandidateProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApprovedBlockCandidateProto block.
         * @member {casper.IBlockMessageProto|null|undefined} block
         * @memberof casper.ApprovedBlockCandidateProto
         * @instance
         */
        ApprovedBlockCandidateProto.prototype.block = null;

        /**
         * ApprovedBlockCandidateProto requiredSigs.
         * @member {number} requiredSigs
         * @memberof casper.ApprovedBlockCandidateProto
         * @instance
         */
        ApprovedBlockCandidateProto.prototype.requiredSigs = 0;

        /**
         * Creates a new ApprovedBlockCandidateProto instance using the specified properties.
         * @function create
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {casper.IApprovedBlockCandidateProto=} [properties] Properties to set
         * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto instance
         */
        ApprovedBlockCandidateProto.create = function create(properties) {
            return new ApprovedBlockCandidateProto(properties);
        };

        /**
         * Encodes the specified ApprovedBlockCandidateProto message. Does not implicitly {@link casper.ApprovedBlockCandidateProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {casper.IApprovedBlockCandidateProto} message ApprovedBlockCandidateProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovedBlockCandidateProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.block != null && message.hasOwnProperty("block"))
                $root.casper.BlockMessageProto.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.requiredSigs != null && message.hasOwnProperty("requiredSigs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.requiredSigs);
            return writer;
        };

        /**
         * Encodes the specified ApprovedBlockCandidateProto message, length delimited. Does not implicitly {@link casper.ApprovedBlockCandidateProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {casper.IApprovedBlockCandidateProto} message ApprovedBlockCandidateProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovedBlockCandidateProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApprovedBlockCandidateProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovedBlockCandidateProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ApprovedBlockCandidateProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.block = $root.casper.BlockMessageProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.requiredSigs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApprovedBlockCandidateProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovedBlockCandidateProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApprovedBlockCandidateProto message.
         * @function verify
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApprovedBlockCandidateProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.block != null && message.hasOwnProperty("block")) {
                var error = $root.casper.BlockMessageProto.verify(message.block);
                if (error)
                    return "block." + error;
            }
            if (message.requiredSigs != null && message.hasOwnProperty("requiredSigs"))
                if (!$util.isInteger(message.requiredSigs))
                    return "requiredSigs: integer expected";
            return null;
        };

        /**
         * Creates an ApprovedBlockCandidateProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto
         */
        ApprovedBlockCandidateProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ApprovedBlockCandidateProto)
                return object;
            var message = new $root.casper.ApprovedBlockCandidateProto();
            if (object.block != null) {
                if (typeof object.block !== "object")
                    throw TypeError(".casper.ApprovedBlockCandidateProto.block: object expected");
                message.block = $root.casper.BlockMessageProto.fromObject(object.block);
            }
            if (object.requiredSigs != null)
                message.requiredSigs = object.requiredSigs | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApprovedBlockCandidateProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ApprovedBlockCandidateProto
         * @static
         * @param {casper.ApprovedBlockCandidateProto} message ApprovedBlockCandidateProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApprovedBlockCandidateProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.block = null;
                object.requiredSigs = 0;
            }
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = $root.casper.BlockMessageProto.toObject(message.block, options);
            if (message.requiredSigs != null && message.hasOwnProperty("requiredSigs"))
                object.requiredSigs = message.requiredSigs;
            return object;
        };

        /**
         * Converts this ApprovedBlockCandidateProto to JSON.
         * @function toJSON
         * @memberof casper.ApprovedBlockCandidateProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApprovedBlockCandidateProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApprovedBlockCandidateProto;
    })();

    casper.UnapprovedBlockProto = (function() {

        /**
         * Properties of an UnapprovedBlockProto.
         * @memberof casper
         * @interface IUnapprovedBlockProto
         * @property {casper.IApprovedBlockCandidateProto|null} [candidate] UnapprovedBlockProto candidate
         * @property {number|Long|null} [timestamp] UnapprovedBlockProto timestamp
         * @property {number|Long|null} [duration] UnapprovedBlockProto duration
         */

        /**
         * Constructs a new UnapprovedBlockProto.
         * @memberof casper
         * @classdesc Represents an UnapprovedBlockProto.
         * @implements IUnapprovedBlockProto
         * @constructor
         * @param {casper.IUnapprovedBlockProto=} [properties] Properties to set
         */
        function UnapprovedBlockProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnapprovedBlockProto candidate.
         * @member {casper.IApprovedBlockCandidateProto|null|undefined} candidate
         * @memberof casper.UnapprovedBlockProto
         * @instance
         */
        UnapprovedBlockProto.prototype.candidate = null;

        /**
         * UnapprovedBlockProto timestamp.
         * @member {number|Long} timestamp
         * @memberof casper.UnapprovedBlockProto
         * @instance
         */
        UnapprovedBlockProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UnapprovedBlockProto duration.
         * @member {number|Long} duration
         * @memberof casper.UnapprovedBlockProto
         * @instance
         */
        UnapprovedBlockProto.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UnapprovedBlockProto instance using the specified properties.
         * @function create
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {casper.IUnapprovedBlockProto=} [properties] Properties to set
         * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto instance
         */
        UnapprovedBlockProto.create = function create(properties) {
            return new UnapprovedBlockProto(properties);
        };

        /**
         * Encodes the specified UnapprovedBlockProto message. Does not implicitly {@link casper.UnapprovedBlockProto.verify|verify} messages.
         * @function encode
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {casper.IUnapprovedBlockProto} message UnapprovedBlockProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnapprovedBlockProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.candidate != null && message.hasOwnProperty("candidate"))
                $root.casper.ApprovedBlockCandidateProto.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
            if (message.duration != null && message.hasOwnProperty("duration"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.duration);
            return writer;
        };

        /**
         * Encodes the specified UnapprovedBlockProto message, length delimited. Does not implicitly {@link casper.UnapprovedBlockProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {casper.IUnapprovedBlockProto} message UnapprovedBlockProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnapprovedBlockProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnapprovedBlockProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnapprovedBlockProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.UnapprovedBlockProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.candidate = $root.casper.ApprovedBlockCandidateProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.timestamp = reader.int64();
                    break;
                case 3:
                    message.duration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnapprovedBlockProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnapprovedBlockProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnapprovedBlockProto message.
         * @function verify
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnapprovedBlockProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.candidate != null && message.hasOwnProperty("candidate")) {
                var error = $root.casper.ApprovedBlockCandidateProto.verify(message.candidate);
                if (error)
                    return "candidate." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
                    return "duration: integer|Long expected";
            return null;
        };

        /**
         * Creates an UnapprovedBlockProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto
         */
        UnapprovedBlockProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.UnapprovedBlockProto)
                return object;
            var message = new $root.casper.UnapprovedBlockProto();
            if (object.candidate != null) {
                if (typeof object.candidate !== "object")
                    throw TypeError(".casper.UnapprovedBlockProto.candidate: object expected");
                message.candidate = $root.casper.ApprovedBlockCandidateProto.fromObject(object.candidate);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.duration != null)
                if ($util.Long)
                    (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
                else if (typeof object.duration === "string")
                    message.duration = parseInt(object.duration, 10);
                else if (typeof object.duration === "number")
                    message.duration = object.duration;
                else if (typeof object.duration === "object")
                    message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UnapprovedBlockProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.UnapprovedBlockProto
         * @static
         * @param {casper.UnapprovedBlockProto} message UnapprovedBlockProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnapprovedBlockProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.candidate = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.duration = options.longs === String ? "0" : 0;
            }
            if (message.candidate != null && message.hasOwnProperty("candidate"))
                object.candidate = $root.casper.ApprovedBlockCandidateProto.toObject(message.candidate, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration === "number")
                    object.duration = options.longs === String ? String(message.duration) : message.duration;
                else
                    object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
            return object;
        };

        /**
         * Converts this UnapprovedBlockProto to JSON.
         * @function toJSON
         * @memberof casper.UnapprovedBlockProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnapprovedBlockProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnapprovedBlockProto;
    })();

    casper.Signature = (function() {

        /**
         * Properties of a Signature.
         * @memberof casper
         * @interface ISignature
         * @property {Uint8Array|null} [publicKey] Signature publicKey
         * @property {string|null} [algorithm] Signature algorithm
         * @property {Uint8Array|null} [sig] Signature sig
         */

        /**
         * Constructs a new Signature.
         * @memberof casper
         * @classdesc Represents a Signature.
         * @implements ISignature
         * @constructor
         * @param {casper.ISignature=} [properties] Properties to set
         */
        function Signature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Signature publicKey.
         * @member {Uint8Array} publicKey
         * @memberof casper.Signature
         * @instance
         */
        Signature.prototype.publicKey = $util.newBuffer([]);

        /**
         * Signature algorithm.
         * @member {string} algorithm
         * @memberof casper.Signature
         * @instance
         */
        Signature.prototype.algorithm = "";

        /**
         * Signature sig.
         * @member {Uint8Array} sig
         * @memberof casper.Signature
         * @instance
         */
        Signature.prototype.sig = $util.newBuffer([]);

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof casper.Signature
         * @static
         * @param {casper.ISignature=} [properties] Properties to set
         * @returns {casper.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link casper.Signature.verify|verify} messages.
         * @function encode
         * @memberof casper.Signature
         * @static
         * @param {casper.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.algorithm);
            if (message.sig != null && message.hasOwnProperty("sig"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sig);
            return writer;
        };

        /**
         * Encodes the specified Signature message, length delimited. Does not implicitly {@link casper.Signature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.Signature
         * @static
         * @param {casper.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof casper.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.Signature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.algorithm = reader.string();
                    break;
                case 3:
                    message.sig = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Signature message.
         * @function verify
         * @memberof casper.Signature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Signature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isString(message.algorithm))
                    return "algorithm: string expected";
            if (message.sig != null && message.hasOwnProperty("sig"))
                if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                    return "sig: buffer expected";
            return null;
        };

        /**
         * Creates a Signature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.Signature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.Signature} Signature
         */
        Signature.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.Signature)
                return object;
            var message = new $root.casper.Signature();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.algorithm != null)
                message.algorithm = String(object.algorithm);
            if (object.sig != null)
                if (typeof object.sig === "string")
                    $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
                else if (object.sig.length)
                    message.sig = object.sig;
            return message;
        };

        /**
         * Creates a plain object from a Signature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.Signature
         * @static
         * @param {casper.Signature} message Signature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Signature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.algorithm = "";
                if (options.bytes === String)
                    object.sig = "";
                else {
                    object.sig = [];
                    if (options.bytes !== Array)
                        object.sig = $util.newBuffer(object.sig);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            if (message.sig != null && message.hasOwnProperty("sig"))
                object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
            return object;
        };

        /**
         * Converts this Signature to JSON.
         * @function toJSON
         * @memberof casper.Signature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Signature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Signature;
    })();

    casper.BlockApprovalProto = (function() {

        /**
         * Properties of a BlockApprovalProto.
         * @memberof casper
         * @interface IBlockApprovalProto
         * @property {casper.IApprovedBlockCandidateProto|null} [candidate] BlockApprovalProto candidate
         * @property {casper.ISignature|null} [sig] BlockApprovalProto sig
         */

        /**
         * Constructs a new BlockApprovalProto.
         * @memberof casper
         * @classdesc Represents a BlockApprovalProto.
         * @implements IBlockApprovalProto
         * @constructor
         * @param {casper.IBlockApprovalProto=} [properties] Properties to set
         */
        function BlockApprovalProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockApprovalProto candidate.
         * @member {casper.IApprovedBlockCandidateProto|null|undefined} candidate
         * @memberof casper.BlockApprovalProto
         * @instance
         */
        BlockApprovalProto.prototype.candidate = null;

        /**
         * BlockApprovalProto sig.
         * @member {casper.ISignature|null|undefined} sig
         * @memberof casper.BlockApprovalProto
         * @instance
         */
        BlockApprovalProto.prototype.sig = null;

        /**
         * Creates a new BlockApprovalProto instance using the specified properties.
         * @function create
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {casper.IBlockApprovalProto=} [properties] Properties to set
         * @returns {casper.BlockApprovalProto} BlockApprovalProto instance
         */
        BlockApprovalProto.create = function create(properties) {
            return new BlockApprovalProto(properties);
        };

        /**
         * Encodes the specified BlockApprovalProto message. Does not implicitly {@link casper.BlockApprovalProto.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {casper.IBlockApprovalProto} message BlockApprovalProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockApprovalProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.candidate != null && message.hasOwnProperty("candidate"))
                $root.casper.ApprovedBlockCandidateProto.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sig != null && message.hasOwnProperty("sig"))
                $root.casper.Signature.encode(message.sig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BlockApprovalProto message, length delimited. Does not implicitly {@link casper.BlockApprovalProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {casper.IBlockApprovalProto} message BlockApprovalProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockApprovalProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockApprovalProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockApprovalProto} BlockApprovalProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockApprovalProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockApprovalProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.candidate = $root.casper.ApprovedBlockCandidateProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sig = $root.casper.Signature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockApprovalProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockApprovalProto} BlockApprovalProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockApprovalProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockApprovalProto message.
         * @function verify
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockApprovalProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.candidate != null && message.hasOwnProperty("candidate")) {
                var error = $root.casper.ApprovedBlockCandidateProto.verify(message.candidate);
                if (error)
                    return "candidate." + error;
            }
            if (message.sig != null && message.hasOwnProperty("sig")) {
                var error = $root.casper.Signature.verify(message.sig);
                if (error)
                    return "sig." + error;
            }
            return null;
        };

        /**
         * Creates a BlockApprovalProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockApprovalProto} BlockApprovalProto
         */
        BlockApprovalProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockApprovalProto)
                return object;
            var message = new $root.casper.BlockApprovalProto();
            if (object.candidate != null) {
                if (typeof object.candidate !== "object")
                    throw TypeError(".casper.BlockApprovalProto.candidate: object expected");
                message.candidate = $root.casper.ApprovedBlockCandidateProto.fromObject(object.candidate);
            }
            if (object.sig != null) {
                if (typeof object.sig !== "object")
                    throw TypeError(".casper.BlockApprovalProto.sig: object expected");
                message.sig = $root.casper.Signature.fromObject(object.sig);
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockApprovalProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockApprovalProto
         * @static
         * @param {casper.BlockApprovalProto} message BlockApprovalProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockApprovalProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.candidate = null;
                object.sig = null;
            }
            if (message.candidate != null && message.hasOwnProperty("candidate"))
                object.candidate = $root.casper.ApprovedBlockCandidateProto.toObject(message.candidate, options);
            if (message.sig != null && message.hasOwnProperty("sig"))
                object.sig = $root.casper.Signature.toObject(message.sig, options);
            return object;
        };

        /**
         * Converts this BlockApprovalProto to JSON.
         * @function toJSON
         * @memberof casper.BlockApprovalProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockApprovalProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockApprovalProto;
    })();

    casper.ApprovedBlockProto = (function() {

        /**
         * Properties of an ApprovedBlockProto.
         * @memberof casper
         * @interface IApprovedBlockProto
         * @property {casper.IApprovedBlockCandidateProto|null} [candidate] ApprovedBlockProto candidate
         * @property {Array.<casper.ISignature>|null} [sigs] ApprovedBlockProto sigs
         */

        /**
         * Constructs a new ApprovedBlockProto.
         * @memberof casper
         * @classdesc Represents an ApprovedBlockProto.
         * @implements IApprovedBlockProto
         * @constructor
         * @param {casper.IApprovedBlockProto=} [properties] Properties to set
         */
        function ApprovedBlockProto(properties) {
            this.sigs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApprovedBlockProto candidate.
         * @member {casper.IApprovedBlockCandidateProto|null|undefined} candidate
         * @memberof casper.ApprovedBlockProto
         * @instance
         */
        ApprovedBlockProto.prototype.candidate = null;

        /**
         * ApprovedBlockProto sigs.
         * @member {Array.<casper.ISignature>} sigs
         * @memberof casper.ApprovedBlockProto
         * @instance
         */
        ApprovedBlockProto.prototype.sigs = $util.emptyArray;

        /**
         * Creates a new ApprovedBlockProto instance using the specified properties.
         * @function create
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {casper.IApprovedBlockProto=} [properties] Properties to set
         * @returns {casper.ApprovedBlockProto} ApprovedBlockProto instance
         */
        ApprovedBlockProto.create = function create(properties) {
            return new ApprovedBlockProto(properties);
        };

        /**
         * Encodes the specified ApprovedBlockProto message. Does not implicitly {@link casper.ApprovedBlockProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {casper.IApprovedBlockProto} message ApprovedBlockProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovedBlockProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.candidate != null && message.hasOwnProperty("candidate"))
                $root.casper.ApprovedBlockCandidateProto.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sigs != null && message.sigs.length)
                for (var i = 0; i < message.sigs.length; ++i)
                    $root.casper.Signature.encode(message.sigs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApprovedBlockProto message, length delimited. Does not implicitly {@link casper.ApprovedBlockProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {casper.IApprovedBlockProto} message ApprovedBlockProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovedBlockProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApprovedBlockProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ApprovedBlockProto} ApprovedBlockProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovedBlockProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ApprovedBlockProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.candidate = $root.casper.ApprovedBlockCandidateProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.sigs && message.sigs.length))
                        message.sigs = [];
                    message.sigs.push($root.casper.Signature.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApprovedBlockProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ApprovedBlockProto} ApprovedBlockProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovedBlockProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApprovedBlockProto message.
         * @function verify
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApprovedBlockProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.candidate != null && message.hasOwnProperty("candidate")) {
                var error = $root.casper.ApprovedBlockCandidateProto.verify(message.candidate);
                if (error)
                    return "candidate." + error;
            }
            if (message.sigs != null && message.hasOwnProperty("sigs")) {
                if (!Array.isArray(message.sigs))
                    return "sigs: array expected";
                for (var i = 0; i < message.sigs.length; ++i) {
                    var error = $root.casper.Signature.verify(message.sigs[i]);
                    if (error)
                        return "sigs." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ApprovedBlockProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ApprovedBlockProto} ApprovedBlockProto
         */
        ApprovedBlockProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ApprovedBlockProto)
                return object;
            var message = new $root.casper.ApprovedBlockProto();
            if (object.candidate != null) {
                if (typeof object.candidate !== "object")
                    throw TypeError(".casper.ApprovedBlockProto.candidate: object expected");
                message.candidate = $root.casper.ApprovedBlockCandidateProto.fromObject(object.candidate);
            }
            if (object.sigs) {
                if (!Array.isArray(object.sigs))
                    throw TypeError(".casper.ApprovedBlockProto.sigs: array expected");
                message.sigs = [];
                for (var i = 0; i < object.sigs.length; ++i) {
                    if (typeof object.sigs[i] !== "object")
                        throw TypeError(".casper.ApprovedBlockProto.sigs: object expected");
                    message.sigs[i] = $root.casper.Signature.fromObject(object.sigs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ApprovedBlockProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ApprovedBlockProto
         * @static
         * @param {casper.ApprovedBlockProto} message ApprovedBlockProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApprovedBlockProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sigs = [];
            if (options.defaults)
                object.candidate = null;
            if (message.candidate != null && message.hasOwnProperty("candidate"))
                object.candidate = $root.casper.ApprovedBlockCandidateProto.toObject(message.candidate, options);
            if (message.sigs && message.sigs.length) {
                object.sigs = [];
                for (var j = 0; j < message.sigs.length; ++j)
                    object.sigs[j] = $root.casper.Signature.toObject(message.sigs[j], options);
            }
            return object;
        };

        /**
         * Converts this ApprovedBlockProto to JSON.
         * @function toJSON
         * @memberof casper.ApprovedBlockProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApprovedBlockProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApprovedBlockProto;
    })();

    casper.ApprovedBlockRequestProto = (function() {

        /**
         * Properties of an ApprovedBlockRequestProto.
         * @memberof casper
         * @interface IApprovedBlockRequestProto
         * @property {string|null} [identifier] ApprovedBlockRequestProto identifier
         */

        /**
         * Constructs a new ApprovedBlockRequestProto.
         * @memberof casper
         * @classdesc Represents an ApprovedBlockRequestProto.
         * @implements IApprovedBlockRequestProto
         * @constructor
         * @param {casper.IApprovedBlockRequestProto=} [properties] Properties to set
         */
        function ApprovedBlockRequestProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApprovedBlockRequestProto identifier.
         * @member {string} identifier
         * @memberof casper.ApprovedBlockRequestProto
         * @instance
         */
        ApprovedBlockRequestProto.prototype.identifier = "";

        /**
         * Creates a new ApprovedBlockRequestProto instance using the specified properties.
         * @function create
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {casper.IApprovedBlockRequestProto=} [properties] Properties to set
         * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto instance
         */
        ApprovedBlockRequestProto.create = function create(properties) {
            return new ApprovedBlockRequestProto(properties);
        };

        /**
         * Encodes the specified ApprovedBlockRequestProto message. Does not implicitly {@link casper.ApprovedBlockRequestProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {casper.IApprovedBlockRequestProto} message ApprovedBlockRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovedBlockRequestProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
            return writer;
        };

        /**
         * Encodes the specified ApprovedBlockRequestProto message, length delimited. Does not implicitly {@link casper.ApprovedBlockRequestProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {casper.IApprovedBlockRequestProto} message ApprovedBlockRequestProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovedBlockRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApprovedBlockRequestProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovedBlockRequestProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ApprovedBlockRequestProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identifier = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApprovedBlockRequestProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovedBlockRequestProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApprovedBlockRequestProto message.
         * @function verify
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApprovedBlockRequestProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                if (!$util.isString(message.identifier))
                    return "identifier: string expected";
            return null;
        };

        /**
         * Creates an ApprovedBlockRequestProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto
         */
        ApprovedBlockRequestProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ApprovedBlockRequestProto)
                return object;
            var message = new $root.casper.ApprovedBlockRequestProto();
            if (object.identifier != null)
                message.identifier = String(object.identifier);
            return message;
        };

        /**
         * Creates a plain object from an ApprovedBlockRequestProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ApprovedBlockRequestProto
         * @static
         * @param {casper.ApprovedBlockRequestProto} message ApprovedBlockRequestProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApprovedBlockRequestProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.identifier = "";
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                object.identifier = message.identifier;
            return object;
        };

        /**
         * Converts this ApprovedBlockRequestProto to JSON.
         * @function toJSON
         * @memberof casper.ApprovedBlockRequestProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApprovedBlockRequestProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApprovedBlockRequestProto;
    })();

    casper.NoApprovedBlockAvailableProto = (function() {

        /**
         * Properties of a NoApprovedBlockAvailableProto.
         * @memberof casper
         * @interface INoApprovedBlockAvailableProto
         * @property {string|null} [identifier] NoApprovedBlockAvailableProto identifier
         * @property {string|null} [nodeIdentifer] NoApprovedBlockAvailableProto nodeIdentifer
         */

        /**
         * Constructs a new NoApprovedBlockAvailableProto.
         * @memberof casper
         * @classdesc Represents a NoApprovedBlockAvailableProto.
         * @implements INoApprovedBlockAvailableProto
         * @constructor
         * @param {casper.INoApprovedBlockAvailableProto=} [properties] Properties to set
         */
        function NoApprovedBlockAvailableProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoApprovedBlockAvailableProto identifier.
         * @member {string} identifier
         * @memberof casper.NoApprovedBlockAvailableProto
         * @instance
         */
        NoApprovedBlockAvailableProto.prototype.identifier = "";

        /**
         * NoApprovedBlockAvailableProto nodeIdentifer.
         * @member {string} nodeIdentifer
         * @memberof casper.NoApprovedBlockAvailableProto
         * @instance
         */
        NoApprovedBlockAvailableProto.prototype.nodeIdentifer = "";

        /**
         * Creates a new NoApprovedBlockAvailableProto instance using the specified properties.
         * @function create
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {casper.INoApprovedBlockAvailableProto=} [properties] Properties to set
         * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto instance
         */
        NoApprovedBlockAvailableProto.create = function create(properties) {
            return new NoApprovedBlockAvailableProto(properties);
        };

        /**
         * Encodes the specified NoApprovedBlockAvailableProto message. Does not implicitly {@link casper.NoApprovedBlockAvailableProto.verify|verify} messages.
         * @function encode
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {casper.INoApprovedBlockAvailableProto} message NoApprovedBlockAvailableProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoApprovedBlockAvailableProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
            if (message.nodeIdentifer != null && message.hasOwnProperty("nodeIdentifer"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodeIdentifer);
            return writer;
        };

        /**
         * Encodes the specified NoApprovedBlockAvailableProto message, length delimited. Does not implicitly {@link casper.NoApprovedBlockAvailableProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {casper.INoApprovedBlockAvailableProto} message NoApprovedBlockAvailableProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoApprovedBlockAvailableProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoApprovedBlockAvailableProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoApprovedBlockAvailableProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.NoApprovedBlockAvailableProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identifier = reader.string();
                    break;
                case 2:
                    message.nodeIdentifer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoApprovedBlockAvailableProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoApprovedBlockAvailableProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoApprovedBlockAvailableProto message.
         * @function verify
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoApprovedBlockAvailableProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                if (!$util.isString(message.identifier))
                    return "identifier: string expected";
            if (message.nodeIdentifer != null && message.hasOwnProperty("nodeIdentifer"))
                if (!$util.isString(message.nodeIdentifer))
                    return "nodeIdentifer: string expected";
            return null;
        };

        /**
         * Creates a NoApprovedBlockAvailableProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto
         */
        NoApprovedBlockAvailableProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.NoApprovedBlockAvailableProto)
                return object;
            var message = new $root.casper.NoApprovedBlockAvailableProto();
            if (object.identifier != null)
                message.identifier = String(object.identifier);
            if (object.nodeIdentifer != null)
                message.nodeIdentifer = String(object.nodeIdentifer);
            return message;
        };

        /**
         * Creates a plain object from a NoApprovedBlockAvailableProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.NoApprovedBlockAvailableProto
         * @static
         * @param {casper.NoApprovedBlockAvailableProto} message NoApprovedBlockAvailableProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoApprovedBlockAvailableProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.identifier = "";
                object.nodeIdentifer = "";
            }
            if (message.identifier != null && message.hasOwnProperty("identifier"))
                object.identifier = message.identifier;
            if (message.nodeIdentifer != null && message.hasOwnProperty("nodeIdentifer"))
                object.nodeIdentifer = message.nodeIdentifer;
            return object;
        };

        /**
         * Converts this NoApprovedBlockAvailableProto to JSON.
         * @function toJSON
         * @memberof casper.NoApprovedBlockAvailableProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoApprovedBlockAvailableProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NoApprovedBlockAvailableProto;
    })();

    casper.BlockMessageProto = (function() {

        /**
         * Properties of a BlockMessageProto.
         * @memberof casper
         * @interface IBlockMessageProto
         * @property {Uint8Array|null} [blockHash] BlockMessageProto blockHash
         * @property {casper.IHeaderProto|null} [header] BlockMessageProto header
         * @property {casper.IBodyProto|null} [body] BlockMessageProto body
         * @property {Array.<casper.IJustificationProto>|null} [justifications] BlockMessageProto justifications
         * @property {Uint8Array|null} [sender] BlockMessageProto sender
         * @property {number|null} [seqNum] BlockMessageProto seqNum
         * @property {Uint8Array|null} [sig] BlockMessageProto sig
         * @property {string|null} [sigAlgorithm] BlockMessageProto sigAlgorithm
         * @property {string|null} [shardId] BlockMessageProto shardId
         * @property {Uint8Array|null} [extraBytes] BlockMessageProto extraBytes
         */

        /**
         * Constructs a new BlockMessageProto.
         * @memberof casper
         * @classdesc Represents a BlockMessageProto.
         * @implements IBlockMessageProto
         * @constructor
         * @param {casper.IBlockMessageProto=} [properties] Properties to set
         */
        function BlockMessageProto(properties) {
            this.justifications = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockMessageProto blockHash.
         * @member {Uint8Array} blockHash
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.blockHash = $util.newBuffer([]);

        /**
         * BlockMessageProto header.
         * @member {casper.IHeaderProto|null|undefined} header
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.header = null;

        /**
         * BlockMessageProto body.
         * @member {casper.IBodyProto|null|undefined} body
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.body = null;

        /**
         * BlockMessageProto justifications.
         * @member {Array.<casper.IJustificationProto>} justifications
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.justifications = $util.emptyArray;

        /**
         * BlockMessageProto sender.
         * @member {Uint8Array} sender
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.sender = $util.newBuffer([]);

        /**
         * BlockMessageProto seqNum.
         * @member {number} seqNum
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.seqNum = 0;

        /**
         * BlockMessageProto sig.
         * @member {Uint8Array} sig
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.sig = $util.newBuffer([]);

        /**
         * BlockMessageProto sigAlgorithm.
         * @member {string} sigAlgorithm
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.sigAlgorithm = "";

        /**
         * BlockMessageProto shardId.
         * @member {string} shardId
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.shardId = "";

        /**
         * BlockMessageProto extraBytes.
         * @member {Uint8Array} extraBytes
         * @memberof casper.BlockMessageProto
         * @instance
         */
        BlockMessageProto.prototype.extraBytes = $util.newBuffer([]);

        /**
         * Creates a new BlockMessageProto instance using the specified properties.
         * @function create
         * @memberof casper.BlockMessageProto
         * @static
         * @param {casper.IBlockMessageProto=} [properties] Properties to set
         * @returns {casper.BlockMessageProto} BlockMessageProto instance
         */
        BlockMessageProto.create = function create(properties) {
            return new BlockMessageProto(properties);
        };

        /**
         * Encodes the specified BlockMessageProto message. Does not implicitly {@link casper.BlockMessageProto.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockMessageProto
         * @static
         * @param {casper.IBlockMessageProto} message BlockMessageProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockMessageProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockHash);
            if (message.header != null && message.hasOwnProperty("header"))
                $root.casper.HeaderProto.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.body != null && message.hasOwnProperty("body"))
                $root.casper.BodyProto.encode(message.body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.justifications != null && message.justifications.length)
                for (var i = 0; i < message.justifications.length; ++i)
                    $root.casper.JustificationProto.encode(message.justifications[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.sender != null && message.hasOwnProperty("sender"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sender);
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.seqNum);
            if (message.sig != null && message.hasOwnProperty("sig"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.sig);
            if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sigAlgorithm);
            if (message.shardId != null && message.hasOwnProperty("shardId"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.shardId);
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.extraBytes);
            return writer;
        };

        /**
         * Encodes the specified BlockMessageProto message, length delimited. Does not implicitly {@link casper.BlockMessageProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockMessageProto
         * @static
         * @param {casper.IBlockMessageProto} message BlockMessageProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockMessageProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockMessageProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockMessageProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockMessageProto} BlockMessageProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockMessageProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockMessageProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockHash = reader.bytes();
                    break;
                case 2:
                    message.header = $root.casper.HeaderProto.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.body = $root.casper.BodyProto.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.justifications && message.justifications.length))
                        message.justifications = [];
                    message.justifications.push($root.casper.JustificationProto.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.sender = reader.bytes();
                    break;
                case 6:
                    message.seqNum = reader.int32();
                    break;
                case 7:
                    message.sig = reader.bytes();
                    break;
                case 8:
                    message.sigAlgorithm = reader.string();
                    break;
                case 9:
                    message.shardId = reader.string();
                    break;
                case 10:
                    message.extraBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockMessageProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockMessageProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockMessageProto} BlockMessageProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockMessageProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockMessageProto message.
         * @function verify
         * @memberof casper.BlockMessageProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockMessageProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                    return "blockHash: buffer expected";
            if (message.header != null && message.hasOwnProperty("header")) {
                var error = $root.casper.HeaderProto.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.body != null && message.hasOwnProperty("body")) {
                var error = $root.casper.BodyProto.verify(message.body);
                if (error)
                    return "body." + error;
            }
            if (message.justifications != null && message.hasOwnProperty("justifications")) {
                if (!Array.isArray(message.justifications))
                    return "justifications: array expected";
                for (var i = 0; i < message.justifications.length; ++i) {
                    var error = $root.casper.JustificationProto.verify(message.justifications[i]);
                    if (error)
                        return "justifications." + error;
                }
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                    return "sender: buffer expected";
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                if (!$util.isInteger(message.seqNum))
                    return "seqNum: integer expected";
            if (message.sig != null && message.hasOwnProperty("sig"))
                if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                    return "sig: buffer expected";
            if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                if (!$util.isString(message.sigAlgorithm))
                    return "sigAlgorithm: string expected";
            if (message.shardId != null && message.hasOwnProperty("shardId"))
                if (!$util.isString(message.shardId))
                    return "shardId: string expected";
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                    return "extraBytes: buffer expected";
            return null;
        };

        /**
         * Creates a BlockMessageProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockMessageProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockMessageProto} BlockMessageProto
         */
        BlockMessageProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockMessageProto)
                return object;
            var message = new $root.casper.BlockMessageProto();
            if (object.blockHash != null)
                if (typeof object.blockHash === "string")
                    $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                else if (object.blockHash.length)
                    message.blockHash = object.blockHash;
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".casper.BlockMessageProto.header: object expected");
                message.header = $root.casper.HeaderProto.fromObject(object.header);
            }
            if (object.body != null) {
                if (typeof object.body !== "object")
                    throw TypeError(".casper.BlockMessageProto.body: object expected");
                message.body = $root.casper.BodyProto.fromObject(object.body);
            }
            if (object.justifications) {
                if (!Array.isArray(object.justifications))
                    throw TypeError(".casper.BlockMessageProto.justifications: array expected");
                message.justifications = [];
                for (var i = 0; i < object.justifications.length; ++i) {
                    if (typeof object.justifications[i] !== "object")
                        throw TypeError(".casper.BlockMessageProto.justifications: object expected");
                    message.justifications[i] = $root.casper.JustificationProto.fromObject(object.justifications[i]);
                }
            }
            if (object.sender != null)
                if (typeof object.sender === "string")
                    $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                else if (object.sender.length)
                    message.sender = object.sender;
            if (object.seqNum != null)
                message.seqNum = object.seqNum | 0;
            if (object.sig != null)
                if (typeof object.sig === "string")
                    $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
                else if (object.sig.length)
                    message.sig = object.sig;
            if (object.sigAlgorithm != null)
                message.sigAlgorithm = String(object.sigAlgorithm);
            if (object.shardId != null)
                message.shardId = String(object.shardId);
            if (object.extraBytes != null)
                if (typeof object.extraBytes === "string")
                    $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                else if (object.extraBytes.length)
                    message.extraBytes = object.extraBytes;
            return message;
        };

        /**
         * Creates a plain object from a BlockMessageProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockMessageProto
         * @static
         * @param {casper.BlockMessageProto} message BlockMessageProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockMessageProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.justifications = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockHash = "";
                else {
                    object.blockHash = [];
                    if (options.bytes !== Array)
                        object.blockHash = $util.newBuffer(object.blockHash);
                }
                object.header = null;
                object.body = null;
                if (options.bytes === String)
                    object.sender = "";
                else {
                    object.sender = [];
                    if (options.bytes !== Array)
                        object.sender = $util.newBuffer(object.sender);
                }
                object.seqNum = 0;
                if (options.bytes === String)
                    object.sig = "";
                else {
                    object.sig = [];
                    if (options.bytes !== Array)
                        object.sig = $util.newBuffer(object.sig);
                }
                object.sigAlgorithm = "";
                object.shardId = "";
                if (options.bytes === String)
                    object.extraBytes = "";
                else {
                    object.extraBytes = [];
                    if (options.bytes !== Array)
                        object.extraBytes = $util.newBuffer(object.extraBytes);
                }
            }
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.casper.HeaderProto.toObject(message.header, options);
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = $root.casper.BodyProto.toObject(message.body, options);
            if (message.justifications && message.justifications.length) {
                object.justifications = [];
                for (var j = 0; j < message.justifications.length; ++j)
                    object.justifications[j] = $root.casper.JustificationProto.toObject(message.justifications[j], options);
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                object.seqNum = message.seqNum;
            if (message.sig != null && message.hasOwnProperty("sig"))
                object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
            if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                object.sigAlgorithm = message.sigAlgorithm;
            if (message.shardId != null && message.hasOwnProperty("shardId"))
                object.shardId = message.shardId;
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
            return object;
        };

        /**
         * Converts this BlockMessageProto to JSON.
         * @function toJSON
         * @memberof casper.BlockMessageProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockMessageProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockMessageProto;
    })();

    casper.BlockHashMessageProto = (function() {

        /**
         * Properties of a BlockHashMessageProto.
         * @memberof casper
         * @interface IBlockHashMessageProto
         * @property {Uint8Array|null} [hash] BlockHashMessageProto hash
         */

        /**
         * Constructs a new BlockHashMessageProto.
         * @memberof casper
         * @classdesc Represents a BlockHashMessageProto.
         * @implements IBlockHashMessageProto
         * @constructor
         * @param {casper.IBlockHashMessageProto=} [properties] Properties to set
         */
        function BlockHashMessageProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockHashMessageProto hash.
         * @member {Uint8Array} hash
         * @memberof casper.BlockHashMessageProto
         * @instance
         */
        BlockHashMessageProto.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new BlockHashMessageProto instance using the specified properties.
         * @function create
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {casper.IBlockHashMessageProto=} [properties] Properties to set
         * @returns {casper.BlockHashMessageProto} BlockHashMessageProto instance
         */
        BlockHashMessageProto.create = function create(properties) {
            return new BlockHashMessageProto(properties);
        };

        /**
         * Encodes the specified BlockHashMessageProto message. Does not implicitly {@link casper.BlockHashMessageProto.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {casper.IBlockHashMessageProto} message BlockHashMessageProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockHashMessageProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified BlockHashMessageProto message, length delimited. Does not implicitly {@link casper.BlockHashMessageProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {casper.IBlockHashMessageProto} message BlockHashMessageProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockHashMessageProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockHashMessageProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockHashMessageProto} BlockHashMessageProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockHashMessageProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockHashMessageProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockHashMessageProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockHashMessageProto} BlockHashMessageProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockHashMessageProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockHashMessageProto message.
         * @function verify
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockHashMessageProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a BlockHashMessageProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockHashMessageProto} BlockHashMessageProto
         */
        BlockHashMessageProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockHashMessageProto)
                return object;
            var message = new $root.casper.BlockHashMessageProto();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a BlockHashMessageProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockHashMessageProto
         * @static
         * @param {casper.BlockHashMessageProto} message BlockHashMessageProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockHashMessageProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this BlockHashMessageProto to JSON.
         * @function toJSON
         * @memberof casper.BlockHashMessageProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockHashMessageProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockHashMessageProto;
    })();

    casper.BlockMetadataInternal = (function() {

        /**
         * Properties of a BlockMetadataInternal.
         * @memberof casper
         * @interface IBlockMetadataInternal
         * @property {Uint8Array|null} [blockHash] BlockMetadataInternal blockHash
         * @property {Array.<Uint8Array>|null} [parents] BlockMetadataInternal parents
         * @property {Uint8Array|null} [sender] BlockMetadataInternal sender
         * @property {Array.<casper.IJustificationProto>|null} [justifications] BlockMetadataInternal justifications
         * @property {Array.<casper.IBondProto>|null} [bonds] BlockMetadataInternal bonds
         * @property {number|Long|null} [blockNum] BlockMetadataInternal blockNum
         * @property {number|null} [seqNum] BlockMetadataInternal seqNum
         * @property {boolean|null} [invalid] BlockMetadataInternal invalid
         */

        /**
         * Constructs a new BlockMetadataInternal.
         * @memberof casper
         * @classdesc Represents a BlockMetadataInternal.
         * @implements IBlockMetadataInternal
         * @constructor
         * @param {casper.IBlockMetadataInternal=} [properties] Properties to set
         */
        function BlockMetadataInternal(properties) {
            this.parents = [];
            this.justifications = [];
            this.bonds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockMetadataInternal blockHash.
         * @member {Uint8Array} blockHash
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.blockHash = $util.newBuffer([]);

        /**
         * BlockMetadataInternal parents.
         * @member {Array.<Uint8Array>} parents
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.parents = $util.emptyArray;

        /**
         * BlockMetadataInternal sender.
         * @member {Uint8Array} sender
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.sender = $util.newBuffer([]);

        /**
         * BlockMetadataInternal justifications.
         * @member {Array.<casper.IJustificationProto>} justifications
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.justifications = $util.emptyArray;

        /**
         * BlockMetadataInternal bonds.
         * @member {Array.<casper.IBondProto>} bonds
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.bonds = $util.emptyArray;

        /**
         * BlockMetadataInternal blockNum.
         * @member {number|Long} blockNum
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.blockNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockMetadataInternal seqNum.
         * @member {number} seqNum
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.seqNum = 0;

        /**
         * BlockMetadataInternal invalid.
         * @member {boolean} invalid
         * @memberof casper.BlockMetadataInternal
         * @instance
         */
        BlockMetadataInternal.prototype.invalid = false;

        /**
         * Creates a new BlockMetadataInternal instance using the specified properties.
         * @function create
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {casper.IBlockMetadataInternal=} [properties] Properties to set
         * @returns {casper.BlockMetadataInternal} BlockMetadataInternal instance
         */
        BlockMetadataInternal.create = function create(properties) {
            return new BlockMetadataInternal(properties);
        };

        /**
         * Encodes the specified BlockMetadataInternal message. Does not implicitly {@link casper.BlockMetadataInternal.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {casper.IBlockMetadataInternal} message BlockMetadataInternal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockMetadataInternal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockHash);
            if (message.parents != null && message.parents.length)
                for (var i = 0; i < message.parents.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.parents[i]);
            if (message.sender != null && message.hasOwnProperty("sender"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sender);
            if (message.justifications != null && message.justifications.length)
                for (var i = 0; i < message.justifications.length; ++i)
                    $root.casper.JustificationProto.encode(message.justifications[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.bonds != null && message.bonds.length)
                for (var i = 0; i < message.bonds.length; ++i)
                    $root.casper.BondProto.encode(message.bonds[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.blockNum);
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.seqNum);
            if (message.invalid != null && message.hasOwnProperty("invalid"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.invalid);
            return writer;
        };

        /**
         * Encodes the specified BlockMetadataInternal message, length delimited. Does not implicitly {@link casper.BlockMetadataInternal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {casper.IBlockMetadataInternal} message BlockMetadataInternal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockMetadataInternal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockMetadataInternal message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockMetadataInternal} BlockMetadataInternal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockMetadataInternal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockMetadataInternal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockHash = reader.bytes();
                    break;
                case 2:
                    if (!(message.parents && message.parents.length))
                        message.parents = [];
                    message.parents.push(reader.bytes());
                    break;
                case 3:
                    message.sender = reader.bytes();
                    break;
                case 4:
                    if (!(message.justifications && message.justifications.length))
                        message.justifications = [];
                    message.justifications.push($root.casper.JustificationProto.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.bonds && message.bonds.length))
                        message.bonds = [];
                    message.bonds.push($root.casper.BondProto.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.blockNum = reader.int64();
                    break;
                case 7:
                    message.seqNum = reader.int32();
                    break;
                case 8:
                    message.invalid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockMetadataInternal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockMetadataInternal} BlockMetadataInternal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockMetadataInternal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockMetadataInternal message.
         * @function verify
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockMetadataInternal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                    return "blockHash: buffer expected";
            if (message.parents != null && message.hasOwnProperty("parents")) {
                if (!Array.isArray(message.parents))
                    return "parents: array expected";
                for (var i = 0; i < message.parents.length; ++i)
                    if (!(message.parents[i] && typeof message.parents[i].length === "number" || $util.isString(message.parents[i])))
                        return "parents: buffer[] expected";
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                    return "sender: buffer expected";
            if (message.justifications != null && message.hasOwnProperty("justifications")) {
                if (!Array.isArray(message.justifications))
                    return "justifications: array expected";
                for (var i = 0; i < message.justifications.length; ++i) {
                    var error = $root.casper.JustificationProto.verify(message.justifications[i]);
                    if (error)
                        return "justifications." + error;
                }
            }
            if (message.bonds != null && message.hasOwnProperty("bonds")) {
                if (!Array.isArray(message.bonds))
                    return "bonds: array expected";
                for (var i = 0; i < message.bonds.length; ++i) {
                    var error = $root.casper.BondProto.verify(message.bonds[i]);
                    if (error)
                        return "bonds." + error;
                }
            }
            if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                if (!$util.isInteger(message.blockNum) && !(message.blockNum && $util.isInteger(message.blockNum.low) && $util.isInteger(message.blockNum.high)))
                    return "blockNum: integer|Long expected";
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                if (!$util.isInteger(message.seqNum))
                    return "seqNum: integer expected";
            if (message.invalid != null && message.hasOwnProperty("invalid"))
                if (typeof message.invalid !== "boolean")
                    return "invalid: boolean expected";
            return null;
        };

        /**
         * Creates a BlockMetadataInternal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockMetadataInternal} BlockMetadataInternal
         */
        BlockMetadataInternal.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockMetadataInternal)
                return object;
            var message = new $root.casper.BlockMetadataInternal();
            if (object.blockHash != null)
                if (typeof object.blockHash === "string")
                    $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                else if (object.blockHash.length)
                    message.blockHash = object.blockHash;
            if (object.parents) {
                if (!Array.isArray(object.parents))
                    throw TypeError(".casper.BlockMetadataInternal.parents: array expected");
                message.parents = [];
                for (var i = 0; i < object.parents.length; ++i)
                    if (typeof object.parents[i] === "string")
                        $util.base64.decode(object.parents[i], message.parents[i] = $util.newBuffer($util.base64.length(object.parents[i])), 0);
                    else if (object.parents[i].length)
                        message.parents[i] = object.parents[i];
            }
            if (object.sender != null)
                if (typeof object.sender === "string")
                    $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                else if (object.sender.length)
                    message.sender = object.sender;
            if (object.justifications) {
                if (!Array.isArray(object.justifications))
                    throw TypeError(".casper.BlockMetadataInternal.justifications: array expected");
                message.justifications = [];
                for (var i = 0; i < object.justifications.length; ++i) {
                    if (typeof object.justifications[i] !== "object")
                        throw TypeError(".casper.BlockMetadataInternal.justifications: object expected");
                    message.justifications[i] = $root.casper.JustificationProto.fromObject(object.justifications[i]);
                }
            }
            if (object.bonds) {
                if (!Array.isArray(object.bonds))
                    throw TypeError(".casper.BlockMetadataInternal.bonds: array expected");
                message.bonds = [];
                for (var i = 0; i < object.bonds.length; ++i) {
                    if (typeof object.bonds[i] !== "object")
                        throw TypeError(".casper.BlockMetadataInternal.bonds: object expected");
                    message.bonds[i] = $root.casper.BondProto.fromObject(object.bonds[i]);
                }
            }
            if (object.blockNum != null)
                if ($util.Long)
                    (message.blockNum = $util.Long.fromValue(object.blockNum)).unsigned = false;
                else if (typeof object.blockNum === "string")
                    message.blockNum = parseInt(object.blockNum, 10);
                else if (typeof object.blockNum === "number")
                    message.blockNum = object.blockNum;
                else if (typeof object.blockNum === "object")
                    message.blockNum = new $util.LongBits(object.blockNum.low >>> 0, object.blockNum.high >>> 0).toNumber();
            if (object.seqNum != null)
                message.seqNum = object.seqNum | 0;
            if (object.invalid != null)
                message.invalid = Boolean(object.invalid);
            return message;
        };

        /**
         * Creates a plain object from a BlockMetadataInternal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockMetadataInternal
         * @static
         * @param {casper.BlockMetadataInternal} message BlockMetadataInternal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockMetadataInternal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.parents = [];
                object.justifications = [];
                object.bonds = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockHash = "";
                else {
                    object.blockHash = [];
                    if (options.bytes !== Array)
                        object.blockHash = $util.newBuffer(object.blockHash);
                }
                if (options.bytes === String)
                    object.sender = "";
                else {
                    object.sender = [];
                    if (options.bytes !== Array)
                        object.sender = $util.newBuffer(object.sender);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNum = options.longs === String ? "0" : 0;
                object.seqNum = 0;
                object.invalid = false;
            }
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
            if (message.parents && message.parents.length) {
                object.parents = [];
                for (var j = 0; j < message.parents.length; ++j)
                    object.parents[j] = options.bytes === String ? $util.base64.encode(message.parents[j], 0, message.parents[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.parents[j]) : message.parents[j];
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
            if (message.justifications && message.justifications.length) {
                object.justifications = [];
                for (var j = 0; j < message.justifications.length; ++j)
                    object.justifications[j] = $root.casper.JustificationProto.toObject(message.justifications[j], options);
            }
            if (message.bonds && message.bonds.length) {
                object.bonds = [];
                for (var j = 0; j < message.bonds.length; ++j)
                    object.bonds[j] = $root.casper.BondProto.toObject(message.bonds[j], options);
            }
            if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                if (typeof message.blockNum === "number")
                    object.blockNum = options.longs === String ? String(message.blockNum) : message.blockNum;
                else
                    object.blockNum = options.longs === String ? $util.Long.prototype.toString.call(message.blockNum) : options.longs === Number ? new $util.LongBits(message.blockNum.low >>> 0, message.blockNum.high >>> 0).toNumber() : message.blockNum;
            if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                object.seqNum = message.seqNum;
            if (message.invalid != null && message.hasOwnProperty("invalid"))
                object.invalid = message.invalid;
            return object;
        };

        /**
         * Converts this BlockMetadataInternal to JSON.
         * @function toJSON
         * @memberof casper.BlockMetadataInternal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockMetadataInternal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockMetadataInternal;
    })();

    casper.HeaderProto = (function() {

        /**
         * Properties of a HeaderProto.
         * @memberof casper
         * @interface IHeaderProto
         * @property {Array.<Uint8Array>|null} [parentsHashList] HeaderProto parentsHashList
         * @property {Uint8Array|null} [deploysHash] HeaderProto deploysHash
         * @property {number|Long|null} [timestamp] HeaderProto timestamp
         * @property {number|Long|null} [version] HeaderProto version
         * @property {number|null} [deployCount] HeaderProto deployCount
         * @property {Uint8Array|null} [extraBytes] HeaderProto extraBytes
         */

        /**
         * Constructs a new HeaderProto.
         * @memberof casper
         * @classdesc Represents a HeaderProto.
         * @implements IHeaderProto
         * @constructor
         * @param {casper.IHeaderProto=} [properties] Properties to set
         */
        function HeaderProto(properties) {
            this.parentsHashList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeaderProto parentsHashList.
         * @member {Array.<Uint8Array>} parentsHashList
         * @memberof casper.HeaderProto
         * @instance
         */
        HeaderProto.prototype.parentsHashList = $util.emptyArray;

        /**
         * HeaderProto deploysHash.
         * @member {Uint8Array} deploysHash
         * @memberof casper.HeaderProto
         * @instance
         */
        HeaderProto.prototype.deploysHash = $util.newBuffer([]);

        /**
         * HeaderProto timestamp.
         * @member {number|Long} timestamp
         * @memberof casper.HeaderProto
         * @instance
         */
        HeaderProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HeaderProto version.
         * @member {number|Long} version
         * @memberof casper.HeaderProto
         * @instance
         */
        HeaderProto.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HeaderProto deployCount.
         * @member {number} deployCount
         * @memberof casper.HeaderProto
         * @instance
         */
        HeaderProto.prototype.deployCount = 0;

        /**
         * HeaderProto extraBytes.
         * @member {Uint8Array} extraBytes
         * @memberof casper.HeaderProto
         * @instance
         */
        HeaderProto.prototype.extraBytes = $util.newBuffer([]);

        /**
         * Creates a new HeaderProto instance using the specified properties.
         * @function create
         * @memberof casper.HeaderProto
         * @static
         * @param {casper.IHeaderProto=} [properties] Properties to set
         * @returns {casper.HeaderProto} HeaderProto instance
         */
        HeaderProto.create = function create(properties) {
            return new HeaderProto(properties);
        };

        /**
         * Encodes the specified HeaderProto message. Does not implicitly {@link casper.HeaderProto.verify|verify} messages.
         * @function encode
         * @memberof casper.HeaderProto
         * @static
         * @param {casper.IHeaderProto} message HeaderProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeaderProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parentsHashList != null && message.parentsHashList.length)
                for (var i = 0; i < message.parentsHashList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.parentsHashList[i]);
            if (message.deploysHash != null && message.hasOwnProperty("deploysHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.deploysHash);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.version);
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.deployCount);
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.extraBytes);
            return writer;
        };

        /**
         * Encodes the specified HeaderProto message, length delimited. Does not implicitly {@link casper.HeaderProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.HeaderProto
         * @static
         * @param {casper.IHeaderProto} message HeaderProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeaderProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeaderProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.HeaderProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.HeaderProto} HeaderProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeaderProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.HeaderProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.parentsHashList && message.parentsHashList.length))
                        message.parentsHashList = [];
                    message.parentsHashList.push(reader.bytes());
                    break;
                case 3:
                    message.deploysHash = reader.bytes();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.version = reader.int64();
                    break;
                case 7:
                    message.deployCount = reader.int32();
                    break;
                case 8:
                    message.extraBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeaderProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.HeaderProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.HeaderProto} HeaderProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeaderProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeaderProto message.
         * @function verify
         * @memberof casper.HeaderProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeaderProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parentsHashList != null && message.hasOwnProperty("parentsHashList")) {
                if (!Array.isArray(message.parentsHashList))
                    return "parentsHashList: array expected";
                for (var i = 0; i < message.parentsHashList.length; ++i)
                    if (!(message.parentsHashList[i] && typeof message.parentsHashList[i].length === "number" || $util.isString(message.parentsHashList[i])))
                        return "parentsHashList: buffer[] expected";
            }
            if (message.deploysHash != null && message.hasOwnProperty("deploysHash"))
                if (!(message.deploysHash && typeof message.deploysHash.length === "number" || $util.isString(message.deploysHash)))
                    return "deploysHash: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                    return "version: integer|Long expected";
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                if (!$util.isInteger(message.deployCount))
                    return "deployCount: integer expected";
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                    return "extraBytes: buffer expected";
            return null;
        };

        /**
         * Creates a HeaderProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.HeaderProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.HeaderProto} HeaderProto
         */
        HeaderProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.HeaderProto)
                return object;
            var message = new $root.casper.HeaderProto();
            if (object.parentsHashList) {
                if (!Array.isArray(object.parentsHashList))
                    throw TypeError(".casper.HeaderProto.parentsHashList: array expected");
                message.parentsHashList = [];
                for (var i = 0; i < object.parentsHashList.length; ++i)
                    if (typeof object.parentsHashList[i] === "string")
                        $util.base64.decode(object.parentsHashList[i], message.parentsHashList[i] = $util.newBuffer($util.base64.length(object.parentsHashList[i])), 0);
                    else if (object.parentsHashList[i].length)
                        message.parentsHashList[i] = object.parentsHashList[i];
            }
            if (object.deploysHash != null)
                if (typeof object.deploysHash === "string")
                    $util.base64.decode(object.deploysHash, message.deploysHash = $util.newBuffer($util.base64.length(object.deploysHash)), 0);
                else if (object.deploysHash.length)
                    message.deploysHash = object.deploysHash;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            if (object.deployCount != null)
                message.deployCount = object.deployCount | 0;
            if (object.extraBytes != null)
                if (typeof object.extraBytes === "string")
                    $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                else if (object.extraBytes.length)
                    message.extraBytes = object.extraBytes;
            return message;
        };

        /**
         * Creates a plain object from a HeaderProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.HeaderProto
         * @static
         * @param {casper.HeaderProto} message HeaderProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeaderProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.parentsHashList = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.deploysHash = "";
                else {
                    object.deploysHash = [];
                    if (options.bytes !== Array)
                        object.deploysHash = $util.newBuffer(object.deploysHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
                object.deployCount = 0;
                if (options.bytes === String)
                    object.extraBytes = "";
                else {
                    object.extraBytes = [];
                    if (options.bytes !== Array)
                        object.extraBytes = $util.newBuffer(object.extraBytes);
                }
            }
            if (message.parentsHashList && message.parentsHashList.length) {
                object.parentsHashList = [];
                for (var j = 0; j < message.parentsHashList.length; ++j)
                    object.parentsHashList[j] = options.bytes === String ? $util.base64.encode(message.parentsHashList[j], 0, message.parentsHashList[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.parentsHashList[j]) : message.parentsHashList[j];
            }
            if (message.deploysHash != null && message.hasOwnProperty("deploysHash"))
                object.deploysHash = options.bytes === String ? $util.base64.encode(message.deploysHash, 0, message.deploysHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.deploysHash) : message.deploysHash;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                object.deployCount = message.deployCount;
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
            return object;
        };

        /**
         * Converts this HeaderProto to JSON.
         * @function toJSON
         * @memberof casper.HeaderProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeaderProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeaderProto;
    })();

    casper.DeployDataProto = (function() {

        /**
         * Properties of a DeployDataProto.
         * @memberof casper
         * @interface IDeployDataProto
         * @property {Uint8Array|null} [deployer] DeployDataProto deployer
         * @property {string|null} [term] DeployDataProto term
         * @property {number|Long|null} [timestamp] DeployDataProto timestamp
         * @property {Uint8Array|null} [sig] DeployDataProto sig
         * @property {string|null} [sigAlgorithm] DeployDataProto sigAlgorithm
         * @property {number|Long|null} [phloPrice] DeployDataProto phloPrice
         * @property {number|Long|null} [phloLimit] DeployDataProto phloLimit
         * @property {number|Long|null} [validAfterBlockNumber] DeployDataProto validAfterBlockNumber
         */

        /**
         * Constructs a new DeployDataProto.
         * @memberof casper
         * @classdesc Note: deploys are uniquely keyed by `user`, `timestamp`.
         * 
         * **TODO**: details of signatures and payment. See RHOL-781
         * @implements IDeployDataProto
         * @constructor
         * @param {casper.IDeployDataProto=} [properties] Properties to set
         */
        function DeployDataProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeployDataProto deployer.
         * @member {Uint8Array} deployer
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.deployer = $util.newBuffer([]);

        /**
         * DeployDataProto term.
         * @member {string} term
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.term = "";

        /**
         * DeployDataProto timestamp.
         * @member {number|Long} timestamp
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeployDataProto sig.
         * @member {Uint8Array} sig
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.sig = $util.newBuffer([]);

        /**
         * DeployDataProto sigAlgorithm.
         * @member {string} sigAlgorithm
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.sigAlgorithm = "";

        /**
         * DeployDataProto phloPrice.
         * @member {number|Long} phloPrice
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.phloPrice = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeployDataProto phloLimit.
         * @member {number|Long} phloLimit
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.phloLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeployDataProto validAfterBlockNumber.
         * @member {number|Long} validAfterBlockNumber
         * @memberof casper.DeployDataProto
         * @instance
         */
        DeployDataProto.prototype.validAfterBlockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeployDataProto instance using the specified properties.
         * @function create
         * @memberof casper.DeployDataProto
         * @static
         * @param {casper.IDeployDataProto=} [properties] Properties to set
         * @returns {casper.DeployDataProto} DeployDataProto instance
         */
        DeployDataProto.create = function create(properties) {
            return new DeployDataProto(properties);
        };

        /**
         * Encodes the specified DeployDataProto message. Does not implicitly {@link casper.DeployDataProto.verify|verify} messages.
         * @function encode
         * @memberof casper.DeployDataProto
         * @static
         * @param {casper.IDeployDataProto} message DeployDataProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeployDataProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deployer != null && message.hasOwnProperty("deployer"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deployer);
            if (message.term != null && message.hasOwnProperty("term"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.term);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.sig != null && message.hasOwnProperty("sig"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sig);
            if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.sigAlgorithm);
            if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.phloPrice);
            if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.phloLimit);
            if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.validAfterBlockNumber);
            return writer;
        };

        /**
         * Encodes the specified DeployDataProto message, length delimited. Does not implicitly {@link casper.DeployDataProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.DeployDataProto
         * @static
         * @param {casper.IDeployDataProto} message DeployDataProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeployDataProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeployDataProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.DeployDataProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.DeployDataProto} DeployDataProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeployDataProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DeployDataProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deployer = reader.bytes();
                    break;
                case 2:
                    message.term = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    message.sig = reader.bytes();
                    break;
                case 5:
                    message.sigAlgorithm = reader.string();
                    break;
                case 7:
                    message.phloPrice = reader.int64();
                    break;
                case 8:
                    message.phloLimit = reader.int64();
                    break;
                case 10:
                    message.validAfterBlockNumber = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeployDataProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.DeployDataProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.DeployDataProto} DeployDataProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeployDataProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeployDataProto message.
         * @function verify
         * @memberof casper.DeployDataProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeployDataProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deployer != null && message.hasOwnProperty("deployer"))
                if (!(message.deployer && typeof message.deployer.length === "number" || $util.isString(message.deployer)))
                    return "deployer: buffer expected";
            if (message.term != null && message.hasOwnProperty("term"))
                if (!$util.isString(message.term))
                    return "term: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.sig != null && message.hasOwnProperty("sig"))
                if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                    return "sig: buffer expected";
            if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                if (!$util.isString(message.sigAlgorithm))
                    return "sigAlgorithm: string expected";
            if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                if (!$util.isInteger(message.phloPrice) && !(message.phloPrice && $util.isInteger(message.phloPrice.low) && $util.isInteger(message.phloPrice.high)))
                    return "phloPrice: integer|Long expected";
            if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                if (!$util.isInteger(message.phloLimit) && !(message.phloLimit && $util.isInteger(message.phloLimit.low) && $util.isInteger(message.phloLimit.high)))
                    return "phloLimit: integer|Long expected";
            if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                if (!$util.isInteger(message.validAfterBlockNumber) && !(message.validAfterBlockNumber && $util.isInteger(message.validAfterBlockNumber.low) && $util.isInteger(message.validAfterBlockNumber.high)))
                    return "validAfterBlockNumber: integer|Long expected";
            return null;
        };

        /**
         * Creates a DeployDataProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.DeployDataProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.DeployDataProto} DeployDataProto
         */
        DeployDataProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.DeployDataProto)
                return object;
            var message = new $root.casper.DeployDataProto();
            if (object.deployer != null)
                if (typeof object.deployer === "string")
                    $util.base64.decode(object.deployer, message.deployer = $util.newBuffer($util.base64.length(object.deployer)), 0);
                else if (object.deployer.length)
                    message.deployer = object.deployer;
            if (object.term != null)
                message.term = String(object.term);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.sig != null)
                if (typeof object.sig === "string")
                    $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
                else if (object.sig.length)
                    message.sig = object.sig;
            if (object.sigAlgorithm != null)
                message.sigAlgorithm = String(object.sigAlgorithm);
            if (object.phloPrice != null)
                if ($util.Long)
                    (message.phloPrice = $util.Long.fromValue(object.phloPrice)).unsigned = false;
                else if (typeof object.phloPrice === "string")
                    message.phloPrice = parseInt(object.phloPrice, 10);
                else if (typeof object.phloPrice === "number")
                    message.phloPrice = object.phloPrice;
                else if (typeof object.phloPrice === "object")
                    message.phloPrice = new $util.LongBits(object.phloPrice.low >>> 0, object.phloPrice.high >>> 0).toNumber();
            if (object.phloLimit != null)
                if ($util.Long)
                    (message.phloLimit = $util.Long.fromValue(object.phloLimit)).unsigned = false;
                else if (typeof object.phloLimit === "string")
                    message.phloLimit = parseInt(object.phloLimit, 10);
                else if (typeof object.phloLimit === "number")
                    message.phloLimit = object.phloLimit;
                else if (typeof object.phloLimit === "object")
                    message.phloLimit = new $util.LongBits(object.phloLimit.low >>> 0, object.phloLimit.high >>> 0).toNumber();
            if (object.validAfterBlockNumber != null)
                if ($util.Long)
                    (message.validAfterBlockNumber = $util.Long.fromValue(object.validAfterBlockNumber)).unsigned = false;
                else if (typeof object.validAfterBlockNumber === "string")
                    message.validAfterBlockNumber = parseInt(object.validAfterBlockNumber, 10);
                else if (typeof object.validAfterBlockNumber === "number")
                    message.validAfterBlockNumber = object.validAfterBlockNumber;
                else if (typeof object.validAfterBlockNumber === "object")
                    message.validAfterBlockNumber = new $util.LongBits(object.validAfterBlockNumber.low >>> 0, object.validAfterBlockNumber.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DeployDataProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.DeployDataProto
         * @static
         * @param {casper.DeployDataProto} message DeployDataProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeployDataProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.deployer = "";
                else {
                    object.deployer = [];
                    if (options.bytes !== Array)
                        object.deployer = $util.newBuffer(object.deployer);
                }
                object.term = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.sig = "";
                else {
                    object.sig = [];
                    if (options.bytes !== Array)
                        object.sig = $util.newBuffer(object.sig);
                }
                object.sigAlgorithm = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.phloPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.phloPrice = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.phloLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.phloLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.validAfterBlockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.validAfterBlockNumber = options.longs === String ? "0" : 0;
            }
            if (message.deployer != null && message.hasOwnProperty("deployer"))
                object.deployer = options.bytes === String ? $util.base64.encode(message.deployer, 0, message.deployer.length) : options.bytes === Array ? Array.prototype.slice.call(message.deployer) : message.deployer;
            if (message.term != null && message.hasOwnProperty("term"))
                object.term = message.term;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.sig != null && message.hasOwnProperty("sig"))
                object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
            if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                object.sigAlgorithm = message.sigAlgorithm;
            if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                if (typeof message.phloPrice === "number")
                    object.phloPrice = options.longs === String ? String(message.phloPrice) : message.phloPrice;
                else
                    object.phloPrice = options.longs === String ? $util.Long.prototype.toString.call(message.phloPrice) : options.longs === Number ? new $util.LongBits(message.phloPrice.low >>> 0, message.phloPrice.high >>> 0).toNumber() : message.phloPrice;
            if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                if (typeof message.phloLimit === "number")
                    object.phloLimit = options.longs === String ? String(message.phloLimit) : message.phloLimit;
                else
                    object.phloLimit = options.longs === String ? $util.Long.prototype.toString.call(message.phloLimit) : options.longs === Number ? new $util.LongBits(message.phloLimit.low >>> 0, message.phloLimit.high >>> 0).toNumber() : message.phloLimit;
            if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                if (typeof message.validAfterBlockNumber === "number")
                    object.validAfterBlockNumber = options.longs === String ? String(message.validAfterBlockNumber) : message.validAfterBlockNumber;
                else
                    object.validAfterBlockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.validAfterBlockNumber) : options.longs === Number ? new $util.LongBits(message.validAfterBlockNumber.low >>> 0, message.validAfterBlockNumber.high >>> 0).toNumber() : message.validAfterBlockNumber;
            return object;
        };

        /**
         * Converts this DeployDataProto to JSON.
         * @function toJSON
         * @memberof casper.DeployDataProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeployDataProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeployDataProto;
    })();

    casper.ProcessedDeployProto = (function() {

        /**
         * Properties of a ProcessedDeployProto.
         * @memberof casper
         * @interface IProcessedDeployProto
         * @property {casper.IDeployDataProto|null} [deploy] ProcessedDeployProto deploy
         * @property {IPCost|null} [cost] ProcessedDeployProto cost
         * @property {Array.<casper.IEventProto>|null} [deployLog] ProcessedDeployProto deployLog
         * @property {Array.<casper.IEventProto>|null} [paymentLog] ProcessedDeployProto paymentLog
         * @property {boolean|null} [errored] ProcessedDeployProto errored
         */

        /**
         * Constructs a new ProcessedDeployProto.
         * @memberof casper
         * @classdesc Represents a ProcessedDeployProto.
         * @implements IProcessedDeployProto
         * @constructor
         * @param {casper.IProcessedDeployProto=} [properties] Properties to set
         */
        function ProcessedDeployProto(properties) {
            this.deployLog = [];
            this.paymentLog = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProcessedDeployProto deploy.
         * @member {casper.IDeployDataProto|null|undefined} deploy
         * @memberof casper.ProcessedDeployProto
         * @instance
         */
        ProcessedDeployProto.prototype.deploy = null;

        /**
         * ProcessedDeployProto cost.
         * @member {IPCost|null|undefined} cost
         * @memberof casper.ProcessedDeployProto
         * @instance
         */
        ProcessedDeployProto.prototype.cost = null;

        /**
         * ProcessedDeployProto deployLog.
         * @member {Array.<casper.IEventProto>} deployLog
         * @memberof casper.ProcessedDeployProto
         * @instance
         */
        ProcessedDeployProto.prototype.deployLog = $util.emptyArray;

        /**
         * ProcessedDeployProto paymentLog.
         * @member {Array.<casper.IEventProto>} paymentLog
         * @memberof casper.ProcessedDeployProto
         * @instance
         */
        ProcessedDeployProto.prototype.paymentLog = $util.emptyArray;

        /**
         * ProcessedDeployProto errored.
         * @member {boolean} errored
         * @memberof casper.ProcessedDeployProto
         * @instance
         */
        ProcessedDeployProto.prototype.errored = false;

        /**
         * Creates a new ProcessedDeployProto instance using the specified properties.
         * @function create
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {casper.IProcessedDeployProto=} [properties] Properties to set
         * @returns {casper.ProcessedDeployProto} ProcessedDeployProto instance
         */
        ProcessedDeployProto.create = function create(properties) {
            return new ProcessedDeployProto(properties);
        };

        /**
         * Encodes the specified ProcessedDeployProto message. Does not implicitly {@link casper.ProcessedDeployProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {casper.IProcessedDeployProto} message ProcessedDeployProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProcessedDeployProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deploy != null && message.hasOwnProperty("deploy"))
                $root.casper.DeployDataProto.encode(message.deploy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.cost != null && message.hasOwnProperty("cost"))
                $root.PCost.encode(message.cost, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.deployLog != null && message.deployLog.length)
                for (var i = 0; i < message.deployLog.length; ++i)
                    $root.casper.EventProto.encode(message.deployLog[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.paymentLog != null && message.paymentLog.length)
                for (var i = 0; i < message.paymentLog.length; ++i)
                    $root.casper.EventProto.encode(message.paymentLog[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.errored != null && message.hasOwnProperty("errored"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.errored);
            return writer;
        };

        /**
         * Encodes the specified ProcessedDeployProto message, length delimited. Does not implicitly {@link casper.ProcessedDeployProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {casper.IProcessedDeployProto} message ProcessedDeployProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProcessedDeployProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProcessedDeployProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ProcessedDeployProto} ProcessedDeployProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProcessedDeployProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ProcessedDeployProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deploy = $root.casper.DeployDataProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.cost = $root.PCost.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.deployLog && message.deployLog.length))
                        message.deployLog = [];
                    message.deployLog.push($root.casper.EventProto.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.paymentLog && message.paymentLog.length))
                        message.paymentLog = [];
                    message.paymentLog.push($root.casper.EventProto.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.errored = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProcessedDeployProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ProcessedDeployProto} ProcessedDeployProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProcessedDeployProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProcessedDeployProto message.
         * @function verify
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProcessedDeployProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deploy != null && message.hasOwnProperty("deploy")) {
                var error = $root.casper.DeployDataProto.verify(message.deploy);
                if (error)
                    return "deploy." + error;
            }
            if (message.cost != null && message.hasOwnProperty("cost")) {
                var error = $root.PCost.verify(message.cost);
                if (error)
                    return "cost." + error;
            }
            if (message.deployLog != null && message.hasOwnProperty("deployLog")) {
                if (!Array.isArray(message.deployLog))
                    return "deployLog: array expected";
                for (var i = 0; i < message.deployLog.length; ++i) {
                    var error = $root.casper.EventProto.verify(message.deployLog[i]);
                    if (error)
                        return "deployLog." + error;
                }
            }
            if (message.paymentLog != null && message.hasOwnProperty("paymentLog")) {
                if (!Array.isArray(message.paymentLog))
                    return "paymentLog: array expected";
                for (var i = 0; i < message.paymentLog.length; ++i) {
                    var error = $root.casper.EventProto.verify(message.paymentLog[i]);
                    if (error)
                        return "paymentLog." + error;
                }
            }
            if (message.errored != null && message.hasOwnProperty("errored"))
                if (typeof message.errored !== "boolean")
                    return "errored: boolean expected";
            return null;
        };

        /**
         * Creates a ProcessedDeployProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ProcessedDeployProto} ProcessedDeployProto
         */
        ProcessedDeployProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ProcessedDeployProto)
                return object;
            var message = new $root.casper.ProcessedDeployProto();
            if (object.deploy != null) {
                if (typeof object.deploy !== "object")
                    throw TypeError(".casper.ProcessedDeployProto.deploy: object expected");
                message.deploy = $root.casper.DeployDataProto.fromObject(object.deploy);
            }
            if (object.cost != null) {
                if (typeof object.cost !== "object")
                    throw TypeError(".casper.ProcessedDeployProto.cost: object expected");
                message.cost = $root.PCost.fromObject(object.cost);
            }
            if (object.deployLog) {
                if (!Array.isArray(object.deployLog))
                    throw TypeError(".casper.ProcessedDeployProto.deployLog: array expected");
                message.deployLog = [];
                for (var i = 0; i < object.deployLog.length; ++i) {
                    if (typeof object.deployLog[i] !== "object")
                        throw TypeError(".casper.ProcessedDeployProto.deployLog: object expected");
                    message.deployLog[i] = $root.casper.EventProto.fromObject(object.deployLog[i]);
                }
            }
            if (object.paymentLog) {
                if (!Array.isArray(object.paymentLog))
                    throw TypeError(".casper.ProcessedDeployProto.paymentLog: array expected");
                message.paymentLog = [];
                for (var i = 0; i < object.paymentLog.length; ++i) {
                    if (typeof object.paymentLog[i] !== "object")
                        throw TypeError(".casper.ProcessedDeployProto.paymentLog: object expected");
                    message.paymentLog[i] = $root.casper.EventProto.fromObject(object.paymentLog[i]);
                }
            }
            if (object.errored != null)
                message.errored = Boolean(object.errored);
            return message;
        };

        /**
         * Creates a plain object from a ProcessedDeployProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ProcessedDeployProto
         * @static
         * @param {casper.ProcessedDeployProto} message ProcessedDeployProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProcessedDeployProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.deployLog = [];
                object.paymentLog = [];
            }
            if (options.defaults) {
                object.deploy = null;
                object.cost = null;
                object.errored = false;
            }
            if (message.deploy != null && message.hasOwnProperty("deploy"))
                object.deploy = $root.casper.DeployDataProto.toObject(message.deploy, options);
            if (message.cost != null && message.hasOwnProperty("cost"))
                object.cost = $root.PCost.toObject(message.cost, options);
            if (message.deployLog && message.deployLog.length) {
                object.deployLog = [];
                for (var j = 0; j < message.deployLog.length; ++j)
                    object.deployLog[j] = $root.casper.EventProto.toObject(message.deployLog[j], options);
            }
            if (message.paymentLog && message.paymentLog.length) {
                object.paymentLog = [];
                for (var j = 0; j < message.paymentLog.length; ++j)
                    object.paymentLog[j] = $root.casper.EventProto.toObject(message.paymentLog[j], options);
            }
            if (message.errored != null && message.hasOwnProperty("errored"))
                object.errored = message.errored;
            return object;
        };

        /**
         * Converts this ProcessedDeployProto to JSON.
         * @function toJSON
         * @memberof casper.ProcessedDeployProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProcessedDeployProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProcessedDeployProto;
    })();

    casper.BodyProto = (function() {

        /**
         * Properties of a BodyProto.
         * @memberof casper
         * @interface IBodyProto
         * @property {casper.IRChainStateProto|null} [state] BodyProto state
         * @property {Array.<casper.IProcessedDeployProto>|null} [deploys] BodyProto deploys
         * @property {Uint8Array|null} [extraBytes] BodyProto extraBytes
         */

        /**
         * Constructs a new BodyProto.
         * @memberof casper
         * @classdesc Represents a BodyProto.
         * @implements IBodyProto
         * @constructor
         * @param {casper.IBodyProto=} [properties] Properties to set
         */
        function BodyProto(properties) {
            this.deploys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BodyProto state.
         * @member {casper.IRChainStateProto|null|undefined} state
         * @memberof casper.BodyProto
         * @instance
         */
        BodyProto.prototype.state = null;

        /**
         * BodyProto deploys.
         * @member {Array.<casper.IProcessedDeployProto>} deploys
         * @memberof casper.BodyProto
         * @instance
         */
        BodyProto.prototype.deploys = $util.emptyArray;

        /**
         * BodyProto extraBytes.
         * @member {Uint8Array} extraBytes
         * @memberof casper.BodyProto
         * @instance
         */
        BodyProto.prototype.extraBytes = $util.newBuffer([]);

        /**
         * Creates a new BodyProto instance using the specified properties.
         * @function create
         * @memberof casper.BodyProto
         * @static
         * @param {casper.IBodyProto=} [properties] Properties to set
         * @returns {casper.BodyProto} BodyProto instance
         */
        BodyProto.create = function create(properties) {
            return new BodyProto(properties);
        };

        /**
         * Encodes the specified BodyProto message. Does not implicitly {@link casper.BodyProto.verify|verify} messages.
         * @function encode
         * @memberof casper.BodyProto
         * @static
         * @param {casper.IBodyProto} message BodyProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && message.hasOwnProperty("state"))
                $root.casper.RChainStateProto.encode(message.state, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.deploys != null && message.deploys.length)
                for (var i = 0; i < message.deploys.length; ++i)
                    $root.casper.ProcessedDeployProto.encode(message.deploys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.extraBytes);
            return writer;
        };

        /**
         * Encodes the specified BodyProto message, length delimited. Does not implicitly {@link casper.BodyProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BodyProto
         * @static
         * @param {casper.IBodyProto} message BodyProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BodyProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BodyProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BodyProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BodyProto} BodyProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BodyProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = $root.casper.RChainStateProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.deploys && message.deploys.length))
                        message.deploys = [];
                    message.deploys.push($root.casper.ProcessedDeployProto.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.extraBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BodyProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BodyProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BodyProto} BodyProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BodyProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BodyProto message.
         * @function verify
         * @memberof casper.BodyProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BodyProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state")) {
                var error = $root.casper.RChainStateProto.verify(message.state);
                if (error)
                    return "state." + error;
            }
            if (message.deploys != null && message.hasOwnProperty("deploys")) {
                if (!Array.isArray(message.deploys))
                    return "deploys: array expected";
                for (var i = 0; i < message.deploys.length; ++i) {
                    var error = $root.casper.ProcessedDeployProto.verify(message.deploys[i]);
                    if (error)
                        return "deploys." + error;
                }
            }
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                    return "extraBytes: buffer expected";
            return null;
        };

        /**
         * Creates a BodyProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BodyProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BodyProto} BodyProto
         */
        BodyProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BodyProto)
                return object;
            var message = new $root.casper.BodyProto();
            if (object.state != null) {
                if (typeof object.state !== "object")
                    throw TypeError(".casper.BodyProto.state: object expected");
                message.state = $root.casper.RChainStateProto.fromObject(object.state);
            }
            if (object.deploys) {
                if (!Array.isArray(object.deploys))
                    throw TypeError(".casper.BodyProto.deploys: array expected");
                message.deploys = [];
                for (var i = 0; i < object.deploys.length; ++i) {
                    if (typeof object.deploys[i] !== "object")
                        throw TypeError(".casper.BodyProto.deploys: object expected");
                    message.deploys[i] = $root.casper.ProcessedDeployProto.fromObject(object.deploys[i]);
                }
            }
            if (object.extraBytes != null)
                if (typeof object.extraBytes === "string")
                    $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                else if (object.extraBytes.length)
                    message.extraBytes = object.extraBytes;
            return message;
        };

        /**
         * Creates a plain object from a BodyProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BodyProto
         * @static
         * @param {casper.BodyProto} message BodyProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BodyProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.deploys = [];
            if (options.defaults) {
                object.state = null;
                if (options.bytes === String)
                    object.extraBytes = "";
                else {
                    object.extraBytes = [];
                    if (options.bytes !== Array)
                        object.extraBytes = $util.newBuffer(object.extraBytes);
                }
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = $root.casper.RChainStateProto.toObject(message.state, options);
            if (message.deploys && message.deploys.length) {
                object.deploys = [];
                for (var j = 0; j < message.deploys.length; ++j)
                    object.deploys[j] = $root.casper.ProcessedDeployProto.toObject(message.deploys[j], options);
            }
            if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
            return object;
        };

        /**
         * Converts this BodyProto to JSON.
         * @function toJSON
         * @memberof casper.BodyProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BodyProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BodyProto;
    })();

    casper.JustificationProto = (function() {

        /**
         * Properties of a JustificationProto.
         * @memberof casper
         * @interface IJustificationProto
         * @property {Uint8Array|null} [validator] JustificationProto validator
         * @property {Uint8Array|null} [latestBlockHash] JustificationProto latestBlockHash
         */

        /**
         * Constructs a new JustificationProto.
         * @memberof casper
         * @classdesc Represents a JustificationProto.
         * @implements IJustificationProto
         * @constructor
         * @param {casper.IJustificationProto=} [properties] Properties to set
         */
        function JustificationProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JustificationProto validator.
         * @member {Uint8Array} validator
         * @memberof casper.JustificationProto
         * @instance
         */
        JustificationProto.prototype.validator = $util.newBuffer([]);

        /**
         * JustificationProto latestBlockHash.
         * @member {Uint8Array} latestBlockHash
         * @memberof casper.JustificationProto
         * @instance
         */
        JustificationProto.prototype.latestBlockHash = $util.newBuffer([]);

        /**
         * Creates a new JustificationProto instance using the specified properties.
         * @function create
         * @memberof casper.JustificationProto
         * @static
         * @param {casper.IJustificationProto=} [properties] Properties to set
         * @returns {casper.JustificationProto} JustificationProto instance
         */
        JustificationProto.create = function create(properties) {
            return new JustificationProto(properties);
        };

        /**
         * Encodes the specified JustificationProto message. Does not implicitly {@link casper.JustificationProto.verify|verify} messages.
         * @function encode
         * @memberof casper.JustificationProto
         * @static
         * @param {casper.IJustificationProto} message JustificationProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JustificationProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validator != null && message.hasOwnProperty("validator"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.validator);
            if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.latestBlockHash);
            return writer;
        };

        /**
         * Encodes the specified JustificationProto message, length delimited. Does not implicitly {@link casper.JustificationProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.JustificationProto
         * @static
         * @param {casper.IJustificationProto} message JustificationProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JustificationProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JustificationProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.JustificationProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.JustificationProto} JustificationProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JustificationProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.JustificationProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.validator = reader.bytes();
                    break;
                case 2:
                    message.latestBlockHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JustificationProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.JustificationProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.JustificationProto} JustificationProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JustificationProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JustificationProto message.
         * @function verify
         * @memberof casper.JustificationProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JustificationProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validator != null && message.hasOwnProperty("validator"))
                if (!(message.validator && typeof message.validator.length === "number" || $util.isString(message.validator)))
                    return "validator: buffer expected";
            if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                if (!(message.latestBlockHash && typeof message.latestBlockHash.length === "number" || $util.isString(message.latestBlockHash)))
                    return "latestBlockHash: buffer expected";
            return null;
        };

        /**
         * Creates a JustificationProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.JustificationProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.JustificationProto} JustificationProto
         */
        JustificationProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.JustificationProto)
                return object;
            var message = new $root.casper.JustificationProto();
            if (object.validator != null)
                if (typeof object.validator === "string")
                    $util.base64.decode(object.validator, message.validator = $util.newBuffer($util.base64.length(object.validator)), 0);
                else if (object.validator.length)
                    message.validator = object.validator;
            if (object.latestBlockHash != null)
                if (typeof object.latestBlockHash === "string")
                    $util.base64.decode(object.latestBlockHash, message.latestBlockHash = $util.newBuffer($util.base64.length(object.latestBlockHash)), 0);
                else if (object.latestBlockHash.length)
                    message.latestBlockHash = object.latestBlockHash;
            return message;
        };

        /**
         * Creates a plain object from a JustificationProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.JustificationProto
         * @static
         * @param {casper.JustificationProto} message JustificationProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JustificationProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.validator = "";
                else {
                    object.validator = [];
                    if (options.bytes !== Array)
                        object.validator = $util.newBuffer(object.validator);
                }
                if (options.bytes === String)
                    object.latestBlockHash = "";
                else {
                    object.latestBlockHash = [];
                    if (options.bytes !== Array)
                        object.latestBlockHash = $util.newBuffer(object.latestBlockHash);
                }
            }
            if (message.validator != null && message.hasOwnProperty("validator"))
                object.validator = options.bytes === String ? $util.base64.encode(message.validator, 0, message.validator.length) : options.bytes === Array ? Array.prototype.slice.call(message.validator) : message.validator;
            if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                object.latestBlockHash = options.bytes === String ? $util.base64.encode(message.latestBlockHash, 0, message.latestBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.latestBlockHash) : message.latestBlockHash;
            return object;
        };

        /**
         * Converts this JustificationProto to JSON.
         * @function toJSON
         * @memberof casper.JustificationProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JustificationProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return JustificationProto;
    })();

    casper.RChainStateProto = (function() {

        /**
         * Properties of a RChainStateProto.
         * @memberof casper
         * @interface IRChainStateProto
         * @property {Uint8Array|null} [preStateHash] RChainStateProto preStateHash
         * @property {Uint8Array|null} [postStateHash] RChainStateProto postStateHash
         * @property {Array.<casper.IBondProto>|null} [bonds] RChainStateProto bonds
         * @property {number|Long|null} [blockNumber] RChainStateProto blockNumber
         */

        /**
         * Constructs a new RChainStateProto.
         * @memberof casper
         * @classdesc Represents a RChainStateProto.
         * @implements IRChainStateProto
         * @constructor
         * @param {casper.IRChainStateProto=} [properties] Properties to set
         */
        function RChainStateProto(properties) {
            this.bonds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RChainStateProto preStateHash.
         * @member {Uint8Array} preStateHash
         * @memberof casper.RChainStateProto
         * @instance
         */
        RChainStateProto.prototype.preStateHash = $util.newBuffer([]);

        /**
         * RChainStateProto postStateHash.
         * @member {Uint8Array} postStateHash
         * @memberof casper.RChainStateProto
         * @instance
         */
        RChainStateProto.prototype.postStateHash = $util.newBuffer([]);

        /**
         * RChainStateProto bonds.
         * @member {Array.<casper.IBondProto>} bonds
         * @memberof casper.RChainStateProto
         * @instance
         */
        RChainStateProto.prototype.bonds = $util.emptyArray;

        /**
         * RChainStateProto blockNumber.
         * @member {number|Long} blockNumber
         * @memberof casper.RChainStateProto
         * @instance
         */
        RChainStateProto.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RChainStateProto instance using the specified properties.
         * @function create
         * @memberof casper.RChainStateProto
         * @static
         * @param {casper.IRChainStateProto=} [properties] Properties to set
         * @returns {casper.RChainStateProto} RChainStateProto instance
         */
        RChainStateProto.create = function create(properties) {
            return new RChainStateProto(properties);
        };

        /**
         * Encodes the specified RChainStateProto message. Does not implicitly {@link casper.RChainStateProto.verify|verify} messages.
         * @function encode
         * @memberof casper.RChainStateProto
         * @static
         * @param {casper.IRChainStateProto} message RChainStateProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RChainStateProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.preStateHash);
            if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.postStateHash);
            if (message.bonds != null && message.bonds.length)
                for (var i = 0; i < message.bonds.length; ++i)
                    $root.casper.BondProto.encode(message.bonds[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.blockNumber);
            return writer;
        };

        /**
         * Encodes the specified RChainStateProto message, length delimited. Does not implicitly {@link casper.RChainStateProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.RChainStateProto
         * @static
         * @param {casper.IRChainStateProto} message RChainStateProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RChainStateProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RChainStateProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.RChainStateProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.RChainStateProto} RChainStateProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RChainStateProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.RChainStateProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.preStateHash = reader.bytes();
                    break;
                case 2:
                    message.postStateHash = reader.bytes();
                    break;
                case 3:
                    if (!(message.bonds && message.bonds.length))
                        message.bonds = [];
                    message.bonds.push($root.casper.BondProto.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.blockNumber = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RChainStateProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.RChainStateProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.RChainStateProto} RChainStateProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RChainStateProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RChainStateProto message.
         * @function verify
         * @memberof casper.RChainStateProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RChainStateProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                if (!(message.preStateHash && typeof message.preStateHash.length === "number" || $util.isString(message.preStateHash)))
                    return "preStateHash: buffer expected";
            if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                if (!(message.postStateHash && typeof message.postStateHash.length === "number" || $util.isString(message.postStateHash)))
                    return "postStateHash: buffer expected";
            if (message.bonds != null && message.hasOwnProperty("bonds")) {
                if (!Array.isArray(message.bonds))
                    return "bonds: array expected";
                for (var i = 0; i < message.bonds.length; ++i) {
                    var error = $root.casper.BondProto.verify(message.bonds[i]);
                    if (error)
                        return "bonds." + error;
                }
            }
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            return null;
        };

        /**
         * Creates a RChainStateProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.RChainStateProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.RChainStateProto} RChainStateProto
         */
        RChainStateProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.RChainStateProto)
                return object;
            var message = new $root.casper.RChainStateProto();
            if (object.preStateHash != null)
                if (typeof object.preStateHash === "string")
                    $util.base64.decode(object.preStateHash, message.preStateHash = $util.newBuffer($util.base64.length(object.preStateHash)), 0);
                else if (object.preStateHash.length)
                    message.preStateHash = object.preStateHash;
            if (object.postStateHash != null)
                if (typeof object.postStateHash === "string")
                    $util.base64.decode(object.postStateHash, message.postStateHash = $util.newBuffer($util.base64.length(object.postStateHash)), 0);
                else if (object.postStateHash.length)
                    message.postStateHash = object.postStateHash;
            if (object.bonds) {
                if (!Array.isArray(object.bonds))
                    throw TypeError(".casper.RChainStateProto.bonds: array expected");
                message.bonds = [];
                for (var i = 0; i < object.bonds.length; ++i) {
                    if (typeof object.bonds[i] !== "object")
                        throw TypeError(".casper.RChainStateProto.bonds: object expected");
                    message.bonds[i] = $root.casper.BondProto.fromObject(object.bonds[i]);
                }
            }
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RChainStateProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.RChainStateProto
         * @static
         * @param {casper.RChainStateProto} message RChainStateProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RChainStateProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bonds = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.preStateHash = "";
                else {
                    object.preStateHash = [];
                    if (options.bytes !== Array)
                        object.preStateHash = $util.newBuffer(object.preStateHash);
                }
                if (options.bytes === String)
                    object.postStateHash = "";
                else {
                    object.postStateHash = [];
                    if (options.bytes !== Array)
                        object.postStateHash = $util.newBuffer(object.postStateHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
            }
            if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                object.preStateHash = options.bytes === String ? $util.base64.encode(message.preStateHash, 0, message.preStateHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.preStateHash) : message.preStateHash;
            if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                object.postStateHash = options.bytes === String ? $util.base64.encode(message.postStateHash, 0, message.postStateHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.postStateHash) : message.postStateHash;
            if (message.bonds && message.bonds.length) {
                object.bonds = [];
                for (var j = 0; j < message.bonds.length; ++j)
                    object.bonds[j] = $root.casper.BondProto.toObject(message.bonds[j], options);
            }
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            return object;
        };

        /**
         * Converts this RChainStateProto to JSON.
         * @function toJSON
         * @memberof casper.RChainStateProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RChainStateProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RChainStateProto;
    })();

    casper.EventProto = (function() {

        /**
         * Properties of an EventProto.
         * @memberof casper
         * @interface IEventProto
         * @property {casper.IProduceEventProto|null} [produce] EventProto produce
         * @property {casper.IConsumeEventProto|null} [consume] EventProto consume
         * @property {casper.ICommEventProto|null} [comm] EventProto comm
         */

        /**
         * Constructs a new EventProto.
         * @memberof casper
         * @classdesc Represents an EventProto.
         * @implements IEventProto
         * @constructor
         * @param {casper.IEventProto=} [properties] Properties to set
         */
        function EventProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventProto produce.
         * @member {casper.IProduceEventProto|null|undefined} produce
         * @memberof casper.EventProto
         * @instance
         */
        EventProto.prototype.produce = null;

        /**
         * EventProto consume.
         * @member {casper.IConsumeEventProto|null|undefined} consume
         * @memberof casper.EventProto
         * @instance
         */
        EventProto.prototype.consume = null;

        /**
         * EventProto comm.
         * @member {casper.ICommEventProto|null|undefined} comm
         * @memberof casper.EventProto
         * @instance
         */
        EventProto.prototype.comm = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * EventProto event_instance.
         * @member {"produce"|"consume"|"comm"|undefined} event_instance
         * @memberof casper.EventProto
         * @instance
         */
        Object.defineProperty(EventProto.prototype, "event_instance", {
            get: $util.oneOfGetter($oneOfFields = ["produce", "consume", "comm"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EventProto instance using the specified properties.
         * @function create
         * @memberof casper.EventProto
         * @static
         * @param {casper.IEventProto=} [properties] Properties to set
         * @returns {casper.EventProto} EventProto instance
         */
        EventProto.create = function create(properties) {
            return new EventProto(properties);
        };

        /**
         * Encodes the specified EventProto message. Does not implicitly {@link casper.EventProto.verify|verify} messages.
         * @function encode
         * @memberof casper.EventProto
         * @static
         * @param {casper.IEventProto} message EventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.produce != null && message.hasOwnProperty("produce"))
                $root.casper.ProduceEventProto.encode(message.produce, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.consume != null && message.hasOwnProperty("consume"))
                $root.casper.ConsumeEventProto.encode(message.consume, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.comm != null && message.hasOwnProperty("comm"))
                $root.casper.CommEventProto.encode(message.comm, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EventProto message, length delimited. Does not implicitly {@link casper.EventProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.EventProto
         * @static
         * @param {casper.IEventProto} message EventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.EventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.EventProto} EventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.EventProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.produce = $root.casper.ProduceEventProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.consume = $root.casper.ConsumeEventProto.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.comm = $root.casper.CommEventProto.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.EventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.EventProto} EventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventProto message.
         * @function verify
         * @memberof casper.EventProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.produce != null && message.hasOwnProperty("produce")) {
                properties.event_instance = 1;
                {
                    var error = $root.casper.ProduceEventProto.verify(message.produce);
                    if (error)
                        return "produce." + error;
                }
            }
            if (message.consume != null && message.hasOwnProperty("consume")) {
                if (properties.event_instance === 1)
                    return "event_instance: multiple values";
                properties.event_instance = 1;
                {
                    var error = $root.casper.ConsumeEventProto.verify(message.consume);
                    if (error)
                        return "consume." + error;
                }
            }
            if (message.comm != null && message.hasOwnProperty("comm")) {
                if (properties.event_instance === 1)
                    return "event_instance: multiple values";
                properties.event_instance = 1;
                {
                    var error = $root.casper.CommEventProto.verify(message.comm);
                    if (error)
                        return "comm." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EventProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.EventProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.EventProto} EventProto
         */
        EventProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.EventProto)
                return object;
            var message = new $root.casper.EventProto();
            if (object.produce != null) {
                if (typeof object.produce !== "object")
                    throw TypeError(".casper.EventProto.produce: object expected");
                message.produce = $root.casper.ProduceEventProto.fromObject(object.produce);
            }
            if (object.consume != null) {
                if (typeof object.consume !== "object")
                    throw TypeError(".casper.EventProto.consume: object expected");
                message.consume = $root.casper.ConsumeEventProto.fromObject(object.consume);
            }
            if (object.comm != null) {
                if (typeof object.comm !== "object")
                    throw TypeError(".casper.EventProto.comm: object expected");
                message.comm = $root.casper.CommEventProto.fromObject(object.comm);
            }
            return message;
        };

        /**
         * Creates a plain object from an EventProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.EventProto
         * @static
         * @param {casper.EventProto} message EventProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.produce != null && message.hasOwnProperty("produce")) {
                object.produce = $root.casper.ProduceEventProto.toObject(message.produce, options);
                if (options.oneofs)
                    object.event_instance = "produce";
            }
            if (message.consume != null && message.hasOwnProperty("consume")) {
                object.consume = $root.casper.ConsumeEventProto.toObject(message.consume, options);
                if (options.oneofs)
                    object.event_instance = "consume";
            }
            if (message.comm != null && message.hasOwnProperty("comm")) {
                object.comm = $root.casper.CommEventProto.toObject(message.comm, options);
                if (options.oneofs)
                    object.event_instance = "comm";
            }
            return object;
        };

        /**
         * Converts this EventProto to JSON.
         * @function toJSON
         * @memberof casper.EventProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventProto;
    })();

    casper.ProduceEventProto = (function() {

        /**
         * Properties of a ProduceEventProto.
         * @memberof casper
         * @interface IProduceEventProto
         * @property {Uint8Array|null} [channelsHash] ProduceEventProto channelsHash
         * @property {Uint8Array|null} [hash] ProduceEventProto hash
         * @property {boolean|null} [persistent] ProduceEventProto persistent
         * @property {number|null} [timesRepeated] ProduceEventProto timesRepeated
         */

        /**
         * Constructs a new ProduceEventProto.
         * @memberof casper
         * @classdesc Represents a ProduceEventProto.
         * @implements IProduceEventProto
         * @constructor
         * @param {casper.IProduceEventProto=} [properties] Properties to set
         */
        function ProduceEventProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProduceEventProto channelsHash.
         * @member {Uint8Array} channelsHash
         * @memberof casper.ProduceEventProto
         * @instance
         */
        ProduceEventProto.prototype.channelsHash = $util.newBuffer([]);

        /**
         * ProduceEventProto hash.
         * @member {Uint8Array} hash
         * @memberof casper.ProduceEventProto
         * @instance
         */
        ProduceEventProto.prototype.hash = $util.newBuffer([]);

        /**
         * ProduceEventProto persistent.
         * @member {boolean} persistent
         * @memberof casper.ProduceEventProto
         * @instance
         */
        ProduceEventProto.prototype.persistent = false;

        /**
         * ProduceEventProto timesRepeated.
         * @member {number} timesRepeated
         * @memberof casper.ProduceEventProto
         * @instance
         */
        ProduceEventProto.prototype.timesRepeated = 0;

        /**
         * Creates a new ProduceEventProto instance using the specified properties.
         * @function create
         * @memberof casper.ProduceEventProto
         * @static
         * @param {casper.IProduceEventProto=} [properties] Properties to set
         * @returns {casper.ProduceEventProto} ProduceEventProto instance
         */
        ProduceEventProto.create = function create(properties) {
            return new ProduceEventProto(properties);
        };

        /**
         * Encodes the specified ProduceEventProto message. Does not implicitly {@link casper.ProduceEventProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ProduceEventProto
         * @static
         * @param {casper.IProduceEventProto} message ProduceEventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProduceEventProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelsHash != null && message.hasOwnProperty("channelsHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelsHash);
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
            if (message.persistent != null && message.hasOwnProperty("persistent"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
            if (message.timesRepeated != null && message.hasOwnProperty("timesRepeated"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timesRepeated);
            return writer;
        };

        /**
         * Encodes the specified ProduceEventProto message, length delimited. Does not implicitly {@link casper.ProduceEventProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ProduceEventProto
         * @static
         * @param {casper.IProduceEventProto} message ProduceEventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProduceEventProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProduceEventProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ProduceEventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ProduceEventProto} ProduceEventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProduceEventProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ProduceEventProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelsHash = reader.bytes();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                case 3:
                    message.persistent = reader.bool();
                    break;
                case 4:
                    message.timesRepeated = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProduceEventProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ProduceEventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ProduceEventProto} ProduceEventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProduceEventProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProduceEventProto message.
         * @function verify
         * @memberof casper.ProduceEventProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProduceEventProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelsHash != null && message.hasOwnProperty("channelsHash"))
                if (!(message.channelsHash && typeof message.channelsHash.length === "number" || $util.isString(message.channelsHash)))
                    return "channelsHash: buffer expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.persistent != null && message.hasOwnProperty("persistent"))
                if (typeof message.persistent !== "boolean")
                    return "persistent: boolean expected";
            if (message.timesRepeated != null && message.hasOwnProperty("timesRepeated"))
                if (!$util.isInteger(message.timesRepeated))
                    return "timesRepeated: integer expected";
            return null;
        };

        /**
         * Creates a ProduceEventProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ProduceEventProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ProduceEventProto} ProduceEventProto
         */
        ProduceEventProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ProduceEventProto)
                return object;
            var message = new $root.casper.ProduceEventProto();
            if (object.channelsHash != null)
                if (typeof object.channelsHash === "string")
                    $util.base64.decode(object.channelsHash, message.channelsHash = $util.newBuffer($util.base64.length(object.channelsHash)), 0);
                else if (object.channelsHash.length)
                    message.channelsHash = object.channelsHash;
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.persistent != null)
                message.persistent = Boolean(object.persistent);
            if (object.timesRepeated != null)
                message.timesRepeated = object.timesRepeated | 0;
            return message;
        };

        /**
         * Creates a plain object from a ProduceEventProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ProduceEventProto
         * @static
         * @param {casper.ProduceEventProto} message ProduceEventProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProduceEventProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.channelsHash = "";
                else {
                    object.channelsHash = [];
                    if (options.bytes !== Array)
                        object.channelsHash = $util.newBuffer(object.channelsHash);
                }
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                object.persistent = false;
                object.timesRepeated = 0;
            }
            if (message.channelsHash != null && message.hasOwnProperty("channelsHash"))
                object.channelsHash = options.bytes === String ? $util.base64.encode(message.channelsHash, 0, message.channelsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelsHash) : message.channelsHash;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.persistent != null && message.hasOwnProperty("persistent"))
                object.persistent = message.persistent;
            if (message.timesRepeated != null && message.hasOwnProperty("timesRepeated"))
                object.timesRepeated = message.timesRepeated;
            return object;
        };

        /**
         * Converts this ProduceEventProto to JSON.
         * @function toJSON
         * @memberof casper.ProduceEventProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProduceEventProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProduceEventProto;
    })();

    casper.ConsumeEventProto = (function() {

        /**
         * Properties of a ConsumeEventProto.
         * @memberof casper
         * @interface IConsumeEventProto
         * @property {Array.<Uint8Array>|null} [channelsHashes] ConsumeEventProto channelsHashes
         * @property {Uint8Array|null} [hash] ConsumeEventProto hash
         * @property {boolean|null} [persistent] ConsumeEventProto persistent
         */

        /**
         * Constructs a new ConsumeEventProto.
         * @memberof casper
         * @classdesc Represents a ConsumeEventProto.
         * @implements IConsumeEventProto
         * @constructor
         * @param {casper.IConsumeEventProto=} [properties] Properties to set
         */
        function ConsumeEventProto(properties) {
            this.channelsHashes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConsumeEventProto channelsHashes.
         * @member {Array.<Uint8Array>} channelsHashes
         * @memberof casper.ConsumeEventProto
         * @instance
         */
        ConsumeEventProto.prototype.channelsHashes = $util.emptyArray;

        /**
         * ConsumeEventProto hash.
         * @member {Uint8Array} hash
         * @memberof casper.ConsumeEventProto
         * @instance
         */
        ConsumeEventProto.prototype.hash = $util.newBuffer([]);

        /**
         * ConsumeEventProto persistent.
         * @member {boolean} persistent
         * @memberof casper.ConsumeEventProto
         * @instance
         */
        ConsumeEventProto.prototype.persistent = false;

        /**
         * Creates a new ConsumeEventProto instance using the specified properties.
         * @function create
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {casper.IConsumeEventProto=} [properties] Properties to set
         * @returns {casper.ConsumeEventProto} ConsumeEventProto instance
         */
        ConsumeEventProto.create = function create(properties) {
            return new ConsumeEventProto(properties);
        };

        /**
         * Encodes the specified ConsumeEventProto message. Does not implicitly {@link casper.ConsumeEventProto.verify|verify} messages.
         * @function encode
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {casper.IConsumeEventProto} message ConsumeEventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsumeEventProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelsHashes != null && message.channelsHashes.length)
                for (var i = 0; i < message.channelsHashes.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelsHashes[i]);
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
            if (message.persistent != null && message.hasOwnProperty("persistent"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
            return writer;
        };

        /**
         * Encodes the specified ConsumeEventProto message, length delimited. Does not implicitly {@link casper.ConsumeEventProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {casper.IConsumeEventProto} message ConsumeEventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsumeEventProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConsumeEventProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ConsumeEventProto} ConsumeEventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsumeEventProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ConsumeEventProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channelsHashes && message.channelsHashes.length))
                        message.channelsHashes = [];
                    message.channelsHashes.push(reader.bytes());
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                case 3:
                    message.persistent = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConsumeEventProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ConsumeEventProto} ConsumeEventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsumeEventProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConsumeEventProto message.
         * @function verify
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConsumeEventProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelsHashes != null && message.hasOwnProperty("channelsHashes")) {
                if (!Array.isArray(message.channelsHashes))
                    return "channelsHashes: array expected";
                for (var i = 0; i < message.channelsHashes.length; ++i)
                    if (!(message.channelsHashes[i] && typeof message.channelsHashes[i].length === "number" || $util.isString(message.channelsHashes[i])))
                        return "channelsHashes: buffer[] expected";
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.persistent != null && message.hasOwnProperty("persistent"))
                if (typeof message.persistent !== "boolean")
                    return "persistent: boolean expected";
            return null;
        };

        /**
         * Creates a ConsumeEventProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ConsumeEventProto} ConsumeEventProto
         */
        ConsumeEventProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ConsumeEventProto)
                return object;
            var message = new $root.casper.ConsumeEventProto();
            if (object.channelsHashes) {
                if (!Array.isArray(object.channelsHashes))
                    throw TypeError(".casper.ConsumeEventProto.channelsHashes: array expected");
                message.channelsHashes = [];
                for (var i = 0; i < object.channelsHashes.length; ++i)
                    if (typeof object.channelsHashes[i] === "string")
                        $util.base64.decode(object.channelsHashes[i], message.channelsHashes[i] = $util.newBuffer($util.base64.length(object.channelsHashes[i])), 0);
                    else if (object.channelsHashes[i].length)
                        message.channelsHashes[i] = object.channelsHashes[i];
            }
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.persistent != null)
                message.persistent = Boolean(object.persistent);
            return message;
        };

        /**
         * Creates a plain object from a ConsumeEventProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ConsumeEventProto
         * @static
         * @param {casper.ConsumeEventProto} message ConsumeEventProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConsumeEventProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.channelsHashes = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                object.persistent = false;
            }
            if (message.channelsHashes && message.channelsHashes.length) {
                object.channelsHashes = [];
                for (var j = 0; j < message.channelsHashes.length; ++j)
                    object.channelsHashes[j] = options.bytes === String ? $util.base64.encode(message.channelsHashes[j], 0, message.channelsHashes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.channelsHashes[j]) : message.channelsHashes[j];
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.persistent != null && message.hasOwnProperty("persistent"))
                object.persistent = message.persistent;
            return object;
        };

        /**
         * Converts this ConsumeEventProto to JSON.
         * @function toJSON
         * @memberof casper.ConsumeEventProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConsumeEventProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConsumeEventProto;
    })();

    casper.CommEventProto = (function() {

        /**
         * Properties of a CommEventProto.
         * @memberof casper
         * @interface ICommEventProto
         * @property {casper.IConsumeEventProto|null} [consume] CommEventProto consume
         * @property {Array.<casper.IProduceEventProto>|null} [produces] CommEventProto produces
         * @property {Array.<casper.IPeekProto>|null} [peeks] CommEventProto peeks
         */

        /**
         * Constructs a new CommEventProto.
         * @memberof casper
         * @classdesc Represents a CommEventProto.
         * @implements ICommEventProto
         * @constructor
         * @param {casper.ICommEventProto=} [properties] Properties to set
         */
        function CommEventProto(properties) {
            this.produces = [];
            this.peeks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommEventProto consume.
         * @member {casper.IConsumeEventProto|null|undefined} consume
         * @memberof casper.CommEventProto
         * @instance
         */
        CommEventProto.prototype.consume = null;

        /**
         * CommEventProto produces.
         * @member {Array.<casper.IProduceEventProto>} produces
         * @memberof casper.CommEventProto
         * @instance
         */
        CommEventProto.prototype.produces = $util.emptyArray;

        /**
         * CommEventProto peeks.
         * @member {Array.<casper.IPeekProto>} peeks
         * @memberof casper.CommEventProto
         * @instance
         */
        CommEventProto.prototype.peeks = $util.emptyArray;

        /**
         * Creates a new CommEventProto instance using the specified properties.
         * @function create
         * @memberof casper.CommEventProto
         * @static
         * @param {casper.ICommEventProto=} [properties] Properties to set
         * @returns {casper.CommEventProto} CommEventProto instance
         */
        CommEventProto.create = function create(properties) {
            return new CommEventProto(properties);
        };

        /**
         * Encodes the specified CommEventProto message. Does not implicitly {@link casper.CommEventProto.verify|verify} messages.
         * @function encode
         * @memberof casper.CommEventProto
         * @static
         * @param {casper.ICommEventProto} message CommEventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommEventProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.consume != null && message.hasOwnProperty("consume"))
                $root.casper.ConsumeEventProto.encode(message.consume, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.produces != null && message.produces.length)
                for (var i = 0; i < message.produces.length; ++i)
                    $root.casper.ProduceEventProto.encode(message.produces[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.peeks != null && message.peeks.length)
                for (var i = 0; i < message.peeks.length; ++i)
                    $root.casper.PeekProto.encode(message.peeks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CommEventProto message, length delimited. Does not implicitly {@link casper.CommEventProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.CommEventProto
         * @static
         * @param {casper.ICommEventProto} message CommEventProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommEventProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommEventProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.CommEventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.CommEventProto} CommEventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommEventProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.CommEventProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.consume = $root.casper.ConsumeEventProto.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.produces && message.produces.length))
                        message.produces = [];
                    message.produces.push($root.casper.ProduceEventProto.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.peeks && message.peeks.length))
                        message.peeks = [];
                    message.peeks.push($root.casper.PeekProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommEventProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.CommEventProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.CommEventProto} CommEventProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommEventProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommEventProto message.
         * @function verify
         * @memberof casper.CommEventProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommEventProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.consume != null && message.hasOwnProperty("consume")) {
                var error = $root.casper.ConsumeEventProto.verify(message.consume);
                if (error)
                    return "consume." + error;
            }
            if (message.produces != null && message.hasOwnProperty("produces")) {
                if (!Array.isArray(message.produces))
                    return "produces: array expected";
                for (var i = 0; i < message.produces.length; ++i) {
                    var error = $root.casper.ProduceEventProto.verify(message.produces[i]);
                    if (error)
                        return "produces." + error;
                }
            }
            if (message.peeks != null && message.hasOwnProperty("peeks")) {
                if (!Array.isArray(message.peeks))
                    return "peeks: array expected";
                for (var i = 0; i < message.peeks.length; ++i) {
                    var error = $root.casper.PeekProto.verify(message.peeks[i]);
                    if (error)
                        return "peeks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CommEventProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.CommEventProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.CommEventProto} CommEventProto
         */
        CommEventProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.CommEventProto)
                return object;
            var message = new $root.casper.CommEventProto();
            if (object.consume != null) {
                if (typeof object.consume !== "object")
                    throw TypeError(".casper.CommEventProto.consume: object expected");
                message.consume = $root.casper.ConsumeEventProto.fromObject(object.consume);
            }
            if (object.produces) {
                if (!Array.isArray(object.produces))
                    throw TypeError(".casper.CommEventProto.produces: array expected");
                message.produces = [];
                for (var i = 0; i < object.produces.length; ++i) {
                    if (typeof object.produces[i] !== "object")
                        throw TypeError(".casper.CommEventProto.produces: object expected");
                    message.produces[i] = $root.casper.ProduceEventProto.fromObject(object.produces[i]);
                }
            }
            if (object.peeks) {
                if (!Array.isArray(object.peeks))
                    throw TypeError(".casper.CommEventProto.peeks: array expected");
                message.peeks = [];
                for (var i = 0; i < object.peeks.length; ++i) {
                    if (typeof object.peeks[i] !== "object")
                        throw TypeError(".casper.CommEventProto.peeks: object expected");
                    message.peeks[i] = $root.casper.PeekProto.fromObject(object.peeks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CommEventProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.CommEventProto
         * @static
         * @param {casper.CommEventProto} message CommEventProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommEventProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.produces = [];
                object.peeks = [];
            }
            if (options.defaults)
                object.consume = null;
            if (message.consume != null && message.hasOwnProperty("consume"))
                object.consume = $root.casper.ConsumeEventProto.toObject(message.consume, options);
            if (message.produces && message.produces.length) {
                object.produces = [];
                for (var j = 0; j < message.produces.length; ++j)
                    object.produces[j] = $root.casper.ProduceEventProto.toObject(message.produces[j], options);
            }
            if (message.peeks && message.peeks.length) {
                object.peeks = [];
                for (var j = 0; j < message.peeks.length; ++j)
                    object.peeks[j] = $root.casper.PeekProto.toObject(message.peeks[j], options);
            }
            return object;
        };

        /**
         * Converts this CommEventProto to JSON.
         * @function toJSON
         * @memberof casper.CommEventProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommEventProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommEventProto;
    })();

    casper.PeekProto = (function() {

        /**
         * Properties of a PeekProto.
         * @memberof casper
         * @interface IPeekProto
         * @property {number|null} [channelIndex] PeekProto channelIndex
         */

        /**
         * Constructs a new PeekProto.
         * @memberof casper
         * @classdesc Represents a PeekProto.
         * @implements IPeekProto
         * @constructor
         * @param {casper.IPeekProto=} [properties] Properties to set
         */
        function PeekProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PeekProto channelIndex.
         * @member {number} channelIndex
         * @memberof casper.PeekProto
         * @instance
         */
        PeekProto.prototype.channelIndex = 0;

        /**
         * Creates a new PeekProto instance using the specified properties.
         * @function create
         * @memberof casper.PeekProto
         * @static
         * @param {casper.IPeekProto=} [properties] Properties to set
         * @returns {casper.PeekProto} PeekProto instance
         */
        PeekProto.create = function create(properties) {
            return new PeekProto(properties);
        };

        /**
         * Encodes the specified PeekProto message. Does not implicitly {@link casper.PeekProto.verify|verify} messages.
         * @function encode
         * @memberof casper.PeekProto
         * @static
         * @param {casper.IPeekProto} message PeekProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeekProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.channelIndex);
            return writer;
        };

        /**
         * Encodes the specified PeekProto message, length delimited. Does not implicitly {@link casper.PeekProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.PeekProto
         * @static
         * @param {casper.IPeekProto} message PeekProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeekProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PeekProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.PeekProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.PeekProto} PeekProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeekProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.PeekProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeekProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.PeekProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.PeekProto} PeekProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeekProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PeekProto message.
         * @function verify
         * @memberof casper.PeekProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PeekProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                if (!$util.isInteger(message.channelIndex))
                    return "channelIndex: integer expected";
            return null;
        };

        /**
         * Creates a PeekProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.PeekProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.PeekProto} PeekProto
         */
        PeekProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.PeekProto)
                return object;
            var message = new $root.casper.PeekProto();
            if (object.channelIndex != null)
                message.channelIndex = object.channelIndex | 0;
            return message;
        };

        /**
         * Creates a plain object from a PeekProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.PeekProto
         * @static
         * @param {casper.PeekProto} message PeekProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PeekProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.channelIndex = 0;
            if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                object.channelIndex = message.channelIndex;
            return object;
        };

        /**
         * Converts this PeekProto to JSON.
         * @function toJSON
         * @memberof casper.PeekProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PeekProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PeekProto;
    })();

    casper.BondProto = (function() {

        /**
         * Properties of a BondProto.
         * @memberof casper
         * @interface IBondProto
         * @property {Uint8Array|null} [validator] BondProto validator
         * @property {number|Long|null} [stake] BondProto stake
         */

        /**
         * Constructs a new BondProto.
         * @memberof casper
         * @classdesc Represents a BondProto.
         * @implements IBondProto
         * @constructor
         * @param {casper.IBondProto=} [properties] Properties to set
         */
        function BondProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BondProto validator.
         * @member {Uint8Array} validator
         * @memberof casper.BondProto
         * @instance
         */
        BondProto.prototype.validator = $util.newBuffer([]);

        /**
         * BondProto stake.
         * @member {number|Long} stake
         * @memberof casper.BondProto
         * @instance
         */
        BondProto.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BondProto instance using the specified properties.
         * @function create
         * @memberof casper.BondProto
         * @static
         * @param {casper.IBondProto=} [properties] Properties to set
         * @returns {casper.BondProto} BondProto instance
         */
        BondProto.create = function create(properties) {
            return new BondProto(properties);
        };

        /**
         * Encodes the specified BondProto message. Does not implicitly {@link casper.BondProto.verify|verify} messages.
         * @function encode
         * @memberof casper.BondProto
         * @static
         * @param {casper.IBondProto} message BondProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BondProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validator != null && message.hasOwnProperty("validator"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.validator);
            if (message.stake != null && message.hasOwnProperty("stake"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.stake);
            return writer;
        };

        /**
         * Encodes the specified BondProto message, length delimited. Does not implicitly {@link casper.BondProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BondProto
         * @static
         * @param {casper.IBondProto} message BondProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BondProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BondProto message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BondProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BondProto} BondProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BondProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BondProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.validator = reader.bytes();
                    break;
                case 2:
                    message.stake = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BondProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BondProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BondProto} BondProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BondProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BondProto message.
         * @function verify
         * @memberof casper.BondProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BondProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validator != null && message.hasOwnProperty("validator"))
                if (!(message.validator && typeof message.validator.length === "number" || $util.isString(message.validator)))
                    return "validator: buffer expected";
            if (message.stake != null && message.hasOwnProperty("stake"))
                if (!$util.isInteger(message.stake) && !(message.stake && $util.isInteger(message.stake.low) && $util.isInteger(message.stake.high)))
                    return "stake: integer|Long expected";
            return null;
        };

        /**
         * Creates a BondProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BondProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BondProto} BondProto
         */
        BondProto.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BondProto)
                return object;
            var message = new $root.casper.BondProto();
            if (object.validator != null)
                if (typeof object.validator === "string")
                    $util.base64.decode(object.validator, message.validator = $util.newBuffer($util.base64.length(object.validator)), 0);
                else if (object.validator.length)
                    message.validator = object.validator;
            if (object.stake != null)
                if ($util.Long)
                    (message.stake = $util.Long.fromValue(object.stake)).unsigned = false;
                else if (typeof object.stake === "string")
                    message.stake = parseInt(object.stake, 10);
                else if (typeof object.stake === "number")
                    message.stake = object.stake;
                else if (typeof object.stake === "object")
                    message.stake = new $util.LongBits(object.stake.low >>> 0, object.stake.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BondProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BondProto
         * @static
         * @param {casper.BondProto} message BondProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BondProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.validator = "";
                else {
                    object.validator = [];
                    if (options.bytes !== Array)
                        object.validator = $util.newBuffer(object.validator);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.stake = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.stake = options.longs === String ? "0" : 0;
            }
            if (message.validator != null && message.hasOwnProperty("validator"))
                object.validator = options.bytes === String ? $util.base64.encode(message.validator, 0, message.validator.length) : options.bytes === Array ? Array.prototype.slice.call(message.validator) : message.validator;
            if (message.stake != null && message.hasOwnProperty("stake"))
                if (typeof message.stake === "number")
                    object.stake = options.longs === String ? String(message.stake) : message.stake;
                else
                    object.stake = options.longs === String ? $util.Long.prototype.toString.call(message.stake) : options.longs === Number ? new $util.LongBits(message.stake.low >>> 0, message.stake.high >>> 0).toNumber() : message.stake;
            return object;
        };

        /**
         * Converts this BondProto to JSON.
         * @function toJSON
         * @memberof casper.BondProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BondProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BondProto;
    })();

    casper.FindDeployQuery = (function() {

        /**
         * Properties of a FindDeployQuery.
         * @memberof casper
         * @interface IFindDeployQuery
         * @property {Uint8Array|null} [deployId] FindDeployQuery deployId
         */

        /**
         * Constructs a new FindDeployQuery.
         * @memberof casper
         * @classdesc Represents a FindDeployQuery.
         * @implements IFindDeployQuery
         * @constructor
         * @param {casper.IFindDeployQuery=} [properties] Properties to set
         */
        function FindDeployQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FindDeployQuery deployId.
         * @member {Uint8Array} deployId
         * @memberof casper.FindDeployQuery
         * @instance
         */
        FindDeployQuery.prototype.deployId = $util.newBuffer([]);

        /**
         * Creates a new FindDeployQuery instance using the specified properties.
         * @function create
         * @memberof casper.FindDeployQuery
         * @static
         * @param {casper.IFindDeployQuery=} [properties] Properties to set
         * @returns {casper.FindDeployQuery} FindDeployQuery instance
         */
        FindDeployQuery.create = function create(properties) {
            return new FindDeployQuery(properties);
        };

        /**
         * Encodes the specified FindDeployQuery message. Does not implicitly {@link casper.FindDeployQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.FindDeployQuery
         * @static
         * @param {casper.IFindDeployQuery} message FindDeployQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindDeployQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deployId != null && message.hasOwnProperty("deployId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deployId);
            return writer;
        };

        /**
         * Encodes the specified FindDeployQuery message, length delimited. Does not implicitly {@link casper.FindDeployQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.FindDeployQuery
         * @static
         * @param {casper.IFindDeployQuery} message FindDeployQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindDeployQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FindDeployQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.FindDeployQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.FindDeployQuery} FindDeployQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindDeployQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.FindDeployQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deployId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FindDeployQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.FindDeployQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.FindDeployQuery} FindDeployQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindDeployQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FindDeployQuery message.
         * @function verify
         * @memberof casper.FindDeployQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FindDeployQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deployId != null && message.hasOwnProperty("deployId"))
                if (!(message.deployId && typeof message.deployId.length === "number" || $util.isString(message.deployId)))
                    return "deployId: buffer expected";
            return null;
        };

        /**
         * Creates a FindDeployQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.FindDeployQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.FindDeployQuery} FindDeployQuery
         */
        FindDeployQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.FindDeployQuery)
                return object;
            var message = new $root.casper.FindDeployQuery();
            if (object.deployId != null)
                if (typeof object.deployId === "string")
                    $util.base64.decode(object.deployId, message.deployId = $util.newBuffer($util.base64.length(object.deployId)), 0);
                else if (object.deployId.length)
                    message.deployId = object.deployId;
            return message;
        };

        /**
         * Creates a plain object from a FindDeployQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.FindDeployQuery
         * @static
         * @param {casper.FindDeployQuery} message FindDeployQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FindDeployQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.deployId = "";
                else {
                    object.deployId = [];
                    if (options.bytes !== Array)
                        object.deployId = $util.newBuffer(object.deployId);
                }
            if (message.deployId != null && message.hasOwnProperty("deployId"))
                object.deployId = options.bytes === String ? $util.base64.encode(message.deployId, 0, message.deployId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deployId) : message.deployId;
            return object;
        };

        /**
         * Converts this FindDeployQuery to JSON.
         * @function toJSON
         * @memberof casper.FindDeployQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FindDeployQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FindDeployQuery;
    })();

    casper.BlockQuery = (function() {

        /**
         * Properties of a BlockQuery.
         * @memberof casper
         * @interface IBlockQuery
         * @property {string|null} [hash] BlockQuery hash
         */

        /**
         * Constructs a new BlockQuery.
         * @memberof casper
         * @classdesc Represents a BlockQuery.
         * @implements IBlockQuery
         * @constructor
         * @param {casper.IBlockQuery=} [properties] Properties to set
         */
        function BlockQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockQuery hash.
         * @member {string} hash
         * @memberof casper.BlockQuery
         * @instance
         */
        BlockQuery.prototype.hash = "";

        /**
         * Creates a new BlockQuery instance using the specified properties.
         * @function create
         * @memberof casper.BlockQuery
         * @static
         * @param {casper.IBlockQuery=} [properties] Properties to set
         * @returns {casper.BlockQuery} BlockQuery instance
         */
        BlockQuery.create = function create(properties) {
            return new BlockQuery(properties);
        };

        /**
         * Encodes the specified BlockQuery message. Does not implicitly {@link casper.BlockQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockQuery
         * @static
         * @param {casper.IBlockQuery} message BlockQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            return writer;
        };

        /**
         * Encodes the specified BlockQuery message, length delimited. Does not implicitly {@link casper.BlockQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockQuery
         * @static
         * @param {casper.IBlockQuery} message BlockQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockQuery} BlockQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockQuery} BlockQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockQuery message.
         * @function verify
         * @memberof casper.BlockQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            return null;
        };

        /**
         * Creates a BlockQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockQuery} BlockQuery
         */
        BlockQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockQuery)
                return object;
            var message = new $root.casper.BlockQuery();
            if (object.hash != null)
                message.hash = String(object.hash);
            return message;
        };

        /**
         * Creates a plain object from a BlockQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockQuery
         * @static
         * @param {casper.BlockQuery} message BlockQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hash = "";
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            return object;
        };

        /**
         * Converts this BlockQuery to JSON.
         * @function toJSON
         * @memberof casper.BlockQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockQuery;
    })();

    casper.BlocksQuery = (function() {

        /**
         * Properties of a BlocksQuery.
         * @memberof casper
         * @interface IBlocksQuery
         * @property {number|null} [depth] BlocksQuery depth
         */

        /**
         * Constructs a new BlocksQuery.
         * @memberof casper
         * @classdesc Represents a BlocksQuery.
         * @implements IBlocksQuery
         * @constructor
         * @param {casper.IBlocksQuery=} [properties] Properties to set
         */
        function BlocksQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlocksQuery depth.
         * @member {number} depth
         * @memberof casper.BlocksQuery
         * @instance
         */
        BlocksQuery.prototype.depth = 0;

        /**
         * Creates a new BlocksQuery instance using the specified properties.
         * @function create
         * @memberof casper.BlocksQuery
         * @static
         * @param {casper.IBlocksQuery=} [properties] Properties to set
         * @returns {casper.BlocksQuery} BlocksQuery instance
         */
        BlocksQuery.create = function create(properties) {
            return new BlocksQuery(properties);
        };

        /**
         * Encodes the specified BlocksQuery message. Does not implicitly {@link casper.BlocksQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.BlocksQuery
         * @static
         * @param {casper.IBlocksQuery} message BlocksQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlocksQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.depth != null && message.hasOwnProperty("depth"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
            return writer;
        };

        /**
         * Encodes the specified BlocksQuery message, length delimited. Does not implicitly {@link casper.BlocksQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlocksQuery
         * @static
         * @param {casper.IBlocksQuery} message BlocksQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlocksQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlocksQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlocksQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlocksQuery} BlocksQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlocksQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlocksQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.depth = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlocksQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlocksQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlocksQuery} BlocksQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlocksQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlocksQuery message.
         * @function verify
         * @memberof casper.BlocksQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlocksQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.depth != null && message.hasOwnProperty("depth"))
                if (!$util.isInteger(message.depth))
                    return "depth: integer expected";
            return null;
        };

        /**
         * Creates a BlocksQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlocksQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlocksQuery} BlocksQuery
         */
        BlocksQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlocksQuery)
                return object;
            var message = new $root.casper.BlocksQuery();
            if (object.depth != null)
                message.depth = object.depth | 0;
            return message;
        };

        /**
         * Creates a plain object from a BlocksQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlocksQuery
         * @static
         * @param {casper.BlocksQuery} message BlocksQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlocksQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.depth = 0;
            if (message.depth != null && message.hasOwnProperty("depth"))
                object.depth = message.depth;
            return object;
        };

        /**
         * Converts this BlocksQuery to JSON.
         * @function toJSON
         * @memberof casper.BlocksQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlocksQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlocksQuery;
    })();

    casper.DataAtNameQuery = (function() {

        /**
         * Properties of a DataAtNameQuery.
         * @memberof casper
         * @interface IDataAtNameQuery
         * @property {number|null} [depth] DataAtNameQuery depth
         * @property {IPar|null} [name] DataAtNameQuery name
         */

        /**
         * Constructs a new DataAtNameQuery.
         * @memberof casper
         * @classdesc Represents a DataAtNameQuery.
         * @implements IDataAtNameQuery
         * @constructor
         * @param {casper.IDataAtNameQuery=} [properties] Properties to set
         */
        function DataAtNameQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataAtNameQuery depth.
         * @member {number} depth
         * @memberof casper.DataAtNameQuery
         * @instance
         */
        DataAtNameQuery.prototype.depth = 0;

        /**
         * DataAtNameQuery name.
         * @member {IPar|null|undefined} name
         * @memberof casper.DataAtNameQuery
         * @instance
         */
        DataAtNameQuery.prototype.name = null;

        /**
         * Creates a new DataAtNameQuery instance using the specified properties.
         * @function create
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {casper.IDataAtNameQuery=} [properties] Properties to set
         * @returns {casper.DataAtNameQuery} DataAtNameQuery instance
         */
        DataAtNameQuery.create = function create(properties) {
            return new DataAtNameQuery(properties);
        };

        /**
         * Encodes the specified DataAtNameQuery message. Does not implicitly {@link casper.DataAtNameQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {casper.IDataAtNameQuery} message DataAtNameQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataAtNameQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.depth != null && message.hasOwnProperty("depth"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
            if (message.name != null && message.hasOwnProperty("name"))
                $root.Par.encode(message.name, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DataAtNameQuery message, length delimited. Does not implicitly {@link casper.DataAtNameQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {casper.IDataAtNameQuery} message DataAtNameQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataAtNameQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataAtNameQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.DataAtNameQuery} DataAtNameQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataAtNameQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DataAtNameQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.depth = reader.int32();
                    break;
                case 2:
                    message.name = $root.Par.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataAtNameQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.DataAtNameQuery} DataAtNameQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataAtNameQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataAtNameQuery message.
         * @function verify
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataAtNameQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.depth != null && message.hasOwnProperty("depth"))
                if (!$util.isInteger(message.depth))
                    return "depth: integer expected";
            if (message.name != null && message.hasOwnProperty("name")) {
                var error = $root.Par.verify(message.name);
                if (error)
                    return "name." + error;
            }
            return null;
        };

        /**
         * Creates a DataAtNameQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.DataAtNameQuery} DataAtNameQuery
         */
        DataAtNameQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.DataAtNameQuery)
                return object;
            var message = new $root.casper.DataAtNameQuery();
            if (object.depth != null)
                message.depth = object.depth | 0;
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".casper.DataAtNameQuery.name: object expected");
                message.name = $root.Par.fromObject(object.name);
            }
            return message;
        };

        /**
         * Creates a plain object from a DataAtNameQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.DataAtNameQuery
         * @static
         * @param {casper.DataAtNameQuery} message DataAtNameQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataAtNameQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.depth = 0;
                object.name = null;
            }
            if (message.depth != null && message.hasOwnProperty("depth"))
                object.depth = message.depth;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = $root.Par.toObject(message.name, options);
            return object;
        };

        /**
         * Converts this DataAtNameQuery to JSON.
         * @function toJSON
         * @memberof casper.DataAtNameQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataAtNameQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DataAtNameQuery;
    })();

    casper.ContinuationAtNameQuery = (function() {

        /**
         * Properties of a ContinuationAtNameQuery.
         * @memberof casper
         * @interface IContinuationAtNameQuery
         * @property {number|null} [depth] ContinuationAtNameQuery depth
         * @property {Array.<IPar>|null} [names] ContinuationAtNameQuery names
         */

        /**
         * Constructs a new ContinuationAtNameQuery.
         * @memberof casper
         * @classdesc Represents a ContinuationAtNameQuery.
         * @implements IContinuationAtNameQuery
         * @constructor
         * @param {casper.IContinuationAtNameQuery=} [properties] Properties to set
         */
        function ContinuationAtNameQuery(properties) {
            this.names = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContinuationAtNameQuery depth.
         * @member {number} depth
         * @memberof casper.ContinuationAtNameQuery
         * @instance
         */
        ContinuationAtNameQuery.prototype.depth = 0;

        /**
         * ContinuationAtNameQuery names.
         * @member {Array.<IPar>} names
         * @memberof casper.ContinuationAtNameQuery
         * @instance
         */
        ContinuationAtNameQuery.prototype.names = $util.emptyArray;

        /**
         * Creates a new ContinuationAtNameQuery instance using the specified properties.
         * @function create
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {casper.IContinuationAtNameQuery=} [properties] Properties to set
         * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery instance
         */
        ContinuationAtNameQuery.create = function create(properties) {
            return new ContinuationAtNameQuery(properties);
        };

        /**
         * Encodes the specified ContinuationAtNameQuery message. Does not implicitly {@link casper.ContinuationAtNameQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {casper.IContinuationAtNameQuery} message ContinuationAtNameQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuationAtNameQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.depth != null && message.hasOwnProperty("depth"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
            if (message.names != null && message.names.length)
                for (var i = 0; i < message.names.length; ++i)
                    $root.Par.encode(message.names[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContinuationAtNameQuery message, length delimited. Does not implicitly {@link casper.ContinuationAtNameQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {casper.IContinuationAtNameQuery} message ContinuationAtNameQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuationAtNameQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContinuationAtNameQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuationAtNameQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ContinuationAtNameQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.depth = reader.int32();
                    break;
                case 2:
                    if (!(message.names && message.names.length))
                        message.names = [];
                    message.names.push($root.Par.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContinuationAtNameQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuationAtNameQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContinuationAtNameQuery message.
         * @function verify
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContinuationAtNameQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.depth != null && message.hasOwnProperty("depth"))
                if (!$util.isInteger(message.depth))
                    return "depth: integer expected";
            if (message.names != null && message.hasOwnProperty("names")) {
                if (!Array.isArray(message.names))
                    return "names: array expected";
                for (var i = 0; i < message.names.length; ++i) {
                    var error = $root.Par.verify(message.names[i]);
                    if (error)
                        return "names." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ContinuationAtNameQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery
         */
        ContinuationAtNameQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ContinuationAtNameQuery)
                return object;
            var message = new $root.casper.ContinuationAtNameQuery();
            if (object.depth != null)
                message.depth = object.depth | 0;
            if (object.names) {
                if (!Array.isArray(object.names))
                    throw TypeError(".casper.ContinuationAtNameQuery.names: array expected");
                message.names = [];
                for (var i = 0; i < object.names.length; ++i) {
                    if (typeof object.names[i] !== "object")
                        throw TypeError(".casper.ContinuationAtNameQuery.names: object expected");
                    message.names[i] = $root.Par.fromObject(object.names[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ContinuationAtNameQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ContinuationAtNameQuery
         * @static
         * @param {casper.ContinuationAtNameQuery} message ContinuationAtNameQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContinuationAtNameQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.names = [];
            if (options.defaults)
                object.depth = 0;
            if (message.depth != null && message.hasOwnProperty("depth"))
                object.depth = message.depth;
            if (message.names && message.names.length) {
                object.names = [];
                for (var j = 0; j < message.names.length; ++j)
                    object.names[j] = $root.Par.toObject(message.names[j], options);
            }
            return object;
        };

        /**
         * Converts this ContinuationAtNameQuery to JSON.
         * @function toJSON
         * @memberof casper.ContinuationAtNameQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContinuationAtNameQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContinuationAtNameQuery;
    })();

    casper.VisualizeDagQuery = (function() {

        /**
         * Properties of a VisualizeDagQuery.
         * @memberof casper
         * @interface IVisualizeDagQuery
         * @property {number|null} [depth] VisualizeDagQuery depth
         * @property {boolean|null} [showJustificationLines] VisualizeDagQuery showJustificationLines
         */

        /**
         * Constructs a new VisualizeDagQuery.
         * @memberof casper
         * @classdesc Represents a VisualizeDagQuery.
         * @implements IVisualizeDagQuery
         * @constructor
         * @param {casper.IVisualizeDagQuery=} [properties] Properties to set
         */
        function VisualizeDagQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VisualizeDagQuery depth.
         * @member {number} depth
         * @memberof casper.VisualizeDagQuery
         * @instance
         */
        VisualizeDagQuery.prototype.depth = 0;

        /**
         * VisualizeDagQuery showJustificationLines.
         * @member {boolean} showJustificationLines
         * @memberof casper.VisualizeDagQuery
         * @instance
         */
        VisualizeDagQuery.prototype.showJustificationLines = false;

        /**
         * Creates a new VisualizeDagQuery instance using the specified properties.
         * @function create
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {casper.IVisualizeDagQuery=} [properties] Properties to set
         * @returns {casper.VisualizeDagQuery} VisualizeDagQuery instance
         */
        VisualizeDagQuery.create = function create(properties) {
            return new VisualizeDagQuery(properties);
        };

        /**
         * Encodes the specified VisualizeDagQuery message. Does not implicitly {@link casper.VisualizeDagQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {casper.IVisualizeDagQuery} message VisualizeDagQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VisualizeDagQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.depth != null && message.hasOwnProperty("depth"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
            if (message.showJustificationLines != null && message.hasOwnProperty("showJustificationLines"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.showJustificationLines);
            return writer;
        };

        /**
         * Encodes the specified VisualizeDagQuery message, length delimited. Does not implicitly {@link casper.VisualizeDagQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {casper.IVisualizeDagQuery} message VisualizeDagQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VisualizeDagQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VisualizeDagQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.VisualizeDagQuery} VisualizeDagQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VisualizeDagQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.VisualizeDagQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.depth = reader.int32();
                    break;
                case 2:
                    message.showJustificationLines = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VisualizeDagQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.VisualizeDagQuery} VisualizeDagQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VisualizeDagQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VisualizeDagQuery message.
         * @function verify
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VisualizeDagQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.depth != null && message.hasOwnProperty("depth"))
                if (!$util.isInteger(message.depth))
                    return "depth: integer expected";
            if (message.showJustificationLines != null && message.hasOwnProperty("showJustificationLines"))
                if (typeof message.showJustificationLines !== "boolean")
                    return "showJustificationLines: boolean expected";
            return null;
        };

        /**
         * Creates a VisualizeDagQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.VisualizeDagQuery} VisualizeDagQuery
         */
        VisualizeDagQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.VisualizeDagQuery)
                return object;
            var message = new $root.casper.VisualizeDagQuery();
            if (object.depth != null)
                message.depth = object.depth | 0;
            if (object.showJustificationLines != null)
                message.showJustificationLines = Boolean(object.showJustificationLines);
            return message;
        };

        /**
         * Creates a plain object from a VisualizeDagQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.VisualizeDagQuery
         * @static
         * @param {casper.VisualizeDagQuery} message VisualizeDagQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VisualizeDagQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.depth = 0;
                object.showJustificationLines = false;
            }
            if (message.depth != null && message.hasOwnProperty("depth"))
                object.depth = message.depth;
            if (message.showJustificationLines != null && message.hasOwnProperty("showJustificationLines"))
                object.showJustificationLines = message.showJustificationLines;
            return object;
        };

        /**
         * Converts this VisualizeDagQuery to JSON.
         * @function toJSON
         * @memberof casper.VisualizeDagQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VisualizeDagQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VisualizeDagQuery;
    })();

    casper.MachineVerifyQuery = (function() {

        /**
         * Properties of a MachineVerifyQuery.
         * @memberof casper
         * @interface IMachineVerifyQuery
         */

        /**
         * Constructs a new MachineVerifyQuery.
         * @memberof casper
         * @classdesc Represents a MachineVerifyQuery.
         * @implements IMachineVerifyQuery
         * @constructor
         * @param {casper.IMachineVerifyQuery=} [properties] Properties to set
         */
        function MachineVerifyQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MachineVerifyQuery instance using the specified properties.
         * @function create
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {casper.IMachineVerifyQuery=} [properties] Properties to set
         * @returns {casper.MachineVerifyQuery} MachineVerifyQuery instance
         */
        MachineVerifyQuery.create = function create(properties) {
            return new MachineVerifyQuery(properties);
        };

        /**
         * Encodes the specified MachineVerifyQuery message. Does not implicitly {@link casper.MachineVerifyQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {casper.IMachineVerifyQuery} message MachineVerifyQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MachineVerifyQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MachineVerifyQuery message, length delimited. Does not implicitly {@link casper.MachineVerifyQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {casper.IMachineVerifyQuery} message MachineVerifyQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MachineVerifyQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MachineVerifyQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.MachineVerifyQuery} MachineVerifyQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MachineVerifyQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.MachineVerifyQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MachineVerifyQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.MachineVerifyQuery} MachineVerifyQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MachineVerifyQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MachineVerifyQuery message.
         * @function verify
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MachineVerifyQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MachineVerifyQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.MachineVerifyQuery} MachineVerifyQuery
         */
        MachineVerifyQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.MachineVerifyQuery)
                return object;
            return new $root.casper.MachineVerifyQuery();
        };

        /**
         * Creates a plain object from a MachineVerifyQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.MachineVerifyQuery
         * @static
         * @param {casper.MachineVerifyQuery} message MachineVerifyQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MachineVerifyQuery.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MachineVerifyQuery to JSON.
         * @function toJSON
         * @memberof casper.MachineVerifyQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MachineVerifyQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MachineVerifyQuery;
    })();

    casper.PrivateNamePreviewQuery = (function() {

        /**
         * Properties of a PrivateNamePreviewQuery.
         * @memberof casper
         * @interface IPrivateNamePreviewQuery
         * @property {Uint8Array|null} [user] PrivateNamePreviewQuery user
         * @property {number|Long|null} [timestamp] PrivateNamePreviewQuery timestamp
         * @property {number|null} [nameQty] PrivateNamePreviewQuery nameQty
         */

        /**
         * Constructs a new PrivateNamePreviewQuery.
         * @memberof casper
         * @classdesc Represents a PrivateNamePreviewQuery.
         * @implements IPrivateNamePreviewQuery
         * @constructor
         * @param {casper.IPrivateNamePreviewQuery=} [properties] Properties to set
         */
        function PrivateNamePreviewQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateNamePreviewQuery user.
         * @member {Uint8Array} user
         * @memberof casper.PrivateNamePreviewQuery
         * @instance
         */
        PrivateNamePreviewQuery.prototype.user = $util.newBuffer([]);

        /**
         * PrivateNamePreviewQuery timestamp.
         * @member {number|Long} timestamp
         * @memberof casper.PrivateNamePreviewQuery
         * @instance
         */
        PrivateNamePreviewQuery.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PrivateNamePreviewQuery nameQty.
         * @member {number} nameQty
         * @memberof casper.PrivateNamePreviewQuery
         * @instance
         */
        PrivateNamePreviewQuery.prototype.nameQty = 0;

        /**
         * Creates a new PrivateNamePreviewQuery instance using the specified properties.
         * @function create
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {casper.IPrivateNamePreviewQuery=} [properties] Properties to set
         * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery instance
         */
        PrivateNamePreviewQuery.create = function create(properties) {
            return new PrivateNamePreviewQuery(properties);
        };

        /**
         * Encodes the specified PrivateNamePreviewQuery message. Does not implicitly {@link casper.PrivateNamePreviewQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {casper.IPrivateNamePreviewQuery} message PrivateNamePreviewQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateNamePreviewQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.user != null && message.hasOwnProperty("user"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
            if (message.nameQty != null && message.hasOwnProperty("nameQty"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nameQty);
            return writer;
        };

        /**
         * Encodes the specified PrivateNamePreviewQuery message, length delimited. Does not implicitly {@link casper.PrivateNamePreviewQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {casper.IPrivateNamePreviewQuery} message PrivateNamePreviewQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateNamePreviewQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateNamePreviewQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateNamePreviewQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.PrivateNamePreviewQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = reader.bytes();
                    break;
                case 2:
                    message.timestamp = reader.int64();
                    break;
                case 3:
                    message.nameQty = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateNamePreviewQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateNamePreviewQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateNamePreviewQuery message.
         * @function verify
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateNamePreviewQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                    return "user: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.nameQty != null && message.hasOwnProperty("nameQty"))
                if (!$util.isInteger(message.nameQty))
                    return "nameQty: integer expected";
            return null;
        };

        /**
         * Creates a PrivateNamePreviewQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery
         */
        PrivateNamePreviewQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.PrivateNamePreviewQuery)
                return object;
            var message = new $root.casper.PrivateNamePreviewQuery();
            if (object.user != null)
                if (typeof object.user === "string")
                    $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                else if (object.user.length)
                    message.user = object.user;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.nameQty != null)
                message.nameQty = object.nameQty | 0;
            return message;
        };

        /**
         * Creates a plain object from a PrivateNamePreviewQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.PrivateNamePreviewQuery
         * @static
         * @param {casper.PrivateNamePreviewQuery} message PrivateNamePreviewQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateNamePreviewQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.user = "";
                else {
                    object.user = [];
                    if (options.bytes !== Array)
                        object.user = $util.newBuffer(object.user);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.nameQty = 0;
            }
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.nameQty != null && message.hasOwnProperty("nameQty"))
                object.nameQty = message.nameQty;
            return object;
        };

        /**
         * Converts this PrivateNamePreviewQuery to JSON.
         * @function toJSON
         * @memberof casper.PrivateNamePreviewQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateNamePreviewQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrivateNamePreviewQuery;
    })();

    casper.LastFinalizedBlockQuery = (function() {

        /**
         * Properties of a LastFinalizedBlockQuery.
         * @memberof casper
         * @interface ILastFinalizedBlockQuery
         */

        /**
         * Constructs a new LastFinalizedBlockQuery.
         * @memberof casper
         * @classdesc Represents a LastFinalizedBlockQuery.
         * @implements ILastFinalizedBlockQuery
         * @constructor
         * @param {casper.ILastFinalizedBlockQuery=} [properties] Properties to set
         */
        function LastFinalizedBlockQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LastFinalizedBlockQuery instance using the specified properties.
         * @function create
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {casper.ILastFinalizedBlockQuery=} [properties] Properties to set
         * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery instance
         */
        LastFinalizedBlockQuery.create = function create(properties) {
            return new LastFinalizedBlockQuery(properties);
        };

        /**
         * Encodes the specified LastFinalizedBlockQuery message. Does not implicitly {@link casper.LastFinalizedBlockQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {casper.ILastFinalizedBlockQuery} message LastFinalizedBlockQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastFinalizedBlockQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LastFinalizedBlockQuery message, length delimited. Does not implicitly {@link casper.LastFinalizedBlockQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {casper.ILastFinalizedBlockQuery} message LastFinalizedBlockQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastFinalizedBlockQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastFinalizedBlockQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastFinalizedBlockQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.LastFinalizedBlockQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LastFinalizedBlockQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastFinalizedBlockQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastFinalizedBlockQuery message.
         * @function verify
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastFinalizedBlockQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a LastFinalizedBlockQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery
         */
        LastFinalizedBlockQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.LastFinalizedBlockQuery)
                return object;
            return new $root.casper.LastFinalizedBlockQuery();
        };

        /**
         * Creates a plain object from a LastFinalizedBlockQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.LastFinalizedBlockQuery
         * @static
         * @param {casper.LastFinalizedBlockQuery} message LastFinalizedBlockQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastFinalizedBlockQuery.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LastFinalizedBlockQuery to JSON.
         * @function toJSON
         * @memberof casper.LastFinalizedBlockQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastFinalizedBlockQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LastFinalizedBlockQuery;
    })();

    casper.IsFinalizedQuery = (function() {

        /**
         * Properties of an IsFinalizedQuery.
         * @memberof casper
         * @interface IIsFinalizedQuery
         * @property {string|null} [hash] IsFinalizedQuery hash
         */

        /**
         * Constructs a new IsFinalizedQuery.
         * @memberof casper
         * @classdesc Represents an IsFinalizedQuery.
         * @implements IIsFinalizedQuery
         * @constructor
         * @param {casper.IIsFinalizedQuery=} [properties] Properties to set
         */
        function IsFinalizedQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IsFinalizedQuery hash.
         * @member {string} hash
         * @memberof casper.IsFinalizedQuery
         * @instance
         */
        IsFinalizedQuery.prototype.hash = "";

        /**
         * Creates a new IsFinalizedQuery instance using the specified properties.
         * @function create
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {casper.IIsFinalizedQuery=} [properties] Properties to set
         * @returns {casper.IsFinalizedQuery} IsFinalizedQuery instance
         */
        IsFinalizedQuery.create = function create(properties) {
            return new IsFinalizedQuery(properties);
        };

        /**
         * Encodes the specified IsFinalizedQuery message. Does not implicitly {@link casper.IsFinalizedQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {casper.IIsFinalizedQuery} message IsFinalizedQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IsFinalizedQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            return writer;
        };

        /**
         * Encodes the specified IsFinalizedQuery message, length delimited. Does not implicitly {@link casper.IsFinalizedQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {casper.IIsFinalizedQuery} message IsFinalizedQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IsFinalizedQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IsFinalizedQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.IsFinalizedQuery} IsFinalizedQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IsFinalizedQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.IsFinalizedQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IsFinalizedQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.IsFinalizedQuery} IsFinalizedQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IsFinalizedQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IsFinalizedQuery message.
         * @function verify
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IsFinalizedQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            return null;
        };

        /**
         * Creates an IsFinalizedQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.IsFinalizedQuery} IsFinalizedQuery
         */
        IsFinalizedQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.IsFinalizedQuery)
                return object;
            var message = new $root.casper.IsFinalizedQuery();
            if (object.hash != null)
                message.hash = String(object.hash);
            return message;
        };

        /**
         * Creates a plain object from an IsFinalizedQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.IsFinalizedQuery
         * @static
         * @param {casper.IsFinalizedQuery} message IsFinalizedQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IsFinalizedQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hash = "";
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            return object;
        };

        /**
         * Converts this IsFinalizedQuery to JSON.
         * @function toJSON
         * @memberof casper.IsFinalizedQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IsFinalizedQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IsFinalizedQuery;
    })();

    casper.LightBlockInfo = (function() {

        /**
         * Properties of a LightBlockInfo.
         * @memberof casper
         * @interface ILightBlockInfo
         * @property {string|null} [blockHash] LightBlockInfo blockHash
         * @property {string|null} [blockSize] LightBlockInfo blockSize
         * @property {number|Long|null} [blockNumber] LightBlockInfo blockNumber
         * @property {number|Long|null} [version] LightBlockInfo version
         * @property {number|null} [deployCount] LightBlockInfo deployCount
         * @property {string|null} [tupleSpaceHash] LightBlockInfo tupleSpaceHash
         * @property {number|Long|null} [timestamp] LightBlockInfo timestamp
         * @property {number|null} [faultTolerance] LightBlockInfo faultTolerance
         * @property {string|null} [mainParentHash] LightBlockInfo mainParentHash
         * @property {Array.<string>|null} [parentsHashList] LightBlockInfo parentsHashList
         * @property {string|null} [sender] LightBlockInfo sender
         */

        /**
         * Constructs a new LightBlockInfo.
         * @memberof casper
         * @classdesc Represents a LightBlockInfo.
         * @implements ILightBlockInfo
         * @constructor
         * @param {casper.ILightBlockInfo=} [properties] Properties to set
         */
        function LightBlockInfo(properties) {
            this.parentsHashList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightBlockInfo blockHash.
         * @member {string} blockHash
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.blockHash = "";

        /**
         * LightBlockInfo blockSize.
         * @member {string} blockSize
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.blockSize = "";

        /**
         * LightBlockInfo blockNumber.
         * @member {number|Long} blockNumber
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LightBlockInfo version.
         * @member {number|Long} version
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LightBlockInfo deployCount.
         * @member {number} deployCount
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.deployCount = 0;

        /**
         * LightBlockInfo tupleSpaceHash.
         * @member {string} tupleSpaceHash
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.tupleSpaceHash = "";

        /**
         * LightBlockInfo timestamp.
         * @member {number|Long} timestamp
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LightBlockInfo faultTolerance.
         * @member {number} faultTolerance
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.faultTolerance = 0;

        /**
         * LightBlockInfo mainParentHash.
         * @member {string} mainParentHash
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.mainParentHash = "";

        /**
         * LightBlockInfo parentsHashList.
         * @member {Array.<string>} parentsHashList
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.parentsHashList = $util.emptyArray;

        /**
         * LightBlockInfo sender.
         * @member {string} sender
         * @memberof casper.LightBlockInfo
         * @instance
         */
        LightBlockInfo.prototype.sender = "";

        /**
         * Creates a new LightBlockInfo instance using the specified properties.
         * @function create
         * @memberof casper.LightBlockInfo
         * @static
         * @param {casper.ILightBlockInfo=} [properties] Properties to set
         * @returns {casper.LightBlockInfo} LightBlockInfo instance
         */
        LightBlockInfo.create = function create(properties) {
            return new LightBlockInfo(properties);
        };

        /**
         * Encodes the specified LightBlockInfo message. Does not implicitly {@link casper.LightBlockInfo.verify|verify} messages.
         * @function encode
         * @memberof casper.LightBlockInfo
         * @static
         * @param {casper.ILightBlockInfo} message LightBlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightBlockInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockHash);
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockSize);
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.blockNumber);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.version);
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deployCount);
            if (message.tupleSpaceHash != null && message.hasOwnProperty("tupleSpaceHash"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tupleSpaceHash);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.faultTolerance);
            if (message.mainParentHash != null && message.hasOwnProperty("mainParentHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.mainParentHash);
            if (message.parentsHashList != null && message.parentsHashList.length)
                for (var i = 0; i < message.parentsHashList.length; ++i)
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.parentsHashList[i]);
            if (message.sender != null && message.hasOwnProperty("sender"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.sender);
            return writer;
        };

        /**
         * Encodes the specified LightBlockInfo message, length delimited. Does not implicitly {@link casper.LightBlockInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.LightBlockInfo
         * @static
         * @param {casper.ILightBlockInfo} message LightBlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightBlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightBlockInfo message from the specified reader or buffer.
         * @function decode
         * @memberof casper.LightBlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.LightBlockInfo} LightBlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightBlockInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.LightBlockInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockHash = reader.string();
                    break;
                case 2:
                    message.blockSize = reader.string();
                    break;
                case 3:
                    message.blockNumber = reader.int64();
                    break;
                case 4:
                    message.version = reader.int64();
                    break;
                case 5:
                    message.deployCount = reader.int32();
                    break;
                case 6:
                    message.tupleSpaceHash = reader.string();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.faultTolerance = reader.float();
                    break;
                case 9:
                    message.mainParentHash = reader.string();
                    break;
                case 10:
                    if (!(message.parentsHashList && message.parentsHashList.length))
                        message.parentsHashList = [];
                    message.parentsHashList.push(reader.string());
                    break;
                case 11:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightBlockInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.LightBlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.LightBlockInfo} LightBlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightBlockInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightBlockInfo message.
         * @function verify
         * @memberof casper.LightBlockInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightBlockInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                if (!$util.isString(message.blockSize))
                    return "blockSize: string expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                    return "version: integer|Long expected";
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                if (!$util.isInteger(message.deployCount))
                    return "deployCount: integer expected";
            if (message.tupleSpaceHash != null && message.hasOwnProperty("tupleSpaceHash"))
                if (!$util.isString(message.tupleSpaceHash))
                    return "tupleSpaceHash: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                if (typeof message.faultTolerance !== "number")
                    return "faultTolerance: number expected";
            if (message.mainParentHash != null && message.hasOwnProperty("mainParentHash"))
                if (!$util.isString(message.mainParentHash))
                    return "mainParentHash: string expected";
            if (message.parentsHashList != null && message.hasOwnProperty("parentsHashList")) {
                if (!Array.isArray(message.parentsHashList))
                    return "parentsHashList: array expected";
                for (var i = 0; i < message.parentsHashList.length; ++i)
                    if (!$util.isString(message.parentsHashList[i]))
                        return "parentsHashList: string[] expected";
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!$util.isString(message.sender))
                    return "sender: string expected";
            return null;
        };

        /**
         * Creates a LightBlockInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.LightBlockInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.LightBlockInfo} LightBlockInfo
         */
        LightBlockInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.LightBlockInfo)
                return object;
            var message = new $root.casper.LightBlockInfo();
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.blockSize != null)
                message.blockSize = String(object.blockSize);
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            if (object.deployCount != null)
                message.deployCount = object.deployCount | 0;
            if (object.tupleSpaceHash != null)
                message.tupleSpaceHash = String(object.tupleSpaceHash);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.faultTolerance != null)
                message.faultTolerance = Number(object.faultTolerance);
            if (object.mainParentHash != null)
                message.mainParentHash = String(object.mainParentHash);
            if (object.parentsHashList) {
                if (!Array.isArray(object.parentsHashList))
                    throw TypeError(".casper.LightBlockInfo.parentsHashList: array expected");
                message.parentsHashList = [];
                for (var i = 0; i < object.parentsHashList.length; ++i)
                    message.parentsHashList[i] = String(object.parentsHashList[i]);
            }
            if (object.sender != null)
                message.sender = String(object.sender);
            return message;
        };

        /**
         * Creates a plain object from a LightBlockInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.LightBlockInfo
         * @static
         * @param {casper.LightBlockInfo} message LightBlockInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightBlockInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.parentsHashList = [];
            if (options.defaults) {
                object.blockHash = "";
                object.blockSize = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
                object.deployCount = 0;
                object.tupleSpaceHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.faultTolerance = 0;
                object.mainParentHash = "";
                object.sender = "";
            }
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                object.blockSize = message.blockSize;
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                object.deployCount = message.deployCount;
            if (message.tupleSpaceHash != null && message.hasOwnProperty("tupleSpaceHash"))
                object.tupleSpaceHash = message.tupleSpaceHash;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                object.faultTolerance = options.json && !isFinite(message.faultTolerance) ? String(message.faultTolerance) : message.faultTolerance;
            if (message.mainParentHash != null && message.hasOwnProperty("mainParentHash"))
                object.mainParentHash = message.mainParentHash;
            if (message.parentsHashList && message.parentsHashList.length) {
                object.parentsHashList = [];
                for (var j = 0; j < message.parentsHashList.length; ++j)
                    object.parentsHashList[j] = message.parentsHashList[j];
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = message.sender;
            return object;
        };

        /**
         * Converts this LightBlockInfo to JSON.
         * @function toJSON
         * @memberof casper.LightBlockInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightBlockInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightBlockInfo;
    })();

    casper.BlockInfo = (function() {

        /**
         * Properties of a BlockInfo.
         * @memberof casper
         * @interface IBlockInfo
         * @property {string|null} [blockHash] BlockInfo blockHash
         * @property {string|null} [blockSize] BlockInfo blockSize
         * @property {number|Long|null} [blockNumber] BlockInfo blockNumber
         * @property {number|Long|null} [version] BlockInfo version
         * @property {number|null} [deployCount] BlockInfo deployCount
         * @property {string|null} [tupleSpaceHash] BlockInfo tupleSpaceHash
         * @property {number|Long|null} [timestamp] BlockInfo timestamp
         * @property {number|null} [faultTolerance] BlockInfo faultTolerance
         * @property {string|null} [mainParentHash] BlockInfo mainParentHash
         * @property {Array.<string>|null} [parentsHashList] BlockInfo parentsHashList
         * @property {string|null} [sender] BlockInfo sender
         * @property {string|null} [shardId] BlockInfo shardId
         * @property {Array.<string>|null} [bondsValidatorList] BlockInfo bondsValidatorList
         * @property {Array.<string>|null} [deployCost] BlockInfo deployCost
         */

        /**
         * Constructs a new BlockInfo.
         * @memberof casper
         * @classdesc Represents a BlockInfo.
         * @implements IBlockInfo
         * @constructor
         * @param {casper.IBlockInfo=} [properties] Properties to set
         */
        function BlockInfo(properties) {
            this.parentsHashList = [];
            this.bondsValidatorList = [];
            this.deployCost = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockInfo blockHash.
         * @member {string} blockHash
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.blockHash = "";

        /**
         * BlockInfo blockSize.
         * @member {string} blockSize
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.blockSize = "";

        /**
         * BlockInfo blockNumber.
         * @member {number|Long} blockNumber
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockInfo version.
         * @member {number|Long} version
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockInfo deployCount.
         * @member {number} deployCount
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.deployCount = 0;

        /**
         * BlockInfo tupleSpaceHash.
         * @member {string} tupleSpaceHash
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.tupleSpaceHash = "";

        /**
         * BlockInfo timestamp.
         * @member {number|Long} timestamp
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockInfo faultTolerance.
         * @member {number} faultTolerance
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.faultTolerance = 0;

        /**
         * BlockInfo mainParentHash.
         * @member {string} mainParentHash
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.mainParentHash = "";

        /**
         * BlockInfo parentsHashList.
         * @member {Array.<string>} parentsHashList
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.parentsHashList = $util.emptyArray;

        /**
         * BlockInfo sender.
         * @member {string} sender
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.sender = "";

        /**
         * BlockInfo shardId.
         * @member {string} shardId
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.shardId = "";

        /**
         * BlockInfo bondsValidatorList.
         * @member {Array.<string>} bondsValidatorList
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.bondsValidatorList = $util.emptyArray;

        /**
         * BlockInfo deployCost.
         * @member {Array.<string>} deployCost
         * @memberof casper.BlockInfo
         * @instance
         */
        BlockInfo.prototype.deployCost = $util.emptyArray;

        /**
         * Creates a new BlockInfo instance using the specified properties.
         * @function create
         * @memberof casper.BlockInfo
         * @static
         * @param {casper.IBlockInfo=} [properties] Properties to set
         * @returns {casper.BlockInfo} BlockInfo instance
         */
        BlockInfo.create = function create(properties) {
            return new BlockInfo(properties);
        };

        /**
         * Encodes the specified BlockInfo message. Does not implicitly {@link casper.BlockInfo.verify|verify} messages.
         * @function encode
         * @memberof casper.BlockInfo
         * @static
         * @param {casper.IBlockInfo} message BlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockHash);
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockSize);
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.blockNumber);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.version);
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deployCount);
            if (message.tupleSpaceHash != null && message.hasOwnProperty("tupleSpaceHash"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tupleSpaceHash);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.faultTolerance);
            if (message.mainParentHash != null && message.hasOwnProperty("mainParentHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.mainParentHash);
            if (message.parentsHashList != null && message.parentsHashList.length)
                for (var i = 0; i < message.parentsHashList.length; ++i)
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.parentsHashList[i]);
            if (message.sender != null && message.hasOwnProperty("sender"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.sender);
            if (message.shardId != null && message.hasOwnProperty("shardId"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.shardId);
            if (message.bondsValidatorList != null && message.bondsValidatorList.length)
                for (var i = 0; i < message.bondsValidatorList.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.bondsValidatorList[i]);
            if (message.deployCost != null && message.deployCost.length)
                for (var i = 0; i < message.deployCost.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.deployCost[i]);
            return writer;
        };

        /**
         * Encodes the specified BlockInfo message, length delimited. Does not implicitly {@link casper.BlockInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.BlockInfo
         * @static
         * @param {casper.IBlockInfo} message BlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockInfo message from the specified reader or buffer.
         * @function decode
         * @memberof casper.BlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.BlockInfo} BlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockHash = reader.string();
                    break;
                case 2:
                    message.blockSize = reader.string();
                    break;
                case 3:
                    message.blockNumber = reader.int64();
                    break;
                case 4:
                    message.version = reader.int64();
                    break;
                case 5:
                    message.deployCount = reader.int32();
                    break;
                case 6:
                    message.tupleSpaceHash = reader.string();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.faultTolerance = reader.float();
                    break;
                case 9:
                    message.mainParentHash = reader.string();
                    break;
                case 10:
                    if (!(message.parentsHashList && message.parentsHashList.length))
                        message.parentsHashList = [];
                    message.parentsHashList.push(reader.string());
                    break;
                case 11:
                    message.sender = reader.string();
                    break;
                case 12:
                    message.shardId = reader.string();
                    break;
                case 13:
                    if (!(message.bondsValidatorList && message.bondsValidatorList.length))
                        message.bondsValidatorList = [];
                    message.bondsValidatorList.push(reader.string());
                    break;
                case 14:
                    if (!(message.deployCost && message.deployCost.length))
                        message.deployCost = [];
                    message.deployCost.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.BlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.BlockInfo} BlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockInfo message.
         * @function verify
         * @memberof casper.BlockInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                if (!$util.isString(message.blockSize))
                    return "blockSize: string expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                    return "version: integer|Long expected";
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                if (!$util.isInteger(message.deployCount))
                    return "deployCount: integer expected";
            if (message.tupleSpaceHash != null && message.hasOwnProperty("tupleSpaceHash"))
                if (!$util.isString(message.tupleSpaceHash))
                    return "tupleSpaceHash: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                if (typeof message.faultTolerance !== "number")
                    return "faultTolerance: number expected";
            if (message.mainParentHash != null && message.hasOwnProperty("mainParentHash"))
                if (!$util.isString(message.mainParentHash))
                    return "mainParentHash: string expected";
            if (message.parentsHashList != null && message.hasOwnProperty("parentsHashList")) {
                if (!Array.isArray(message.parentsHashList))
                    return "parentsHashList: array expected";
                for (var i = 0; i < message.parentsHashList.length; ++i)
                    if (!$util.isString(message.parentsHashList[i]))
                        return "parentsHashList: string[] expected";
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!$util.isString(message.sender))
                    return "sender: string expected";
            if (message.shardId != null && message.hasOwnProperty("shardId"))
                if (!$util.isString(message.shardId))
                    return "shardId: string expected";
            if (message.bondsValidatorList != null && message.hasOwnProperty("bondsValidatorList")) {
                if (!Array.isArray(message.bondsValidatorList))
                    return "bondsValidatorList: array expected";
                for (var i = 0; i < message.bondsValidatorList.length; ++i)
                    if (!$util.isString(message.bondsValidatorList[i]))
                        return "bondsValidatorList: string[] expected";
            }
            if (message.deployCost != null && message.hasOwnProperty("deployCost")) {
                if (!Array.isArray(message.deployCost))
                    return "deployCost: array expected";
                for (var i = 0; i < message.deployCost.length; ++i)
                    if (!$util.isString(message.deployCost[i]))
                        return "deployCost: string[] expected";
            }
            return null;
        };

        /**
         * Creates a BlockInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.BlockInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.BlockInfo} BlockInfo
         */
        BlockInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.BlockInfo)
                return object;
            var message = new $root.casper.BlockInfo();
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.blockSize != null)
                message.blockSize = String(object.blockSize);
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            if (object.deployCount != null)
                message.deployCount = object.deployCount | 0;
            if (object.tupleSpaceHash != null)
                message.tupleSpaceHash = String(object.tupleSpaceHash);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.faultTolerance != null)
                message.faultTolerance = Number(object.faultTolerance);
            if (object.mainParentHash != null)
                message.mainParentHash = String(object.mainParentHash);
            if (object.parentsHashList) {
                if (!Array.isArray(object.parentsHashList))
                    throw TypeError(".casper.BlockInfo.parentsHashList: array expected");
                message.parentsHashList = [];
                for (var i = 0; i < object.parentsHashList.length; ++i)
                    message.parentsHashList[i] = String(object.parentsHashList[i]);
            }
            if (object.sender != null)
                message.sender = String(object.sender);
            if (object.shardId != null)
                message.shardId = String(object.shardId);
            if (object.bondsValidatorList) {
                if (!Array.isArray(object.bondsValidatorList))
                    throw TypeError(".casper.BlockInfo.bondsValidatorList: array expected");
                message.bondsValidatorList = [];
                for (var i = 0; i < object.bondsValidatorList.length; ++i)
                    message.bondsValidatorList[i] = String(object.bondsValidatorList[i]);
            }
            if (object.deployCost) {
                if (!Array.isArray(object.deployCost))
                    throw TypeError(".casper.BlockInfo.deployCost: array expected");
                message.deployCost = [];
                for (var i = 0; i < object.deployCost.length; ++i)
                    message.deployCost[i] = String(object.deployCost[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.BlockInfo
         * @static
         * @param {casper.BlockInfo} message BlockInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.parentsHashList = [];
                object.bondsValidatorList = [];
                object.deployCost = [];
            }
            if (options.defaults) {
                object.blockHash = "";
                object.blockSize = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
                object.deployCount = 0;
                object.tupleSpaceHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.faultTolerance = 0;
                object.mainParentHash = "";
                object.sender = "";
                object.shardId = "";
            }
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                object.blockSize = message.blockSize;
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                object.deployCount = message.deployCount;
            if (message.tupleSpaceHash != null && message.hasOwnProperty("tupleSpaceHash"))
                object.tupleSpaceHash = message.tupleSpaceHash;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                object.faultTolerance = options.json && !isFinite(message.faultTolerance) ? String(message.faultTolerance) : message.faultTolerance;
            if (message.mainParentHash != null && message.hasOwnProperty("mainParentHash"))
                object.mainParentHash = message.mainParentHash;
            if (message.parentsHashList && message.parentsHashList.length) {
                object.parentsHashList = [];
                for (var j = 0; j < message.parentsHashList.length; ++j)
                    object.parentsHashList[j] = message.parentsHashList[j];
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = message.sender;
            if (message.shardId != null && message.hasOwnProperty("shardId"))
                object.shardId = message.shardId;
            if (message.bondsValidatorList && message.bondsValidatorList.length) {
                object.bondsValidatorList = [];
                for (var j = 0; j < message.bondsValidatorList.length; ++j)
                    object.bondsValidatorList[j] = message.bondsValidatorList[j];
            }
            if (message.deployCost && message.deployCost.length) {
                object.deployCost = [];
                for (var j = 0; j < message.deployCost.length; ++j)
                    object.deployCost[j] = message.deployCost[j];
            }
            return object;
        };

        /**
         * Converts this BlockInfo to JSON.
         * @function toJSON
         * @memberof casper.BlockInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockInfo;
    })();

    casper.DataWithBlockInfo = (function() {

        /**
         * Properties of a DataWithBlockInfo.
         * @memberof casper
         * @interface IDataWithBlockInfo
         * @property {Array.<IPar>|null} [postBlockData] DataWithBlockInfo postBlockData
         * @property {casper.ILightBlockInfo|null} [block] DataWithBlockInfo block
         */

        /**
         * Constructs a new DataWithBlockInfo.
         * @memberof casper
         * @classdesc Represents a DataWithBlockInfo.
         * @implements IDataWithBlockInfo
         * @constructor
         * @param {casper.IDataWithBlockInfo=} [properties] Properties to set
         */
        function DataWithBlockInfo(properties) {
            this.postBlockData = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataWithBlockInfo postBlockData.
         * @member {Array.<IPar>} postBlockData
         * @memberof casper.DataWithBlockInfo
         * @instance
         */
        DataWithBlockInfo.prototype.postBlockData = $util.emptyArray;

        /**
         * DataWithBlockInfo block.
         * @member {casper.ILightBlockInfo|null|undefined} block
         * @memberof casper.DataWithBlockInfo
         * @instance
         */
        DataWithBlockInfo.prototype.block = null;

        /**
         * Creates a new DataWithBlockInfo instance using the specified properties.
         * @function create
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {casper.IDataWithBlockInfo=} [properties] Properties to set
         * @returns {casper.DataWithBlockInfo} DataWithBlockInfo instance
         */
        DataWithBlockInfo.create = function create(properties) {
            return new DataWithBlockInfo(properties);
        };

        /**
         * Encodes the specified DataWithBlockInfo message. Does not implicitly {@link casper.DataWithBlockInfo.verify|verify} messages.
         * @function encode
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {casper.IDataWithBlockInfo} message DataWithBlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataWithBlockInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.postBlockData != null && message.postBlockData.length)
                for (var i = 0; i < message.postBlockData.length; ++i)
                    $root.Par.encode(message.postBlockData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.block != null && message.hasOwnProperty("block"))
                $root.casper.LightBlockInfo.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DataWithBlockInfo message, length delimited. Does not implicitly {@link casper.DataWithBlockInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {casper.IDataWithBlockInfo} message DataWithBlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataWithBlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataWithBlockInfo message from the specified reader or buffer.
         * @function decode
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.DataWithBlockInfo} DataWithBlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataWithBlockInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DataWithBlockInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.postBlockData && message.postBlockData.length))
                        message.postBlockData = [];
                    message.postBlockData.push($root.Par.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.block = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataWithBlockInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.DataWithBlockInfo} DataWithBlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataWithBlockInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataWithBlockInfo message.
         * @function verify
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataWithBlockInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.postBlockData != null && message.hasOwnProperty("postBlockData")) {
                if (!Array.isArray(message.postBlockData))
                    return "postBlockData: array expected";
                for (var i = 0; i < message.postBlockData.length; ++i) {
                    var error = $root.Par.verify(message.postBlockData[i]);
                    if (error)
                        return "postBlockData." + error;
                }
            }
            if (message.block != null && message.hasOwnProperty("block")) {
                var error = $root.casper.LightBlockInfo.verify(message.block);
                if (error)
                    return "block." + error;
            }
            return null;
        };

        /**
         * Creates a DataWithBlockInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.DataWithBlockInfo} DataWithBlockInfo
         */
        DataWithBlockInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.DataWithBlockInfo)
                return object;
            var message = new $root.casper.DataWithBlockInfo();
            if (object.postBlockData) {
                if (!Array.isArray(object.postBlockData))
                    throw TypeError(".casper.DataWithBlockInfo.postBlockData: array expected");
                message.postBlockData = [];
                for (var i = 0; i < object.postBlockData.length; ++i) {
                    if (typeof object.postBlockData[i] !== "object")
                        throw TypeError(".casper.DataWithBlockInfo.postBlockData: object expected");
                    message.postBlockData[i] = $root.Par.fromObject(object.postBlockData[i]);
                }
            }
            if (object.block != null) {
                if (typeof object.block !== "object")
                    throw TypeError(".casper.DataWithBlockInfo.block: object expected");
                message.block = $root.casper.LightBlockInfo.fromObject(object.block);
            }
            return message;
        };

        /**
         * Creates a plain object from a DataWithBlockInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.DataWithBlockInfo
         * @static
         * @param {casper.DataWithBlockInfo} message DataWithBlockInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataWithBlockInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.postBlockData = [];
            if (options.defaults)
                object.block = null;
            if (message.postBlockData && message.postBlockData.length) {
                object.postBlockData = [];
                for (var j = 0; j < message.postBlockData.length; ++j)
                    object.postBlockData[j] = $root.Par.toObject(message.postBlockData[j], options);
            }
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = $root.casper.LightBlockInfo.toObject(message.block, options);
            return object;
        };

        /**
         * Converts this DataWithBlockInfo to JSON.
         * @function toJSON
         * @memberof casper.DataWithBlockInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataWithBlockInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DataWithBlockInfo;
    })();

    casper.ContinuationsWithBlockInfo = (function() {

        /**
         * Properties of a ContinuationsWithBlockInfo.
         * @memberof casper
         * @interface IContinuationsWithBlockInfo
         * @property {Array.<casper.IWaitingContinuationInfo>|null} [postBlockContinuations] ContinuationsWithBlockInfo postBlockContinuations
         * @property {casper.ILightBlockInfo|null} [block] ContinuationsWithBlockInfo block
         */

        /**
         * Constructs a new ContinuationsWithBlockInfo.
         * @memberof casper
         * @classdesc Represents a ContinuationsWithBlockInfo.
         * @implements IContinuationsWithBlockInfo
         * @constructor
         * @param {casper.IContinuationsWithBlockInfo=} [properties] Properties to set
         */
        function ContinuationsWithBlockInfo(properties) {
            this.postBlockContinuations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContinuationsWithBlockInfo postBlockContinuations.
         * @member {Array.<casper.IWaitingContinuationInfo>} postBlockContinuations
         * @memberof casper.ContinuationsWithBlockInfo
         * @instance
         */
        ContinuationsWithBlockInfo.prototype.postBlockContinuations = $util.emptyArray;

        /**
         * ContinuationsWithBlockInfo block.
         * @member {casper.ILightBlockInfo|null|undefined} block
         * @memberof casper.ContinuationsWithBlockInfo
         * @instance
         */
        ContinuationsWithBlockInfo.prototype.block = null;

        /**
         * Creates a new ContinuationsWithBlockInfo instance using the specified properties.
         * @function create
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {casper.IContinuationsWithBlockInfo=} [properties] Properties to set
         * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo instance
         */
        ContinuationsWithBlockInfo.create = function create(properties) {
            return new ContinuationsWithBlockInfo(properties);
        };

        /**
         * Encodes the specified ContinuationsWithBlockInfo message. Does not implicitly {@link casper.ContinuationsWithBlockInfo.verify|verify} messages.
         * @function encode
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {casper.IContinuationsWithBlockInfo} message ContinuationsWithBlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuationsWithBlockInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.postBlockContinuations != null && message.postBlockContinuations.length)
                for (var i = 0; i < message.postBlockContinuations.length; ++i)
                    $root.casper.WaitingContinuationInfo.encode(message.postBlockContinuations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.block != null && message.hasOwnProperty("block"))
                $root.casper.LightBlockInfo.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContinuationsWithBlockInfo message, length delimited. Does not implicitly {@link casper.ContinuationsWithBlockInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {casper.IContinuationsWithBlockInfo} message ContinuationsWithBlockInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContinuationsWithBlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContinuationsWithBlockInfo message from the specified reader or buffer.
         * @function decode
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuationsWithBlockInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ContinuationsWithBlockInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.postBlockContinuations && message.postBlockContinuations.length))
                        message.postBlockContinuations = [];
                    message.postBlockContinuations.push($root.casper.WaitingContinuationInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.block = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContinuationsWithBlockInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContinuationsWithBlockInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContinuationsWithBlockInfo message.
         * @function verify
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContinuationsWithBlockInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.postBlockContinuations != null && message.hasOwnProperty("postBlockContinuations")) {
                if (!Array.isArray(message.postBlockContinuations))
                    return "postBlockContinuations: array expected";
                for (var i = 0; i < message.postBlockContinuations.length; ++i) {
                    var error = $root.casper.WaitingContinuationInfo.verify(message.postBlockContinuations[i]);
                    if (error)
                        return "postBlockContinuations." + error;
                }
            }
            if (message.block != null && message.hasOwnProperty("block")) {
                var error = $root.casper.LightBlockInfo.verify(message.block);
                if (error)
                    return "block." + error;
            }
            return null;
        };

        /**
         * Creates a ContinuationsWithBlockInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo
         */
        ContinuationsWithBlockInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.ContinuationsWithBlockInfo)
                return object;
            var message = new $root.casper.ContinuationsWithBlockInfo();
            if (object.postBlockContinuations) {
                if (!Array.isArray(object.postBlockContinuations))
                    throw TypeError(".casper.ContinuationsWithBlockInfo.postBlockContinuations: array expected");
                message.postBlockContinuations = [];
                for (var i = 0; i < object.postBlockContinuations.length; ++i) {
                    if (typeof object.postBlockContinuations[i] !== "object")
                        throw TypeError(".casper.ContinuationsWithBlockInfo.postBlockContinuations: object expected");
                    message.postBlockContinuations[i] = $root.casper.WaitingContinuationInfo.fromObject(object.postBlockContinuations[i]);
                }
            }
            if (object.block != null) {
                if (typeof object.block !== "object")
                    throw TypeError(".casper.ContinuationsWithBlockInfo.block: object expected");
                message.block = $root.casper.LightBlockInfo.fromObject(object.block);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContinuationsWithBlockInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.ContinuationsWithBlockInfo
         * @static
         * @param {casper.ContinuationsWithBlockInfo} message ContinuationsWithBlockInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContinuationsWithBlockInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.postBlockContinuations = [];
            if (options.defaults)
                object.block = null;
            if (message.postBlockContinuations && message.postBlockContinuations.length) {
                object.postBlockContinuations = [];
                for (var j = 0; j < message.postBlockContinuations.length; ++j)
                    object.postBlockContinuations[j] = $root.casper.WaitingContinuationInfo.toObject(message.postBlockContinuations[j], options);
            }
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = $root.casper.LightBlockInfo.toObject(message.block, options);
            return object;
        };

        /**
         * Converts this ContinuationsWithBlockInfo to JSON.
         * @function toJSON
         * @memberof casper.ContinuationsWithBlockInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContinuationsWithBlockInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContinuationsWithBlockInfo;
    })();

    casper.WaitingContinuationInfo = (function() {

        /**
         * Properties of a WaitingContinuationInfo.
         * @memberof casper
         * @interface IWaitingContinuationInfo
         * @property {Array.<IBindPattern>|null} [postBlockPatterns] WaitingContinuationInfo postBlockPatterns
         * @property {IPar|null} [postBlockContinuation] WaitingContinuationInfo postBlockContinuation
         */

        /**
         * Constructs a new WaitingContinuationInfo.
         * @memberof casper
         * @classdesc Represents a WaitingContinuationInfo.
         * @implements IWaitingContinuationInfo
         * @constructor
         * @param {casper.IWaitingContinuationInfo=} [properties] Properties to set
         */
        function WaitingContinuationInfo(properties) {
            this.postBlockPatterns = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WaitingContinuationInfo postBlockPatterns.
         * @member {Array.<IBindPattern>} postBlockPatterns
         * @memberof casper.WaitingContinuationInfo
         * @instance
         */
        WaitingContinuationInfo.prototype.postBlockPatterns = $util.emptyArray;

        /**
         * WaitingContinuationInfo postBlockContinuation.
         * @member {IPar|null|undefined} postBlockContinuation
         * @memberof casper.WaitingContinuationInfo
         * @instance
         */
        WaitingContinuationInfo.prototype.postBlockContinuation = null;

        /**
         * Creates a new WaitingContinuationInfo instance using the specified properties.
         * @function create
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {casper.IWaitingContinuationInfo=} [properties] Properties to set
         * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo instance
         */
        WaitingContinuationInfo.create = function create(properties) {
            return new WaitingContinuationInfo(properties);
        };

        /**
         * Encodes the specified WaitingContinuationInfo message. Does not implicitly {@link casper.WaitingContinuationInfo.verify|verify} messages.
         * @function encode
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {casper.IWaitingContinuationInfo} message WaitingContinuationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WaitingContinuationInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.postBlockPatterns != null && message.postBlockPatterns.length)
                for (var i = 0; i < message.postBlockPatterns.length; ++i)
                    $root.BindPattern.encode(message.postBlockPatterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.postBlockContinuation != null && message.hasOwnProperty("postBlockContinuation"))
                $root.Par.encode(message.postBlockContinuation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WaitingContinuationInfo message, length delimited. Does not implicitly {@link casper.WaitingContinuationInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {casper.IWaitingContinuationInfo} message WaitingContinuationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WaitingContinuationInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WaitingContinuationInfo message from the specified reader or buffer.
         * @function decode
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WaitingContinuationInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.WaitingContinuationInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.postBlockPatterns && message.postBlockPatterns.length))
                        message.postBlockPatterns = [];
                    message.postBlockPatterns.push($root.BindPattern.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.postBlockContinuation = $root.Par.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WaitingContinuationInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WaitingContinuationInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WaitingContinuationInfo message.
         * @function verify
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WaitingContinuationInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.postBlockPatterns != null && message.hasOwnProperty("postBlockPatterns")) {
                if (!Array.isArray(message.postBlockPatterns))
                    return "postBlockPatterns: array expected";
                for (var i = 0; i < message.postBlockPatterns.length; ++i) {
                    var error = $root.BindPattern.verify(message.postBlockPatterns[i]);
                    if (error)
                        return "postBlockPatterns." + error;
                }
            }
            if (message.postBlockContinuation != null && message.hasOwnProperty("postBlockContinuation")) {
                var error = $root.Par.verify(message.postBlockContinuation);
                if (error)
                    return "postBlockContinuation." + error;
            }
            return null;
        };

        /**
         * Creates a WaitingContinuationInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo
         */
        WaitingContinuationInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.WaitingContinuationInfo)
                return object;
            var message = new $root.casper.WaitingContinuationInfo();
            if (object.postBlockPatterns) {
                if (!Array.isArray(object.postBlockPatterns))
                    throw TypeError(".casper.WaitingContinuationInfo.postBlockPatterns: array expected");
                message.postBlockPatterns = [];
                for (var i = 0; i < object.postBlockPatterns.length; ++i) {
                    if (typeof object.postBlockPatterns[i] !== "object")
                        throw TypeError(".casper.WaitingContinuationInfo.postBlockPatterns: object expected");
                    message.postBlockPatterns[i] = $root.BindPattern.fromObject(object.postBlockPatterns[i]);
                }
            }
            if (object.postBlockContinuation != null) {
                if (typeof object.postBlockContinuation !== "object")
                    throw TypeError(".casper.WaitingContinuationInfo.postBlockContinuation: object expected");
                message.postBlockContinuation = $root.Par.fromObject(object.postBlockContinuation);
            }
            return message;
        };

        /**
         * Creates a plain object from a WaitingContinuationInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.WaitingContinuationInfo
         * @static
         * @param {casper.WaitingContinuationInfo} message WaitingContinuationInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WaitingContinuationInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.postBlockPatterns = [];
            if (options.defaults)
                object.postBlockContinuation = null;
            if (message.postBlockPatterns && message.postBlockPatterns.length) {
                object.postBlockPatterns = [];
                for (var j = 0; j < message.postBlockPatterns.length; ++j)
                    object.postBlockPatterns[j] = $root.BindPattern.toObject(message.postBlockPatterns[j], options);
            }
            if (message.postBlockContinuation != null && message.hasOwnProperty("postBlockContinuation"))
                object.postBlockContinuation = $root.Par.toObject(message.postBlockContinuation, options);
            return object;
        };

        /**
         * Converts this WaitingContinuationInfo to JSON.
         * @function toJSON
         * @memberof casper.WaitingContinuationInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WaitingContinuationInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WaitingContinuationInfo;
    })();

    casper.v1 = (function() {

        /**
         * Namespace v1.
         * @memberof casper
         * @namespace
         */
        var v1 = {};

        v1.DeployService = (function() {

            /**
             * Constructs a new DeployService service.
             * @memberof casper.v1
             * @classdesc Represents a DeployService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DeployService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DeployService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DeployService;

            /**
             * Creates new DeployService service using the specified rpc implementation.
             * @function create
             * @memberof casper.v1.DeployService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DeployService} RPC service. Useful where requests and/or responses are streamed.
             */
            DeployService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link casper.v1.DeployService#doDeploy}.
             * @memberof casper.v1.DeployService
             * @typedef doDeployCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.DeployResponse} [response] DeployResponse
             */

            /**
             * Calls doDeploy.
             * @function doDeploy
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IDeployDataProto} request DeployDataProto message or plain object
             * @param {casper.v1.DeployService.doDeployCallback} callback Node-style callback called with the error, if any, and DeployResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.doDeploy = function doDeploy(request, callback) {
                return this.rpcCall(doDeploy, $root.casper.DeployDataProto, $root.casper.v1.DeployResponse, request, callback);
            }, "name", { value: "doDeploy" });

            /**
             * Calls doDeploy.
             * @function doDeploy
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IDeployDataProto} request DeployDataProto message or plain object
             * @returns {Promise<casper.v1.DeployResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#getBlock}.
             * @memberof casper.v1.DeployService
             * @typedef getBlockCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.BlockResponse} [response] BlockResponse
             */

            /**
             * Calls getBlock.
             * @function getBlock
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IBlockQuery} request BlockQuery message or plain object
             * @param {casper.v1.DeployService.getBlockCallback} callback Node-style callback called with the error, if any, and BlockResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.getBlock = function getBlock(request, callback) {
                return this.rpcCall(getBlock, $root.casper.BlockQuery, $root.casper.v1.BlockResponse, request, callback);
            }, "name", { value: "getBlock" });

            /**
             * Calls getBlock.
             * @function getBlock
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IBlockQuery} request BlockQuery message or plain object
             * @returns {Promise<casper.v1.BlockResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#visualizeDag}.
             * @memberof casper.v1.DeployService
             * @typedef visualizeDagCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.VisualizeBlocksResponse} [response] VisualizeBlocksResponse
             */

            /**
             * Calls visualizeDag.
             * @function visualizeDag
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IVisualizeDagQuery} request VisualizeDagQuery message or plain object
             * @param {casper.v1.DeployService.visualizeDagCallback} callback Node-style callback called with the error, if any, and VisualizeBlocksResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.visualizeDag = function visualizeDag(request, callback) {
                return this.rpcCall(visualizeDag, $root.casper.VisualizeDagQuery, $root.casper.v1.VisualizeBlocksResponse, request, callback);
            }, "name", { value: "visualizeDag" });

            /**
             * Calls visualizeDag.
             * @function visualizeDag
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IVisualizeDagQuery} request VisualizeDagQuery message or plain object
             * @returns {Promise<casper.v1.VisualizeBlocksResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#machineVerifiableDag}.
             * @memberof casper.v1.DeployService
             * @typedef machineVerifiableDagCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.MachineVerifyResponse} [response] MachineVerifyResponse
             */

            /**
             * Calls machineVerifiableDag.
             * @function machineVerifiableDag
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IMachineVerifyQuery} request MachineVerifyQuery message or plain object
             * @param {casper.v1.DeployService.machineVerifiableDagCallback} callback Node-style callback called with the error, if any, and MachineVerifyResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.machineVerifiableDag = function machineVerifiableDag(request, callback) {
                return this.rpcCall(machineVerifiableDag, $root.casper.MachineVerifyQuery, $root.casper.v1.MachineVerifyResponse, request, callback);
            }, "name", { value: "machineVerifiableDag" });

            /**
             * Calls machineVerifiableDag.
             * @function machineVerifiableDag
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IMachineVerifyQuery} request MachineVerifyQuery message or plain object
             * @returns {Promise<casper.v1.MachineVerifyResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#showMainChain}.
             * @memberof casper.v1.DeployService
             * @typedef showMainChainCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.BlockInfoResponse} [response] BlockInfoResponse
             */

            /**
             * Calls showMainChain.
             * @function showMainChain
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
             * @param {casper.v1.DeployService.showMainChainCallback} callback Node-style callback called with the error, if any, and BlockInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.showMainChain = function showMainChain(request, callback) {
                return this.rpcCall(showMainChain, $root.casper.BlocksQuery, $root.casper.v1.BlockInfoResponse, request, callback);
            }, "name", { value: "showMainChain" });

            /**
             * Calls showMainChain.
             * @function showMainChain
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
             * @returns {Promise<casper.v1.BlockInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#getBlocks}.
             * @memberof casper.v1.DeployService
             * @typedef getBlocksCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.BlockInfoResponse} [response] BlockInfoResponse
             */

            /**
             * Calls getBlocks.
             * @function getBlocks
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
             * @param {casper.v1.DeployService.getBlocksCallback} callback Node-style callback called with the error, if any, and BlockInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.getBlocks = function getBlocks(request, callback) {
                return this.rpcCall(getBlocks, $root.casper.BlocksQuery, $root.casper.v1.BlockInfoResponse, request, callback);
            }, "name", { value: "getBlocks" });

            /**
             * Calls getBlocks.
             * @function getBlocks
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
             * @returns {Promise<casper.v1.BlockInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#listenForDataAtName}.
             * @memberof casper.v1.DeployService
             * @typedef listenForDataAtNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.ListeningNameDataResponse} [response] ListeningNameDataResponse
             */

            /**
             * Calls listenForDataAtName.
             * @function listenForDataAtName
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IDataAtNameQuery} request DataAtNameQuery message or plain object
             * @param {casper.v1.DeployService.listenForDataAtNameCallback} callback Node-style callback called with the error, if any, and ListeningNameDataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.listenForDataAtName = function listenForDataAtName(request, callback) {
                return this.rpcCall(listenForDataAtName, $root.casper.DataAtNameQuery, $root.casper.v1.ListeningNameDataResponse, request, callback);
            }, "name", { value: "listenForDataAtName" });

            /**
             * Calls listenForDataAtName.
             * @function listenForDataAtName
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IDataAtNameQuery} request DataAtNameQuery message or plain object
             * @returns {Promise<casper.v1.ListeningNameDataResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#listenForContinuationAtName}.
             * @memberof casper.v1.DeployService
             * @typedef listenForContinuationAtNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.ContinuationAtNameResponse} [response] ContinuationAtNameResponse
             */

            /**
             * Calls listenForContinuationAtName.
             * @function listenForContinuationAtName
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IContinuationAtNameQuery} request ContinuationAtNameQuery message or plain object
             * @param {casper.v1.DeployService.listenForContinuationAtNameCallback} callback Node-style callback called with the error, if any, and ContinuationAtNameResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.listenForContinuationAtName = function listenForContinuationAtName(request, callback) {
                return this.rpcCall(listenForContinuationAtName, $root.casper.ContinuationAtNameQuery, $root.casper.v1.ContinuationAtNameResponse, request, callback);
            }, "name", { value: "listenForContinuationAtName" });

            /**
             * Calls listenForContinuationAtName.
             * @function listenForContinuationAtName
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IContinuationAtNameQuery} request ContinuationAtNameQuery message or plain object
             * @returns {Promise<casper.v1.ContinuationAtNameResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#findDeploy}.
             * @memberof casper.v1.DeployService
             * @typedef findDeployCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.FindDeployResponse} [response] FindDeployResponse
             */

            /**
             * Calls findDeploy.
             * @function findDeploy
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IFindDeployQuery} request FindDeployQuery message or plain object
             * @param {casper.v1.DeployService.findDeployCallback} callback Node-style callback called with the error, if any, and FindDeployResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.findDeploy = function findDeploy(request, callback) {
                return this.rpcCall(findDeploy, $root.casper.FindDeployQuery, $root.casper.v1.FindDeployResponse, request, callback);
            }, "name", { value: "findDeploy" });

            /**
             * Calls findDeploy.
             * @function findDeploy
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IFindDeployQuery} request FindDeployQuery message or plain object
             * @returns {Promise<casper.v1.FindDeployResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#previewPrivateNames}.
             * @memberof casper.v1.DeployService
             * @typedef previewPrivateNamesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.PrivateNamePreviewResponse} [response] PrivateNamePreviewResponse
             */

            /**
             * Calls previewPrivateNames.
             * @function previewPrivateNames
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IPrivateNamePreviewQuery} request PrivateNamePreviewQuery message or plain object
             * @param {casper.v1.DeployService.previewPrivateNamesCallback} callback Node-style callback called with the error, if any, and PrivateNamePreviewResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.previewPrivateNames = function previewPrivateNames(request, callback) {
                return this.rpcCall(previewPrivateNames, $root.casper.PrivateNamePreviewQuery, $root.casper.v1.PrivateNamePreviewResponse, request, callback);
            }, "name", { value: "previewPrivateNames" });

            /**
             * Calls previewPrivateNames.
             * @function previewPrivateNames
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IPrivateNamePreviewQuery} request PrivateNamePreviewQuery message or plain object
             * @returns {Promise<casper.v1.PrivateNamePreviewResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#lastFinalizedBlock}.
             * @memberof casper.v1.DeployService
             * @typedef lastFinalizedBlockCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.LastFinalizedBlockResponse} [response] LastFinalizedBlockResponse
             */

            /**
             * Calls lastFinalizedBlock.
             * @function lastFinalizedBlock
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.ILastFinalizedBlockQuery} request LastFinalizedBlockQuery message or plain object
             * @param {casper.v1.DeployService.lastFinalizedBlockCallback} callback Node-style callback called with the error, if any, and LastFinalizedBlockResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.lastFinalizedBlock = function lastFinalizedBlock(request, callback) {
                return this.rpcCall(lastFinalizedBlock, $root.casper.LastFinalizedBlockQuery, $root.casper.v1.LastFinalizedBlockResponse, request, callback);
            }, "name", { value: "lastFinalizedBlock" });

            /**
             * Calls lastFinalizedBlock.
             * @function lastFinalizedBlock
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.ILastFinalizedBlockQuery} request LastFinalizedBlockQuery message or plain object
             * @returns {Promise<casper.v1.LastFinalizedBlockResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link casper.v1.DeployService#isFinalized}.
             * @memberof casper.v1.DeployService
             * @typedef isFinalizedCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.IsFinalizedResponse} [response] IsFinalizedResponse
             */

            /**
             * Calls isFinalized.
             * @function isFinalized
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IIsFinalizedQuery} request IsFinalizedQuery message or plain object
             * @param {casper.v1.DeployService.isFinalizedCallback} callback Node-style callback called with the error, if any, and IsFinalizedResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeployService.prototype.isFinalized = function isFinalized(request, callback) {
                return this.rpcCall(isFinalized, $root.casper.IsFinalizedQuery, $root.casper.v1.IsFinalizedResponse, request, callback);
            }, "name", { value: "isFinalized" });

            /**
             * Calls isFinalized.
             * @function isFinalized
             * @memberof casper.v1.DeployService
             * @instance
             * @param {casper.IIsFinalizedQuery} request IsFinalizedQuery message or plain object
             * @returns {Promise<casper.v1.IsFinalizedResponse>} Promise
             * @variation 2
             */

            return DeployService;
        })();

        v1.DeployResponse = (function() {

            /**
             * Properties of a DeployResponse.
             * @memberof casper.v1
             * @interface IDeployResponse
             * @property {IServiceError|null} [error] DeployResponse error
             * @property {string|null} [result] DeployResponse result
             */

            /**
             * Constructs a new DeployResponse.
             * @memberof casper.v1
             * @classdesc Represents a DeployResponse.
             * @implements IDeployResponse
             * @constructor
             * @param {casper.v1.IDeployResponse=} [properties] Properties to set
             */
            function DeployResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeployResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.DeployResponse
             * @instance
             */
            DeployResponse.prototype.error = null;

            /**
             * DeployResponse result.
             * @member {string} result
             * @memberof casper.v1.DeployResponse
             * @instance
             */
            DeployResponse.prototype.result = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * DeployResponse message.
             * @member {"error"|"result"|undefined} message
             * @memberof casper.v1.DeployResponse
             * @instance
             */
            Object.defineProperty(DeployResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "result"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new DeployResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {casper.v1.IDeployResponse=} [properties] Properties to set
             * @returns {casper.v1.DeployResponse} DeployResponse instance
             */
            DeployResponse.create = function create(properties) {
                return new DeployResponse(properties);
            };

            /**
             * Encodes the specified DeployResponse message. Does not implicitly {@link casper.v1.DeployResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {casper.v1.IDeployResponse} message DeployResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeployResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.result != null && message.hasOwnProperty("result"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
                return writer;
            };

            /**
             * Encodes the specified DeployResponse message, length delimited. Does not implicitly {@link casper.v1.DeployResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {casper.v1.IDeployResponse} message DeployResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeployResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeployResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.DeployResponse} DeployResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeployResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.DeployResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.result = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeployResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.DeployResponse} DeployResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeployResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeployResponse message.
             * @function verify
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeployResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    if (!$util.isString(message.result))
                        return "result: string expected";
                }
                return null;
            };

            /**
             * Creates a DeployResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.DeployResponse} DeployResponse
             */
            DeployResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.DeployResponse)
                    return object;
                var message = new $root.casper.v1.DeployResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.DeployResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.result != null)
                    message.result = String(object.result);
                return message;
            };

            /**
             * Creates a plain object from a DeployResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.DeployResponse
             * @static
             * @param {casper.v1.DeployResponse} message DeployResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeployResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object.message = "result";
                }
                return object;
            };

            /**
             * Converts this DeployResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.DeployResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeployResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeployResponse;
        })();

        v1.BlockResponse = (function() {

            /**
             * Properties of a BlockResponse.
             * @memberof casper.v1
             * @interface IBlockResponse
             * @property {IServiceError|null} [error] BlockResponse error
             * @property {casper.IBlockInfo|null} [blockInfo] BlockResponse blockInfo
             */

            /**
             * Constructs a new BlockResponse.
             * @memberof casper.v1
             * @classdesc Represents a BlockResponse.
             * @implements IBlockResponse
             * @constructor
             * @param {casper.v1.IBlockResponse=} [properties] Properties to set
             */
            function BlockResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.BlockResponse
             * @instance
             */
            BlockResponse.prototype.error = null;

            /**
             * BlockResponse blockInfo.
             * @member {casper.IBlockInfo|null|undefined} blockInfo
             * @memberof casper.v1.BlockResponse
             * @instance
             */
            BlockResponse.prototype.blockInfo = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * BlockResponse message.
             * @member {"error"|"blockInfo"|undefined} message
             * @memberof casper.v1.BlockResponse
             * @instance
             */
            Object.defineProperty(BlockResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BlockResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {casper.v1.IBlockResponse=} [properties] Properties to set
             * @returns {casper.v1.BlockResponse} BlockResponse instance
             */
            BlockResponse.create = function create(properties) {
                return new BlockResponse(properties);
            };

            /**
             * Encodes the specified BlockResponse message. Does not implicitly {@link casper.v1.BlockResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {casper.v1.IBlockResponse} message BlockResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                    $root.casper.BlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BlockResponse message, length delimited. Does not implicitly {@link casper.v1.BlockResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {casper.v1.IBlockResponse} message BlockResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.BlockResponse} BlockResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.BlockResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.blockInfo = $root.casper.BlockInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.BlockResponse} BlockResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockResponse message.
             * @function verify
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.BlockInfo.verify(message.blockInfo);
                        if (error)
                            return "blockInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a BlockResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.BlockResponse} BlockResponse
             */
            BlockResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.BlockResponse)
                    return object;
                var message = new $root.casper.v1.BlockResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.BlockResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.blockInfo != null) {
                    if (typeof object.blockInfo !== "object")
                        throw TypeError(".casper.v1.BlockResponse.blockInfo: object expected");
                    message.blockInfo = $root.casper.BlockInfo.fromObject(object.blockInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a BlockResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.BlockResponse
             * @static
             * @param {casper.v1.BlockResponse} message BlockResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    object.blockInfo = $root.casper.BlockInfo.toObject(message.blockInfo, options);
                    if (options.oneofs)
                        object.message = "blockInfo";
                }
                return object;
            };

            /**
             * Converts this BlockResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.BlockResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockResponse;
        })();

        v1.VisualizeBlocksResponse = (function() {

            /**
             * Properties of a VisualizeBlocksResponse.
             * @memberof casper.v1
             * @interface IVisualizeBlocksResponse
             * @property {IServiceError|null} [error] VisualizeBlocksResponse error
             * @property {string|null} [content] VisualizeBlocksResponse content
             */

            /**
             * Constructs a new VisualizeBlocksResponse.
             * @memberof casper.v1
             * @classdesc Represents a VisualizeBlocksResponse.
             * @implements IVisualizeBlocksResponse
             * @constructor
             * @param {casper.v1.IVisualizeBlocksResponse=} [properties] Properties to set
             */
            function VisualizeBlocksResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VisualizeBlocksResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.VisualizeBlocksResponse
             * @instance
             */
            VisualizeBlocksResponse.prototype.error = null;

            /**
             * VisualizeBlocksResponse content.
             * @member {string} content
             * @memberof casper.v1.VisualizeBlocksResponse
             * @instance
             */
            VisualizeBlocksResponse.prototype.content = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * VisualizeBlocksResponse message.
             * @member {"error"|"content"|undefined} message
             * @memberof casper.v1.VisualizeBlocksResponse
             * @instance
             */
            Object.defineProperty(VisualizeBlocksResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "content"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VisualizeBlocksResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {casper.v1.IVisualizeBlocksResponse=} [properties] Properties to set
             * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse instance
             */
            VisualizeBlocksResponse.create = function create(properties) {
                return new VisualizeBlocksResponse(properties);
            };

            /**
             * Encodes the specified VisualizeBlocksResponse message. Does not implicitly {@link casper.v1.VisualizeBlocksResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {casper.v1.IVisualizeBlocksResponse} message VisualizeBlocksResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualizeBlocksResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.content != null && message.hasOwnProperty("content"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                return writer;
            };

            /**
             * Encodes the specified VisualizeBlocksResponse message, length delimited. Does not implicitly {@link casper.v1.VisualizeBlocksResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {casper.v1.IVisualizeBlocksResponse} message VisualizeBlocksResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualizeBlocksResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VisualizeBlocksResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualizeBlocksResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.VisualizeBlocksResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.content = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VisualizeBlocksResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualizeBlocksResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VisualizeBlocksResponse message.
             * @function verify
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VisualizeBlocksResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.content != null && message.hasOwnProperty("content")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    if (!$util.isString(message.content))
                        return "content: string expected";
                }
                return null;
            };

            /**
             * Creates a VisualizeBlocksResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse
             */
            VisualizeBlocksResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.VisualizeBlocksResponse)
                    return object;
                var message = new $root.casper.v1.VisualizeBlocksResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.VisualizeBlocksResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.content != null)
                    message.content = String(object.content);
                return message;
            };

            /**
             * Creates a plain object from a VisualizeBlocksResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.VisualizeBlocksResponse
             * @static
             * @param {casper.v1.VisualizeBlocksResponse} message VisualizeBlocksResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisualizeBlocksResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.content != null && message.hasOwnProperty("content")) {
                    object.content = message.content;
                    if (options.oneofs)
                        object.message = "content";
                }
                return object;
            };

            /**
             * Converts this VisualizeBlocksResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.VisualizeBlocksResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VisualizeBlocksResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VisualizeBlocksResponse;
        })();

        v1.MachineVerifyResponse = (function() {

            /**
             * Properties of a MachineVerifyResponse.
             * @memberof casper.v1
             * @interface IMachineVerifyResponse
             * @property {IServiceError|null} [error] MachineVerifyResponse error
             * @property {string|null} [content] MachineVerifyResponse content
             */

            /**
             * Constructs a new MachineVerifyResponse.
             * @memberof casper.v1
             * @classdesc Represents a MachineVerifyResponse.
             * @implements IMachineVerifyResponse
             * @constructor
             * @param {casper.v1.IMachineVerifyResponse=} [properties] Properties to set
             */
            function MachineVerifyResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MachineVerifyResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.MachineVerifyResponse
             * @instance
             */
            MachineVerifyResponse.prototype.error = null;

            /**
             * MachineVerifyResponse content.
             * @member {string} content
             * @memberof casper.v1.MachineVerifyResponse
             * @instance
             */
            MachineVerifyResponse.prototype.content = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * MachineVerifyResponse message.
             * @member {"error"|"content"|undefined} message
             * @memberof casper.v1.MachineVerifyResponse
             * @instance
             */
            Object.defineProperty(MachineVerifyResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "content"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MachineVerifyResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {casper.v1.IMachineVerifyResponse=} [properties] Properties to set
             * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse instance
             */
            MachineVerifyResponse.create = function create(properties) {
                return new MachineVerifyResponse(properties);
            };

            /**
             * Encodes the specified MachineVerifyResponse message. Does not implicitly {@link casper.v1.MachineVerifyResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {casper.v1.IMachineVerifyResponse} message MachineVerifyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MachineVerifyResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.content != null && message.hasOwnProperty("content"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                return writer;
            };

            /**
             * Encodes the specified MachineVerifyResponse message, length delimited. Does not implicitly {@link casper.v1.MachineVerifyResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {casper.v1.IMachineVerifyResponse} message MachineVerifyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MachineVerifyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MachineVerifyResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MachineVerifyResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.MachineVerifyResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.content = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MachineVerifyResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MachineVerifyResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MachineVerifyResponse message.
             * @function verify
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MachineVerifyResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.content != null && message.hasOwnProperty("content")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    if (!$util.isString(message.content))
                        return "content: string expected";
                }
                return null;
            };

            /**
             * Creates a MachineVerifyResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse
             */
            MachineVerifyResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.MachineVerifyResponse)
                    return object;
                var message = new $root.casper.v1.MachineVerifyResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.MachineVerifyResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.content != null)
                    message.content = String(object.content);
                return message;
            };

            /**
             * Creates a plain object from a MachineVerifyResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.MachineVerifyResponse
             * @static
             * @param {casper.v1.MachineVerifyResponse} message MachineVerifyResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MachineVerifyResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.content != null && message.hasOwnProperty("content")) {
                    object.content = message.content;
                    if (options.oneofs)
                        object.message = "content";
                }
                return object;
            };

            /**
             * Converts this MachineVerifyResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.MachineVerifyResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MachineVerifyResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MachineVerifyResponse;
        })();

        v1.BlockInfoResponse = (function() {

            /**
             * Properties of a BlockInfoResponse.
             * @memberof casper.v1
             * @interface IBlockInfoResponse
             * @property {IServiceError|null} [error] BlockInfoResponse error
             * @property {casper.ILightBlockInfo|null} [blockInfo] BlockInfoResponse blockInfo
             */

            /**
             * Constructs a new BlockInfoResponse.
             * @memberof casper.v1
             * @classdesc Represents a BlockInfoResponse.
             * @implements IBlockInfoResponse
             * @constructor
             * @param {casper.v1.IBlockInfoResponse=} [properties] Properties to set
             */
            function BlockInfoResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockInfoResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.BlockInfoResponse
             * @instance
             */
            BlockInfoResponse.prototype.error = null;

            /**
             * BlockInfoResponse blockInfo.
             * @member {casper.ILightBlockInfo|null|undefined} blockInfo
             * @memberof casper.v1.BlockInfoResponse
             * @instance
             */
            BlockInfoResponse.prototype.blockInfo = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * BlockInfoResponse message.
             * @member {"error"|"blockInfo"|undefined} message
             * @memberof casper.v1.BlockInfoResponse
             * @instance
             */
            Object.defineProperty(BlockInfoResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BlockInfoResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {casper.v1.IBlockInfoResponse=} [properties] Properties to set
             * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse instance
             */
            BlockInfoResponse.create = function create(properties) {
                return new BlockInfoResponse(properties);
            };

            /**
             * Encodes the specified BlockInfoResponse message. Does not implicitly {@link casper.v1.BlockInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {casper.v1.IBlockInfoResponse} message BlockInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                    $root.casper.LightBlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BlockInfoResponse message, length delimited. Does not implicitly {@link casper.v1.BlockInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {casper.v1.IBlockInfoResponse} message BlockInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.BlockInfoResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.blockInfo = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockInfoResponse message.
             * @function verify
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.LightBlockInfo.verify(message.blockInfo);
                        if (error)
                            return "blockInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a BlockInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse
             */
            BlockInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.BlockInfoResponse)
                    return object;
                var message = new $root.casper.v1.BlockInfoResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.BlockInfoResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.blockInfo != null) {
                    if (typeof object.blockInfo !== "object")
                        throw TypeError(".casper.v1.BlockInfoResponse.blockInfo: object expected");
                    message.blockInfo = $root.casper.LightBlockInfo.fromObject(object.blockInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a BlockInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.BlockInfoResponse
             * @static
             * @param {casper.v1.BlockInfoResponse} message BlockInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    object.blockInfo = $root.casper.LightBlockInfo.toObject(message.blockInfo, options);
                    if (options.oneofs)
                        object.message = "blockInfo";
                }
                return object;
            };

            /**
             * Converts this BlockInfoResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.BlockInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockInfoResponse;
        })();

        v1.ListeningNameDataResponse = (function() {

            /**
             * Properties of a ListeningNameDataResponse.
             * @memberof casper.v1
             * @interface IListeningNameDataResponse
             * @property {IServiceError|null} [error] ListeningNameDataResponse error
             * @property {casper.v1.IListeningNameDataPayload|null} [payload] ListeningNameDataResponse payload
             */

            /**
             * Constructs a new ListeningNameDataResponse.
             * @memberof casper.v1
             * @classdesc Represents a ListeningNameDataResponse.
             * @implements IListeningNameDataResponse
             * @constructor
             * @param {casper.v1.IListeningNameDataResponse=} [properties] Properties to set
             */
            function ListeningNameDataResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListeningNameDataResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.ListeningNameDataResponse
             * @instance
             */
            ListeningNameDataResponse.prototype.error = null;

            /**
             * ListeningNameDataResponse payload.
             * @member {casper.v1.IListeningNameDataPayload|null|undefined} payload
             * @memberof casper.v1.ListeningNameDataResponse
             * @instance
             */
            ListeningNameDataResponse.prototype.payload = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ListeningNameDataResponse message.
             * @member {"error"|"payload"|undefined} message
             * @memberof casper.v1.ListeningNameDataResponse
             * @instance
             */
            Object.defineProperty(ListeningNameDataResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "payload"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ListeningNameDataResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {casper.v1.IListeningNameDataResponse=} [properties] Properties to set
             * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse instance
             */
            ListeningNameDataResponse.create = function create(properties) {
                return new ListeningNameDataResponse(properties);
            };

            /**
             * Encodes the specified ListeningNameDataResponse message. Does not implicitly {@link casper.v1.ListeningNameDataResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {casper.v1.IListeningNameDataResponse} message ListeningNameDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListeningNameDataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    $root.casper.v1.ListeningNameDataPayload.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListeningNameDataResponse message, length delimited. Does not implicitly {@link casper.v1.ListeningNameDataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {casper.v1.IListeningNameDataResponse} message ListeningNameDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListeningNameDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListeningNameDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListeningNameDataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ListeningNameDataResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.payload = $root.casper.v1.ListeningNameDataPayload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListeningNameDataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListeningNameDataResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListeningNameDataResponse message.
             * @function verify
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListeningNameDataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.v1.ListeningNameDataPayload.verify(message.payload);
                        if (error)
                            return "payload." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListeningNameDataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse
             */
            ListeningNameDataResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.ListeningNameDataResponse)
                    return object;
                var message = new $root.casper.v1.ListeningNameDataResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.ListeningNameDataResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".casper.v1.ListeningNameDataResponse.payload: object expected");
                    message.payload = $root.casper.v1.ListeningNameDataPayload.fromObject(object.payload);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListeningNameDataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.ListeningNameDataResponse
             * @static
             * @param {casper.v1.ListeningNameDataResponse} message ListeningNameDataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListeningNameDataResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    object.payload = $root.casper.v1.ListeningNameDataPayload.toObject(message.payload, options);
                    if (options.oneofs)
                        object.message = "payload";
                }
                return object;
            };

            /**
             * Converts this ListeningNameDataResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.ListeningNameDataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListeningNameDataResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListeningNameDataResponse;
        })();

        v1.ListeningNameDataPayload = (function() {

            /**
             * Properties of a ListeningNameDataPayload.
             * @memberof casper.v1
             * @interface IListeningNameDataPayload
             * @property {Array.<casper.IDataWithBlockInfo>|null} [blockInfo] ListeningNameDataPayload blockInfo
             * @property {number|null} [length] ListeningNameDataPayload length
             */

            /**
             * Constructs a new ListeningNameDataPayload.
             * @memberof casper.v1
             * @classdesc Represents a ListeningNameDataPayload.
             * @implements IListeningNameDataPayload
             * @constructor
             * @param {casper.v1.IListeningNameDataPayload=} [properties] Properties to set
             */
            function ListeningNameDataPayload(properties) {
                this.blockInfo = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListeningNameDataPayload blockInfo.
             * @member {Array.<casper.IDataWithBlockInfo>} blockInfo
             * @memberof casper.v1.ListeningNameDataPayload
             * @instance
             */
            ListeningNameDataPayload.prototype.blockInfo = $util.emptyArray;

            /**
             * ListeningNameDataPayload length.
             * @member {number} length
             * @memberof casper.v1.ListeningNameDataPayload
             * @instance
             */
            ListeningNameDataPayload.prototype.length = 0;

            /**
             * Creates a new ListeningNameDataPayload instance using the specified properties.
             * @function create
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {casper.v1.IListeningNameDataPayload=} [properties] Properties to set
             * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload instance
             */
            ListeningNameDataPayload.create = function create(properties) {
                return new ListeningNameDataPayload(properties);
            };

            /**
             * Encodes the specified ListeningNameDataPayload message. Does not implicitly {@link casper.v1.ListeningNameDataPayload.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {casper.v1.IListeningNameDataPayload} message ListeningNameDataPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListeningNameDataPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blockInfo != null && message.blockInfo.length)
                    for (var i = 0; i < message.blockInfo.length; ++i)
                        $root.casper.DataWithBlockInfo.encode(message.blockInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.length != null && message.hasOwnProperty("length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.length);
                return writer;
            };

            /**
             * Encodes the specified ListeningNameDataPayload message, length delimited. Does not implicitly {@link casper.v1.ListeningNameDataPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {casper.v1.IListeningNameDataPayload} message ListeningNameDataPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListeningNameDataPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListeningNameDataPayload message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListeningNameDataPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ListeningNameDataPayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.blockInfo && message.blockInfo.length))
                            message.blockInfo = [];
                        message.blockInfo.push($root.casper.DataWithBlockInfo.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.length = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListeningNameDataPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListeningNameDataPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListeningNameDataPayload message.
             * @function verify
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListeningNameDataPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    if (!Array.isArray(message.blockInfo))
                        return "blockInfo: array expected";
                    for (var i = 0; i < message.blockInfo.length; ++i) {
                        var error = $root.casper.DataWithBlockInfo.verify(message.blockInfo[i]);
                        if (error)
                            return "blockInfo." + error;
                    }
                }
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                return null;
            };

            /**
             * Creates a ListeningNameDataPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload
             */
            ListeningNameDataPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.ListeningNameDataPayload)
                    return object;
                var message = new $root.casper.v1.ListeningNameDataPayload();
                if (object.blockInfo) {
                    if (!Array.isArray(object.blockInfo))
                        throw TypeError(".casper.v1.ListeningNameDataPayload.blockInfo: array expected");
                    message.blockInfo = [];
                    for (var i = 0; i < object.blockInfo.length; ++i) {
                        if (typeof object.blockInfo[i] !== "object")
                            throw TypeError(".casper.v1.ListeningNameDataPayload.blockInfo: object expected");
                        message.blockInfo[i] = $root.casper.DataWithBlockInfo.fromObject(object.blockInfo[i]);
                    }
                }
                if (object.length != null)
                    message.length = object.length | 0;
                return message;
            };

            /**
             * Creates a plain object from a ListeningNameDataPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.ListeningNameDataPayload
             * @static
             * @param {casper.v1.ListeningNameDataPayload} message ListeningNameDataPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListeningNameDataPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.blockInfo = [];
                if (options.defaults)
                    object.length = 0;
                if (message.blockInfo && message.blockInfo.length) {
                    object.blockInfo = [];
                    for (var j = 0; j < message.blockInfo.length; ++j)
                        object.blockInfo[j] = $root.casper.DataWithBlockInfo.toObject(message.blockInfo[j], options);
                }
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                return object;
            };

            /**
             * Converts this ListeningNameDataPayload to JSON.
             * @function toJSON
             * @memberof casper.v1.ListeningNameDataPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListeningNameDataPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListeningNameDataPayload;
        })();

        v1.ContinuationAtNameResponse = (function() {

            /**
             * Properties of a ContinuationAtNameResponse.
             * @memberof casper.v1
             * @interface IContinuationAtNameResponse
             * @property {IServiceError|null} [error] ContinuationAtNameResponse error
             * @property {casper.v1.IContinuationAtNamePayload|null} [payload] ContinuationAtNameResponse payload
             */

            /**
             * Constructs a new ContinuationAtNameResponse.
             * @memberof casper.v1
             * @classdesc Represents a ContinuationAtNameResponse.
             * @implements IContinuationAtNameResponse
             * @constructor
             * @param {casper.v1.IContinuationAtNameResponse=} [properties] Properties to set
             */
            function ContinuationAtNameResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContinuationAtNameResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.ContinuationAtNameResponse
             * @instance
             */
            ContinuationAtNameResponse.prototype.error = null;

            /**
             * ContinuationAtNameResponse payload.
             * @member {casper.v1.IContinuationAtNamePayload|null|undefined} payload
             * @memberof casper.v1.ContinuationAtNameResponse
             * @instance
             */
            ContinuationAtNameResponse.prototype.payload = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ContinuationAtNameResponse message.
             * @member {"error"|"payload"|undefined} message
             * @memberof casper.v1.ContinuationAtNameResponse
             * @instance
             */
            Object.defineProperty(ContinuationAtNameResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "payload"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ContinuationAtNameResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {casper.v1.IContinuationAtNameResponse=} [properties] Properties to set
             * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse instance
             */
            ContinuationAtNameResponse.create = function create(properties) {
                return new ContinuationAtNameResponse(properties);
            };

            /**
             * Encodes the specified ContinuationAtNameResponse message. Does not implicitly {@link casper.v1.ContinuationAtNameResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {casper.v1.IContinuationAtNameResponse} message ContinuationAtNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinuationAtNameResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    $root.casper.v1.ContinuationAtNamePayload.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ContinuationAtNameResponse message, length delimited. Does not implicitly {@link casper.v1.ContinuationAtNameResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {casper.v1.IContinuationAtNameResponse} message ContinuationAtNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinuationAtNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContinuationAtNameResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinuationAtNameResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ContinuationAtNameResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.payload = $root.casper.v1.ContinuationAtNamePayload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContinuationAtNameResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinuationAtNameResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContinuationAtNameResponse message.
             * @function verify
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContinuationAtNameResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.v1.ContinuationAtNamePayload.verify(message.payload);
                        if (error)
                            return "payload." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ContinuationAtNameResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse
             */
            ContinuationAtNameResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.ContinuationAtNameResponse)
                    return object;
                var message = new $root.casper.v1.ContinuationAtNameResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.ContinuationAtNameResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".casper.v1.ContinuationAtNameResponse.payload: object expected");
                    message.payload = $root.casper.v1.ContinuationAtNamePayload.fromObject(object.payload);
                }
                return message;
            };

            /**
             * Creates a plain object from a ContinuationAtNameResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.ContinuationAtNameResponse
             * @static
             * @param {casper.v1.ContinuationAtNameResponse} message ContinuationAtNameResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContinuationAtNameResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    object.payload = $root.casper.v1.ContinuationAtNamePayload.toObject(message.payload, options);
                    if (options.oneofs)
                        object.message = "payload";
                }
                return object;
            };

            /**
             * Converts this ContinuationAtNameResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.ContinuationAtNameResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContinuationAtNameResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ContinuationAtNameResponse;
        })();

        v1.ContinuationAtNamePayload = (function() {

            /**
             * Properties of a ContinuationAtNamePayload.
             * @memberof casper.v1
             * @interface IContinuationAtNamePayload
             * @property {Array.<casper.IContinuationsWithBlockInfo>|null} [blockResults] ContinuationAtNamePayload blockResults
             * @property {number|null} [length] ContinuationAtNamePayload length
             */

            /**
             * Constructs a new ContinuationAtNamePayload.
             * @memberof casper.v1
             * @classdesc Represents a ContinuationAtNamePayload.
             * @implements IContinuationAtNamePayload
             * @constructor
             * @param {casper.v1.IContinuationAtNamePayload=} [properties] Properties to set
             */
            function ContinuationAtNamePayload(properties) {
                this.blockResults = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContinuationAtNamePayload blockResults.
             * @member {Array.<casper.IContinuationsWithBlockInfo>} blockResults
             * @memberof casper.v1.ContinuationAtNamePayload
             * @instance
             */
            ContinuationAtNamePayload.prototype.blockResults = $util.emptyArray;

            /**
             * ContinuationAtNamePayload length.
             * @member {number} length
             * @memberof casper.v1.ContinuationAtNamePayload
             * @instance
             */
            ContinuationAtNamePayload.prototype.length = 0;

            /**
             * Creates a new ContinuationAtNamePayload instance using the specified properties.
             * @function create
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {casper.v1.IContinuationAtNamePayload=} [properties] Properties to set
             * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload instance
             */
            ContinuationAtNamePayload.create = function create(properties) {
                return new ContinuationAtNamePayload(properties);
            };

            /**
             * Encodes the specified ContinuationAtNamePayload message. Does not implicitly {@link casper.v1.ContinuationAtNamePayload.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {casper.v1.IContinuationAtNamePayload} message ContinuationAtNamePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinuationAtNamePayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blockResults != null && message.blockResults.length)
                    for (var i = 0; i < message.blockResults.length; ++i)
                        $root.casper.ContinuationsWithBlockInfo.encode(message.blockResults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.length != null && message.hasOwnProperty("length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.length);
                return writer;
            };

            /**
             * Encodes the specified ContinuationAtNamePayload message, length delimited. Does not implicitly {@link casper.v1.ContinuationAtNamePayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {casper.v1.IContinuationAtNamePayload} message ContinuationAtNamePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinuationAtNamePayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContinuationAtNamePayload message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinuationAtNamePayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ContinuationAtNamePayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.blockResults && message.blockResults.length))
                            message.blockResults = [];
                        message.blockResults.push($root.casper.ContinuationsWithBlockInfo.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.length = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContinuationAtNamePayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinuationAtNamePayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContinuationAtNamePayload message.
             * @function verify
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContinuationAtNamePayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blockResults != null && message.hasOwnProperty("blockResults")) {
                    if (!Array.isArray(message.blockResults))
                        return "blockResults: array expected";
                    for (var i = 0; i < message.blockResults.length; ++i) {
                        var error = $root.casper.ContinuationsWithBlockInfo.verify(message.blockResults[i]);
                        if (error)
                            return "blockResults." + error;
                    }
                }
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                return null;
            };

            /**
             * Creates a ContinuationAtNamePayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload
             */
            ContinuationAtNamePayload.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.ContinuationAtNamePayload)
                    return object;
                var message = new $root.casper.v1.ContinuationAtNamePayload();
                if (object.blockResults) {
                    if (!Array.isArray(object.blockResults))
                        throw TypeError(".casper.v1.ContinuationAtNamePayload.blockResults: array expected");
                    message.blockResults = [];
                    for (var i = 0; i < object.blockResults.length; ++i) {
                        if (typeof object.blockResults[i] !== "object")
                            throw TypeError(".casper.v1.ContinuationAtNamePayload.blockResults: object expected");
                        message.blockResults[i] = $root.casper.ContinuationsWithBlockInfo.fromObject(object.blockResults[i]);
                    }
                }
                if (object.length != null)
                    message.length = object.length | 0;
                return message;
            };

            /**
             * Creates a plain object from a ContinuationAtNamePayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.ContinuationAtNamePayload
             * @static
             * @param {casper.v1.ContinuationAtNamePayload} message ContinuationAtNamePayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContinuationAtNamePayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.blockResults = [];
                if (options.defaults)
                    object.length = 0;
                if (message.blockResults && message.blockResults.length) {
                    object.blockResults = [];
                    for (var j = 0; j < message.blockResults.length; ++j)
                        object.blockResults[j] = $root.casper.ContinuationsWithBlockInfo.toObject(message.blockResults[j], options);
                }
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                return object;
            };

            /**
             * Converts this ContinuationAtNamePayload to JSON.
             * @function toJSON
             * @memberof casper.v1.ContinuationAtNamePayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContinuationAtNamePayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ContinuationAtNamePayload;
        })();

        v1.FindDeployResponse = (function() {

            /**
             * Properties of a FindDeployResponse.
             * @memberof casper.v1
             * @interface IFindDeployResponse
             * @property {IServiceError|null} [error] FindDeployResponse error
             * @property {casper.ILightBlockInfo|null} [blockInfo] FindDeployResponse blockInfo
             */

            /**
             * Constructs a new FindDeployResponse.
             * @memberof casper.v1
             * @classdesc Represents a FindDeployResponse.
             * @implements IFindDeployResponse
             * @constructor
             * @param {casper.v1.IFindDeployResponse=} [properties] Properties to set
             */
            function FindDeployResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FindDeployResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.FindDeployResponse
             * @instance
             */
            FindDeployResponse.prototype.error = null;

            /**
             * FindDeployResponse blockInfo.
             * @member {casper.ILightBlockInfo|null|undefined} blockInfo
             * @memberof casper.v1.FindDeployResponse
             * @instance
             */
            FindDeployResponse.prototype.blockInfo = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * FindDeployResponse message.
             * @member {"error"|"blockInfo"|undefined} message
             * @memberof casper.v1.FindDeployResponse
             * @instance
             */
            Object.defineProperty(FindDeployResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FindDeployResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {casper.v1.IFindDeployResponse=} [properties] Properties to set
             * @returns {casper.v1.FindDeployResponse} FindDeployResponse instance
             */
            FindDeployResponse.create = function create(properties) {
                return new FindDeployResponse(properties);
            };

            /**
             * Encodes the specified FindDeployResponse message. Does not implicitly {@link casper.v1.FindDeployResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {casper.v1.IFindDeployResponse} message FindDeployResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FindDeployResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                    $root.casper.LightBlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FindDeployResponse message, length delimited. Does not implicitly {@link casper.v1.FindDeployResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {casper.v1.IFindDeployResponse} message FindDeployResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FindDeployResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FindDeployResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.FindDeployResponse} FindDeployResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FindDeployResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.FindDeployResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.blockInfo = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FindDeployResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.FindDeployResponse} FindDeployResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FindDeployResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FindDeployResponse message.
             * @function verify
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FindDeployResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.LightBlockInfo.verify(message.blockInfo);
                        if (error)
                            return "blockInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FindDeployResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.FindDeployResponse} FindDeployResponse
             */
            FindDeployResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.FindDeployResponse)
                    return object;
                var message = new $root.casper.v1.FindDeployResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.FindDeployResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.blockInfo != null) {
                    if (typeof object.blockInfo !== "object")
                        throw TypeError(".casper.v1.FindDeployResponse.blockInfo: object expected");
                    message.blockInfo = $root.casper.LightBlockInfo.fromObject(object.blockInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a FindDeployResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.FindDeployResponse
             * @static
             * @param {casper.v1.FindDeployResponse} message FindDeployResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FindDeployResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    object.blockInfo = $root.casper.LightBlockInfo.toObject(message.blockInfo, options);
                    if (options.oneofs)
                        object.message = "blockInfo";
                }
                return object;
            };

            /**
             * Converts this FindDeployResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.FindDeployResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FindDeployResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FindDeployResponse;
        })();

        v1.PrivateNamePreviewResponse = (function() {

            /**
             * Properties of a PrivateNamePreviewResponse.
             * @memberof casper.v1
             * @interface IPrivateNamePreviewResponse
             * @property {IServiceError|null} [error] PrivateNamePreviewResponse error
             * @property {casper.v1.IPrivateNamePreviewPayload|null} [payload] PrivateNamePreviewResponse payload
             */

            /**
             * Constructs a new PrivateNamePreviewResponse.
             * @memberof casper.v1
             * @classdesc Represents a PrivateNamePreviewResponse.
             * @implements IPrivateNamePreviewResponse
             * @constructor
             * @param {casper.v1.IPrivateNamePreviewResponse=} [properties] Properties to set
             */
            function PrivateNamePreviewResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrivateNamePreviewResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @instance
             */
            PrivateNamePreviewResponse.prototype.error = null;

            /**
             * PrivateNamePreviewResponse payload.
             * @member {casper.v1.IPrivateNamePreviewPayload|null|undefined} payload
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @instance
             */
            PrivateNamePreviewResponse.prototype.payload = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PrivateNamePreviewResponse message.
             * @member {"error"|"payload"|undefined} message
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @instance
             */
            Object.defineProperty(PrivateNamePreviewResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "payload"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PrivateNamePreviewResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {casper.v1.IPrivateNamePreviewResponse=} [properties] Properties to set
             * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse instance
             */
            PrivateNamePreviewResponse.create = function create(properties) {
                return new PrivateNamePreviewResponse(properties);
            };

            /**
             * Encodes the specified PrivateNamePreviewResponse message. Does not implicitly {@link casper.v1.PrivateNamePreviewResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {casper.v1.IPrivateNamePreviewResponse} message PrivateNamePreviewResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateNamePreviewResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    $root.casper.v1.PrivateNamePreviewPayload.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PrivateNamePreviewResponse message, length delimited. Does not implicitly {@link casper.v1.PrivateNamePreviewResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {casper.v1.IPrivateNamePreviewResponse} message PrivateNamePreviewResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateNamePreviewResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrivateNamePreviewResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateNamePreviewResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.PrivateNamePreviewResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.payload = $root.casper.v1.PrivateNamePreviewPayload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrivateNamePreviewResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateNamePreviewResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrivateNamePreviewResponse message.
             * @function verify
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrivateNamePreviewResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.v1.PrivateNamePreviewPayload.verify(message.payload);
                        if (error)
                            return "payload." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PrivateNamePreviewResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse
             */
            PrivateNamePreviewResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.PrivateNamePreviewResponse)
                    return object;
                var message = new $root.casper.v1.PrivateNamePreviewResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.PrivateNamePreviewResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".casper.v1.PrivateNamePreviewResponse.payload: object expected");
                    message.payload = $root.casper.v1.PrivateNamePreviewPayload.fromObject(object.payload);
                }
                return message;
            };

            /**
             * Creates a plain object from a PrivateNamePreviewResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @static
             * @param {casper.v1.PrivateNamePreviewResponse} message PrivateNamePreviewResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrivateNamePreviewResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    object.payload = $root.casper.v1.PrivateNamePreviewPayload.toObject(message.payload, options);
                    if (options.oneofs)
                        object.message = "payload";
                }
                return object;
            };

            /**
             * Converts this PrivateNamePreviewResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.PrivateNamePreviewResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrivateNamePreviewResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrivateNamePreviewResponse;
        })();

        v1.PrivateNamePreviewPayload = (function() {

            /**
             * Properties of a PrivateNamePreviewPayload.
             * @memberof casper.v1
             * @interface IPrivateNamePreviewPayload
             * @property {Array.<Uint8Array>|null} [ids] PrivateNamePreviewPayload ids
             */

            /**
             * Constructs a new PrivateNamePreviewPayload.
             * @memberof casper.v1
             * @classdesc Represents a PrivateNamePreviewPayload.
             * @implements IPrivateNamePreviewPayload
             * @constructor
             * @param {casper.v1.IPrivateNamePreviewPayload=} [properties] Properties to set
             */
            function PrivateNamePreviewPayload(properties) {
                this.ids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrivateNamePreviewPayload ids.
             * @member {Array.<Uint8Array>} ids
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @instance
             */
            PrivateNamePreviewPayload.prototype.ids = $util.emptyArray;

            /**
             * Creates a new PrivateNamePreviewPayload instance using the specified properties.
             * @function create
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {casper.v1.IPrivateNamePreviewPayload=} [properties] Properties to set
             * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload instance
             */
            PrivateNamePreviewPayload.create = function create(properties) {
                return new PrivateNamePreviewPayload(properties);
            };

            /**
             * Encodes the specified PrivateNamePreviewPayload message. Does not implicitly {@link casper.v1.PrivateNamePreviewPayload.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {casper.v1.IPrivateNamePreviewPayload} message PrivateNamePreviewPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateNamePreviewPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ids != null && message.ids.length)
                    for (var i = 0; i < message.ids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ids[i]);
                return writer;
            };

            /**
             * Encodes the specified PrivateNamePreviewPayload message, length delimited. Does not implicitly {@link casper.v1.PrivateNamePreviewPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {casper.v1.IPrivateNamePreviewPayload} message PrivateNamePreviewPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateNamePreviewPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrivateNamePreviewPayload message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateNamePreviewPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.PrivateNamePreviewPayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        message.ids.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrivateNamePreviewPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateNamePreviewPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrivateNamePreviewPayload message.
             * @function verify
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrivateNamePreviewPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ids != null && message.hasOwnProperty("ids")) {
                    if (!Array.isArray(message.ids))
                        return "ids: array expected";
                    for (var i = 0; i < message.ids.length; ++i)
                        if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                            return "ids: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a PrivateNamePreviewPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload
             */
            PrivateNamePreviewPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.PrivateNamePreviewPayload)
                    return object;
                var message = new $root.casper.v1.PrivateNamePreviewPayload();
                if (object.ids) {
                    if (!Array.isArray(object.ids))
                        throw TypeError(".casper.v1.PrivateNamePreviewPayload.ids: array expected");
                    message.ids = [];
                    for (var i = 0; i < object.ids.length; ++i)
                        if (typeof object.ids[i] === "string")
                            $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                        else if (object.ids[i].length)
                            message.ids[i] = object.ids[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a PrivateNamePreviewPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @static
             * @param {casper.v1.PrivateNamePreviewPayload} message PrivateNamePreviewPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrivateNamePreviewPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ids = [];
                if (message.ids && message.ids.length) {
                    object.ids = [];
                    for (var j = 0; j < message.ids.length; ++j)
                        object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
                }
                return object;
            };

            /**
             * Converts this PrivateNamePreviewPayload to JSON.
             * @function toJSON
             * @memberof casper.v1.PrivateNamePreviewPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrivateNamePreviewPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrivateNamePreviewPayload;
        })();

        v1.LastFinalizedBlockResponse = (function() {

            /**
             * Properties of a LastFinalizedBlockResponse.
             * @memberof casper.v1
             * @interface ILastFinalizedBlockResponse
             * @property {IServiceError|null} [error] LastFinalizedBlockResponse error
             * @property {casper.IBlockInfo|null} [blockInfo] LastFinalizedBlockResponse blockInfo
             */

            /**
             * Constructs a new LastFinalizedBlockResponse.
             * @memberof casper.v1
             * @classdesc Represents a LastFinalizedBlockResponse.
             * @implements ILastFinalizedBlockResponse
             * @constructor
             * @param {casper.v1.ILastFinalizedBlockResponse=} [properties] Properties to set
             */
            function LastFinalizedBlockResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LastFinalizedBlockResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @instance
             */
            LastFinalizedBlockResponse.prototype.error = null;

            /**
             * LastFinalizedBlockResponse blockInfo.
             * @member {casper.IBlockInfo|null|undefined} blockInfo
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @instance
             */
            LastFinalizedBlockResponse.prototype.blockInfo = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * LastFinalizedBlockResponse message.
             * @member {"error"|"blockInfo"|undefined} message
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @instance
             */
            Object.defineProperty(LastFinalizedBlockResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new LastFinalizedBlockResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {casper.v1.ILastFinalizedBlockResponse=} [properties] Properties to set
             * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse instance
             */
            LastFinalizedBlockResponse.create = function create(properties) {
                return new LastFinalizedBlockResponse(properties);
            };

            /**
             * Encodes the specified LastFinalizedBlockResponse message. Does not implicitly {@link casper.v1.LastFinalizedBlockResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {casper.v1.ILastFinalizedBlockResponse} message LastFinalizedBlockResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastFinalizedBlockResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                    $root.casper.BlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LastFinalizedBlockResponse message, length delimited. Does not implicitly {@link casper.v1.LastFinalizedBlockResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {casper.v1.ILastFinalizedBlockResponse} message LastFinalizedBlockResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastFinalizedBlockResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LastFinalizedBlockResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastFinalizedBlockResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.LastFinalizedBlockResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.blockInfo = $root.casper.BlockInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LastFinalizedBlockResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastFinalizedBlockResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LastFinalizedBlockResponse message.
             * @function verify
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LastFinalizedBlockResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    {
                        var error = $root.casper.BlockInfo.verify(message.blockInfo);
                        if (error)
                            return "blockInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LastFinalizedBlockResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse
             */
            LastFinalizedBlockResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.LastFinalizedBlockResponse)
                    return object;
                var message = new $root.casper.v1.LastFinalizedBlockResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.LastFinalizedBlockResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.blockInfo != null) {
                    if (typeof object.blockInfo !== "object")
                        throw TypeError(".casper.v1.LastFinalizedBlockResponse.blockInfo: object expected");
                    message.blockInfo = $root.casper.BlockInfo.fromObject(object.blockInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a LastFinalizedBlockResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @static
             * @param {casper.v1.LastFinalizedBlockResponse} message LastFinalizedBlockResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LastFinalizedBlockResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                    object.blockInfo = $root.casper.BlockInfo.toObject(message.blockInfo, options);
                    if (options.oneofs)
                        object.message = "blockInfo";
                }
                return object;
            };

            /**
             * Converts this LastFinalizedBlockResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.LastFinalizedBlockResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LastFinalizedBlockResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LastFinalizedBlockResponse;
        })();

        v1.IsFinalizedResponse = (function() {

            /**
             * Properties of an IsFinalizedResponse.
             * @memberof casper.v1
             * @interface IIsFinalizedResponse
             * @property {IServiceError|null} [error] IsFinalizedResponse error
             * @property {boolean|null} [isFinalized] IsFinalizedResponse isFinalized
             */

            /**
             * Constructs a new IsFinalizedResponse.
             * @memberof casper.v1
             * @classdesc Represents an IsFinalizedResponse.
             * @implements IIsFinalizedResponse
             * @constructor
             * @param {casper.v1.IIsFinalizedResponse=} [properties] Properties to set
             */
            function IsFinalizedResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsFinalizedResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.IsFinalizedResponse
             * @instance
             */
            IsFinalizedResponse.prototype.error = null;

            /**
             * IsFinalizedResponse isFinalized.
             * @member {boolean} isFinalized
             * @memberof casper.v1.IsFinalizedResponse
             * @instance
             */
            IsFinalizedResponse.prototype.isFinalized = false;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * IsFinalizedResponse message.
             * @member {"error"|"isFinalized"|undefined} message
             * @memberof casper.v1.IsFinalizedResponse
             * @instance
             */
            Object.defineProperty(IsFinalizedResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "isFinalized"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new IsFinalizedResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {casper.v1.IIsFinalizedResponse=} [properties] Properties to set
             * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse instance
             */
            IsFinalizedResponse.create = function create(properties) {
                return new IsFinalizedResponse(properties);
            };

            /**
             * Encodes the specified IsFinalizedResponse message. Does not implicitly {@link casper.v1.IsFinalizedResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {casper.v1.IIsFinalizedResponse} message IsFinalizedResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsFinalizedResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.isFinalized != null && message.hasOwnProperty("isFinalized"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFinalized);
                return writer;
            };

            /**
             * Encodes the specified IsFinalizedResponse message, length delimited. Does not implicitly {@link casper.v1.IsFinalizedResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {casper.v1.IIsFinalizedResponse} message IsFinalizedResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsFinalizedResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsFinalizedResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsFinalizedResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.IsFinalizedResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.isFinalized = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsFinalizedResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsFinalizedResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsFinalizedResponse message.
             * @function verify
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsFinalizedResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.isFinalized != null && message.hasOwnProperty("isFinalized")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    if (typeof message.isFinalized !== "boolean")
                        return "isFinalized: boolean expected";
                }
                return null;
            };

            /**
             * Creates an IsFinalizedResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse
             */
            IsFinalizedResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.IsFinalizedResponse)
                    return object;
                var message = new $root.casper.v1.IsFinalizedResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.IsFinalizedResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.isFinalized != null)
                    message.isFinalized = Boolean(object.isFinalized);
                return message;
            };

            /**
             * Creates a plain object from an IsFinalizedResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.IsFinalizedResponse
             * @static
             * @param {casper.v1.IsFinalizedResponse} message IsFinalizedResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsFinalizedResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.isFinalized != null && message.hasOwnProperty("isFinalized")) {
                    object.isFinalized = message.isFinalized;
                    if (options.oneofs)
                        object.message = "isFinalized";
                }
                return object;
            };

            /**
             * Converts this IsFinalizedResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.IsFinalizedResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsFinalizedResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IsFinalizedResponse;
        })();

        v1.ProposeService = (function() {

            /**
             * Constructs a new ProposeService service.
             * @memberof casper.v1
             * @classdesc Represents a ProposeService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ProposeService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ProposeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ProposeService;

            /**
             * Creates new ProposeService service using the specified rpc implementation.
             * @function create
             * @memberof casper.v1.ProposeService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ProposeService} RPC service. Useful where requests and/or responses are streamed.
             */
            ProposeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link casper.v1.ProposeService#propose}.
             * @memberof casper.v1.ProposeService
             * @typedef proposeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {casper.v1.ProposeResponse} [response] ProposeResponse
             */

            /**
             * Calls propose.
             * @function propose
             * @memberof casper.v1.ProposeService
             * @instance
             * @param {casper.IPrintUnmatchedSendsQuery} request PrintUnmatchedSendsQuery message or plain object
             * @param {casper.v1.ProposeService.proposeCallback} callback Node-style callback called with the error, if any, and ProposeResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ProposeService.prototype.propose = function propose(request, callback) {
                return this.rpcCall(propose, $root.casper.PrintUnmatchedSendsQuery, $root.casper.v1.ProposeResponse, request, callback);
            }, "name", { value: "propose" });

            /**
             * Calls propose.
             * @function propose
             * @memberof casper.v1.ProposeService
             * @instance
             * @param {casper.IPrintUnmatchedSendsQuery} request PrintUnmatchedSendsQuery message or plain object
             * @returns {Promise<casper.v1.ProposeResponse>} Promise
             * @variation 2
             */

            return ProposeService;
        })();

        v1.ProposeResponse = (function() {

            /**
             * Properties of a ProposeResponse.
             * @memberof casper.v1
             * @interface IProposeResponse
             * @property {IServiceError|null} [error] ProposeResponse error
             * @property {string|null} [result] ProposeResponse result
             */

            /**
             * Constructs a new ProposeResponse.
             * @memberof casper.v1
             * @classdesc Represents a ProposeResponse.
             * @implements IProposeResponse
             * @constructor
             * @param {casper.v1.IProposeResponse=} [properties] Properties to set
             */
            function ProposeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProposeResponse error.
             * @member {IServiceError|null|undefined} error
             * @memberof casper.v1.ProposeResponse
             * @instance
             */
            ProposeResponse.prototype.error = null;

            /**
             * ProposeResponse result.
             * @member {string} result
             * @memberof casper.v1.ProposeResponse
             * @instance
             */
            ProposeResponse.prototype.result = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ProposeResponse message.
             * @member {"error"|"result"|undefined} message
             * @memberof casper.v1.ProposeResponse
             * @instance
             */
            Object.defineProperty(ProposeResponse.prototype, "message", {
                get: $util.oneOfGetter($oneOfFields = ["error", "result"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ProposeResponse instance using the specified properties.
             * @function create
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {casper.v1.IProposeResponse=} [properties] Properties to set
             * @returns {casper.v1.ProposeResponse} ProposeResponse instance
             */
            ProposeResponse.create = function create(properties) {
                return new ProposeResponse(properties);
            };

            /**
             * Encodes the specified ProposeResponse message. Does not implicitly {@link casper.v1.ProposeResponse.verify|verify} messages.
             * @function encode
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {casper.v1.IProposeResponse} message ProposeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.result != null && message.hasOwnProperty("result"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
                return writer;
            };

            /**
             * Encodes the specified ProposeResponse message, length delimited. Does not implicitly {@link casper.v1.ProposeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {casper.v1.IProposeResponse} message ProposeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProposeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {casper.v1.ProposeResponse} ProposeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ProposeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.ServiceError.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.result = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProposeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {casper.v1.ProposeResponse} ProposeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProposeResponse message.
             * @function verify
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProposeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.message = 1;
                    {
                        var error = $root.ServiceError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    if (properties.message === 1)
                        return "message: multiple values";
                    properties.message = 1;
                    if (!$util.isString(message.result))
                        return "result: string expected";
                }
                return null;
            };

            /**
             * Creates a ProposeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {casper.v1.ProposeResponse} ProposeResponse
             */
            ProposeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.casper.v1.ProposeResponse)
                    return object;
                var message = new $root.casper.v1.ProposeResponse();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".casper.v1.ProposeResponse.error: object expected");
                    message.error = $root.ServiceError.fromObject(object.error);
                }
                if (object.result != null)
                    message.result = String(object.result);
                return message;
            };

            /**
             * Creates a plain object from a ProposeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof casper.v1.ProposeResponse
             * @static
             * @param {casper.v1.ProposeResponse} message ProposeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProposeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.ServiceError.toObject(message.error, options);
                    if (options.oneofs)
                        object.message = "error";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object.message = "result";
                }
                return object;
            };

            /**
             * Converts this ProposeResponse to JSON.
             * @function toJSON
             * @memberof casper.v1.ProposeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProposeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProposeResponse;
        })();

        return v1;
    })();

    casper.PrintUnmatchedSendsQuery = (function() {

        /**
         * Properties of a PrintUnmatchedSendsQuery.
         * @memberof casper
         * @interface IPrintUnmatchedSendsQuery
         * @property {boolean|null} [printUnmatchedSends] PrintUnmatchedSendsQuery printUnmatchedSends
         */

        /**
         * Constructs a new PrintUnmatchedSendsQuery.
         * @memberof casper
         * @classdesc Represents a PrintUnmatchedSendsQuery.
         * @implements IPrintUnmatchedSendsQuery
         * @constructor
         * @param {casper.IPrintUnmatchedSendsQuery=} [properties] Properties to set
         */
        function PrintUnmatchedSendsQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrintUnmatchedSendsQuery printUnmatchedSends.
         * @member {boolean} printUnmatchedSends
         * @memberof casper.PrintUnmatchedSendsQuery
         * @instance
         */
        PrintUnmatchedSendsQuery.prototype.printUnmatchedSends = false;

        /**
         * Creates a new PrintUnmatchedSendsQuery instance using the specified properties.
         * @function create
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {casper.IPrintUnmatchedSendsQuery=} [properties] Properties to set
         * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery instance
         */
        PrintUnmatchedSendsQuery.create = function create(properties) {
            return new PrintUnmatchedSendsQuery(properties);
        };

        /**
         * Encodes the specified PrintUnmatchedSendsQuery message. Does not implicitly {@link casper.PrintUnmatchedSendsQuery.verify|verify} messages.
         * @function encode
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {casper.IPrintUnmatchedSendsQuery} message PrintUnmatchedSendsQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrintUnmatchedSendsQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.printUnmatchedSends != null && message.hasOwnProperty("printUnmatchedSends"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.printUnmatchedSends);
            return writer;
        };

        /**
         * Encodes the specified PrintUnmatchedSendsQuery message, length delimited. Does not implicitly {@link casper.PrintUnmatchedSendsQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {casper.IPrintUnmatchedSendsQuery} message PrintUnmatchedSendsQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrintUnmatchedSendsQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrintUnmatchedSendsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrintUnmatchedSendsQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.PrintUnmatchedSendsQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.printUnmatchedSends = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrintUnmatchedSendsQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrintUnmatchedSendsQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrintUnmatchedSendsQuery message.
         * @function verify
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrintUnmatchedSendsQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.printUnmatchedSends != null && message.hasOwnProperty("printUnmatchedSends"))
                if (typeof message.printUnmatchedSends !== "boolean")
                    return "printUnmatchedSends: boolean expected";
            return null;
        };

        /**
         * Creates a PrintUnmatchedSendsQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery
         */
        PrintUnmatchedSendsQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.casper.PrintUnmatchedSendsQuery)
                return object;
            var message = new $root.casper.PrintUnmatchedSendsQuery();
            if (object.printUnmatchedSends != null)
                message.printUnmatchedSends = Boolean(object.printUnmatchedSends);
            return message;
        };

        /**
         * Creates a plain object from a PrintUnmatchedSendsQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof casper.PrintUnmatchedSendsQuery
         * @static
         * @param {casper.PrintUnmatchedSendsQuery} message PrintUnmatchedSendsQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrintUnmatchedSendsQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.printUnmatchedSends = false;
            if (message.printUnmatchedSends != null && message.hasOwnProperty("printUnmatchedSends"))
                object.printUnmatchedSends = message.printUnmatchedSends;
            return object;
        };

        /**
         * Converts this PrintUnmatchedSendsQuery to JSON.
         * @function toJSON
         * @memberof casper.PrintUnmatchedSendsQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrintUnmatchedSendsQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrintUnmatchedSendsQuery;
    })();

    return casper;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        return protobuf;
    })();

    return google;
})();

$root.Par = (function() {

    /**
     * Properties of a Par.
     * @exports IPar
     * @interface IPar
     * @property {Array.<ISend>|null} [sends] Par sends
     * @property {Array.<IReceive>|null} [receives] Par receives
     * @property {Array.<INew>|null} [news] Par news
     * @property {Array.<IExpr>|null} [exprs] Par exprs
     * @property {Array.<IMatch>|null} [matches] Par matches
     * @property {Array.<IGUnforgeable>|null} [unforgeables] Par unforgeables
     * @property {Array.<IBundle>|null} [bundles] Par bundles
     * @property {Array.<IConnective>|null} [connectives] Par connectives
     * @property {Uint8Array|null} [locallyFree] Par locallyFree
     * @property {boolean|null} [connective_used] Par connective_used
     */

    /**
     * Constructs a new Par.
     * @exports Par
     * @classdesc Rholang process
     * 
     * For example, `@0!(1) | @2!(3) | for(x <- @0) { Nil }` has two sends
     * and one receive.
     * 
     * The Nil process is a `Par` with no sends, receives, etc.
     * @implements IPar
     * @constructor
     * @param {IPar=} [properties] Properties to set
     */
    function Par(properties) {
        this.sends = [];
        this.receives = [];
        this.news = [];
        this.exprs = [];
        this.matches = [];
        this.unforgeables = [];
        this.bundles = [];
        this.connectives = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Par sends.
     * @member {Array.<ISend>} sends
     * @memberof Par
     * @instance
     */
    Par.prototype.sends = $util.emptyArray;

    /**
     * Par receives.
     * @member {Array.<IReceive>} receives
     * @memberof Par
     * @instance
     */
    Par.prototype.receives = $util.emptyArray;

    /**
     * Par news.
     * @member {Array.<INew>} news
     * @memberof Par
     * @instance
     */
    Par.prototype.news = $util.emptyArray;

    /**
     * Par exprs.
     * @member {Array.<IExpr>} exprs
     * @memberof Par
     * @instance
     */
    Par.prototype.exprs = $util.emptyArray;

    /**
     * Par matches.
     * @member {Array.<IMatch>} matches
     * @memberof Par
     * @instance
     */
    Par.prototype.matches = $util.emptyArray;

    /**
     * Par unforgeables.
     * @member {Array.<IGUnforgeable>} unforgeables
     * @memberof Par
     * @instance
     */
    Par.prototype.unforgeables = $util.emptyArray;

    /**
     * Par bundles.
     * @member {Array.<IBundle>} bundles
     * @memberof Par
     * @instance
     */
    Par.prototype.bundles = $util.emptyArray;

    /**
     * Par connectives.
     * @member {Array.<IConnective>} connectives
     * @memberof Par
     * @instance
     */
    Par.prototype.connectives = $util.emptyArray;

    /**
     * Par locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof Par
     * @instance
     */
    Par.prototype.locallyFree = $util.newBuffer([]);

    /**
     * Par connective_used.
     * @member {boolean} connective_used
     * @memberof Par
     * @instance
     */
    Par.prototype.connective_used = false;

    /**
     * Creates a new Par instance using the specified properties.
     * @function create
     * @memberof Par
     * @static
     * @param {IPar=} [properties] Properties to set
     * @returns {Par} Par instance
     */
    Par.create = function create(properties) {
        return new Par(properties);
    };

    /**
     * Encodes the specified Par message. Does not implicitly {@link Par.verify|verify} messages.
     * @function encode
     * @memberof Par
     * @static
     * @param {IPar} message Par message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Par.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sends != null && message.sends.length)
            for (var i = 0; i < message.sends.length; ++i)
                $root.Send.encode(message.sends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.receives != null && message.receives.length)
            for (var i = 0; i < message.receives.length; ++i)
                $root.Receive.encode(message.receives[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.news != null && message.news.length)
            for (var i = 0; i < message.news.length; ++i)
                $root.New.encode(message.news[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.exprs != null && message.exprs.length)
            for (var i = 0; i < message.exprs.length; ++i)
                $root.Expr.encode(message.exprs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.matches != null && message.matches.length)
            for (var i = 0; i < message.matches.length; ++i)
                $root.Match.encode(message.matches[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.unforgeables != null && message.unforgeables.length)
            for (var i = 0; i < message.unforgeables.length; ++i)
                $root.GUnforgeable.encode(message.unforgeables[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.connectives != null && message.connectives.length)
            for (var i = 0; i < message.connectives.length; ++i)
                $root.Connective.encode(message.connectives[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.connective_used);
        if (message.bundles != null && message.bundles.length)
            for (var i = 0; i < message.bundles.length; ++i)
                $root.Bundle.encode(message.bundles[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Par message, length delimited. Does not implicitly {@link Par.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Par
     * @static
     * @param {IPar} message Par message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Par.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Par message from the specified reader or buffer.
     * @function decode
     * @memberof Par
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Par} Par
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Par.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Par();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.sends && message.sends.length))
                    message.sends = [];
                message.sends.push($root.Send.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.receives && message.receives.length))
                    message.receives = [];
                message.receives.push($root.Receive.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.news && message.news.length))
                    message.news = [];
                message.news.push($root.New.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.exprs && message.exprs.length))
                    message.exprs = [];
                message.exprs.push($root.Expr.decode(reader, reader.uint32()));
                break;
            case 6:
                if (!(message.matches && message.matches.length))
                    message.matches = [];
                message.matches.push($root.Match.decode(reader, reader.uint32()));
                break;
            case 7:
                if (!(message.unforgeables && message.unforgeables.length))
                    message.unforgeables = [];
                message.unforgeables.push($root.GUnforgeable.decode(reader, reader.uint32()));
                break;
            case 11:
                if (!(message.bundles && message.bundles.length))
                    message.bundles = [];
                message.bundles.push($root.Bundle.decode(reader, reader.uint32()));
                break;
            case 8:
                if (!(message.connectives && message.connectives.length))
                    message.connectives = [];
                message.connectives.push($root.Connective.decode(reader, reader.uint32()));
                break;
            case 9:
                message.locallyFree = reader.bytes();
                break;
            case 10:
                message.connective_used = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Par message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Par
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Par} Par
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Par.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Par message.
     * @function verify
     * @memberof Par
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Par.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sends != null && message.hasOwnProperty("sends")) {
            if (!Array.isArray(message.sends))
                return "sends: array expected";
            for (var i = 0; i < message.sends.length; ++i) {
                var error = $root.Send.verify(message.sends[i]);
                if (error)
                    return "sends." + error;
            }
        }
        if (message.receives != null && message.hasOwnProperty("receives")) {
            if (!Array.isArray(message.receives))
                return "receives: array expected";
            for (var i = 0; i < message.receives.length; ++i) {
                var error = $root.Receive.verify(message.receives[i]);
                if (error)
                    return "receives." + error;
            }
        }
        if (message.news != null && message.hasOwnProperty("news")) {
            if (!Array.isArray(message.news))
                return "news: array expected";
            for (var i = 0; i < message.news.length; ++i) {
                var error = $root.New.verify(message.news[i]);
                if (error)
                    return "news." + error;
            }
        }
        if (message.exprs != null && message.hasOwnProperty("exprs")) {
            if (!Array.isArray(message.exprs))
                return "exprs: array expected";
            for (var i = 0; i < message.exprs.length; ++i) {
                var error = $root.Expr.verify(message.exprs[i]);
                if (error)
                    return "exprs." + error;
            }
        }
        if (message.matches != null && message.hasOwnProperty("matches")) {
            if (!Array.isArray(message.matches))
                return "matches: array expected";
            for (var i = 0; i < message.matches.length; ++i) {
                var error = $root.Match.verify(message.matches[i]);
                if (error)
                    return "matches." + error;
            }
        }
        if (message.unforgeables != null && message.hasOwnProperty("unforgeables")) {
            if (!Array.isArray(message.unforgeables))
                return "unforgeables: array expected";
            for (var i = 0; i < message.unforgeables.length; ++i) {
                var error = $root.GUnforgeable.verify(message.unforgeables[i]);
                if (error)
                    return "unforgeables." + error;
            }
        }
        if (message.bundles != null && message.hasOwnProperty("bundles")) {
            if (!Array.isArray(message.bundles))
                return "bundles: array expected";
            for (var i = 0; i < message.bundles.length; ++i) {
                var error = $root.Bundle.verify(message.bundles[i]);
                if (error)
                    return "bundles." + error;
            }
        }
        if (message.connectives != null && message.hasOwnProperty("connectives")) {
            if (!Array.isArray(message.connectives))
                return "connectives: array expected";
            for (var i = 0; i < message.connectives.length; ++i) {
                var error = $root.Connective.verify(message.connectives[i]);
                if (error)
                    return "connectives." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        return null;
    };

    /**
     * Creates a Par message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Par
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Par} Par
     */
    Par.fromObject = function fromObject(object) {
        if (object instanceof $root.Par)
            return object;
        var message = new $root.Par();
        if (object.sends) {
            if (!Array.isArray(object.sends))
                throw TypeError(".Par.sends: array expected");
            message.sends = [];
            for (var i = 0; i < object.sends.length; ++i) {
                if (typeof object.sends[i] !== "object")
                    throw TypeError(".Par.sends: object expected");
                message.sends[i] = $root.Send.fromObject(object.sends[i]);
            }
        }
        if (object.receives) {
            if (!Array.isArray(object.receives))
                throw TypeError(".Par.receives: array expected");
            message.receives = [];
            for (var i = 0; i < object.receives.length; ++i) {
                if (typeof object.receives[i] !== "object")
                    throw TypeError(".Par.receives: object expected");
                message.receives[i] = $root.Receive.fromObject(object.receives[i]);
            }
        }
        if (object.news) {
            if (!Array.isArray(object.news))
                throw TypeError(".Par.news: array expected");
            message.news = [];
            for (var i = 0; i < object.news.length; ++i) {
                if (typeof object.news[i] !== "object")
                    throw TypeError(".Par.news: object expected");
                message.news[i] = $root.New.fromObject(object.news[i]);
            }
        }
        if (object.exprs) {
            if (!Array.isArray(object.exprs))
                throw TypeError(".Par.exprs: array expected");
            message.exprs = [];
            for (var i = 0; i < object.exprs.length; ++i) {
                if (typeof object.exprs[i] !== "object")
                    throw TypeError(".Par.exprs: object expected");
                message.exprs[i] = $root.Expr.fromObject(object.exprs[i]);
            }
        }
        if (object.matches) {
            if (!Array.isArray(object.matches))
                throw TypeError(".Par.matches: array expected");
            message.matches = [];
            for (var i = 0; i < object.matches.length; ++i) {
                if (typeof object.matches[i] !== "object")
                    throw TypeError(".Par.matches: object expected");
                message.matches[i] = $root.Match.fromObject(object.matches[i]);
            }
        }
        if (object.unforgeables) {
            if (!Array.isArray(object.unforgeables))
                throw TypeError(".Par.unforgeables: array expected");
            message.unforgeables = [];
            for (var i = 0; i < object.unforgeables.length; ++i) {
                if (typeof object.unforgeables[i] !== "object")
                    throw TypeError(".Par.unforgeables: object expected");
                message.unforgeables[i] = $root.GUnforgeable.fromObject(object.unforgeables[i]);
            }
        }
        if (object.bundles) {
            if (!Array.isArray(object.bundles))
                throw TypeError(".Par.bundles: array expected");
            message.bundles = [];
            for (var i = 0; i < object.bundles.length; ++i) {
                if (typeof object.bundles[i] !== "object")
                    throw TypeError(".Par.bundles: object expected");
                message.bundles[i] = $root.Bundle.fromObject(object.bundles[i]);
            }
        }
        if (object.connectives) {
            if (!Array.isArray(object.connectives))
                throw TypeError(".Par.connectives: array expected");
            message.connectives = [];
            for (var i = 0; i < object.connectives.length; ++i) {
                if (typeof object.connectives[i] !== "object")
                    throw TypeError(".Par.connectives: object expected");
                message.connectives[i] = $root.Connective.fromObject(object.connectives[i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        return message;
    };

    /**
     * Creates a plain object from a Par message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Par
     * @static
     * @param {Par} message Par
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Par.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.sends = [];
            object.receives = [];
            object.news = [];
            object.exprs = [];
            object.matches = [];
            object.unforgeables = [];
            object.connectives = [];
            object.bundles = [];
        }
        if (options.defaults) {
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
        }
        if (message.sends && message.sends.length) {
            object.sends = [];
            for (var j = 0; j < message.sends.length; ++j)
                object.sends[j] = $root.Send.toObject(message.sends[j], options);
        }
        if (message.receives && message.receives.length) {
            object.receives = [];
            for (var j = 0; j < message.receives.length; ++j)
                object.receives[j] = $root.Receive.toObject(message.receives[j], options);
        }
        if (message.news && message.news.length) {
            object.news = [];
            for (var j = 0; j < message.news.length; ++j)
                object.news[j] = $root.New.toObject(message.news[j], options);
        }
        if (message.exprs && message.exprs.length) {
            object.exprs = [];
            for (var j = 0; j < message.exprs.length; ++j)
                object.exprs[j] = $root.Expr.toObject(message.exprs[j], options);
        }
        if (message.matches && message.matches.length) {
            object.matches = [];
            for (var j = 0; j < message.matches.length; ++j)
                object.matches[j] = $root.Match.toObject(message.matches[j], options);
        }
        if (message.unforgeables && message.unforgeables.length) {
            object.unforgeables = [];
            for (var j = 0; j < message.unforgeables.length; ++j)
                object.unforgeables[j] = $root.GUnforgeable.toObject(message.unforgeables[j], options);
        }
        if (message.connectives && message.connectives.length) {
            object.connectives = [];
            for (var j = 0; j < message.connectives.length; ++j)
                object.connectives[j] = $root.Connective.toObject(message.connectives[j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        if (message.bundles && message.bundles.length) {
            object.bundles = [];
            for (var j = 0; j < message.bundles.length; ++j)
                object.bundles[j] = $root.Bundle.toObject(message.bundles[j], options);
        }
        return object;
    };

    /**
     * Converts this Par to JSON.
     * @function toJSON
     * @memberof Par
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Par.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Par;
})();

$root.TaggedContinuation = (function() {

    /**
     * Properties of a TaggedContinuation.
     * @exports ITaggedContinuation
     * @interface ITaggedContinuation
     * @property {IParWithRandom|null} [par_body] TaggedContinuation par_body
     * @property {number|Long|null} [scala_body_ref] TaggedContinuation scala_body_ref
     */

    /**
     * Constructs a new TaggedContinuation.
     * @exports TaggedContinuation
     * @classdesc Either rholang code or code built in to the interpreter.
     * @implements ITaggedContinuation
     * @constructor
     * @param {ITaggedContinuation=} [properties] Properties to set
     */
    function TaggedContinuation(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TaggedContinuation par_body.
     * @member {IParWithRandom|null|undefined} par_body
     * @memberof TaggedContinuation
     * @instance
     */
    TaggedContinuation.prototype.par_body = null;

    /**
     * TaggedContinuation scala_body_ref.
     * @member {number|Long} scala_body_ref
     * @memberof TaggedContinuation
     * @instance
     */
    TaggedContinuation.prototype.scala_body_ref = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    // OneOf field names bound to virtual getters and setters
    var $oneOfFields;

    /**
     * TaggedContinuation tagged_cont.
     * @member {"par_body"|"scala_body_ref"|undefined} tagged_cont
     * @memberof TaggedContinuation
     * @instance
     */
    Object.defineProperty(TaggedContinuation.prototype, "tagged_cont", {
        get: $util.oneOfGetter($oneOfFields = ["par_body", "scala_body_ref"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new TaggedContinuation instance using the specified properties.
     * @function create
     * @memberof TaggedContinuation
     * @static
     * @param {ITaggedContinuation=} [properties] Properties to set
     * @returns {TaggedContinuation} TaggedContinuation instance
     */
    TaggedContinuation.create = function create(properties) {
        return new TaggedContinuation(properties);
    };

    /**
     * Encodes the specified TaggedContinuation message. Does not implicitly {@link TaggedContinuation.verify|verify} messages.
     * @function encode
     * @memberof TaggedContinuation
     * @static
     * @param {ITaggedContinuation} message TaggedContinuation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TaggedContinuation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.par_body != null && message.hasOwnProperty("par_body"))
            $root.ParWithRandom.encode(message.par_body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.scala_body_ref != null && message.hasOwnProperty("scala_body_ref"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.scala_body_ref);
        return writer;
    };

    /**
     * Encodes the specified TaggedContinuation message, length delimited. Does not implicitly {@link TaggedContinuation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TaggedContinuation
     * @static
     * @param {ITaggedContinuation} message TaggedContinuation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TaggedContinuation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TaggedContinuation message from the specified reader or buffer.
     * @function decode
     * @memberof TaggedContinuation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TaggedContinuation} TaggedContinuation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TaggedContinuation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TaggedContinuation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.par_body = $root.ParWithRandom.decode(reader, reader.uint32());
                break;
            case 2:
                message.scala_body_ref = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TaggedContinuation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TaggedContinuation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TaggedContinuation} TaggedContinuation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TaggedContinuation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TaggedContinuation message.
     * @function verify
     * @memberof TaggedContinuation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TaggedContinuation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        var properties = {};
        if (message.par_body != null && message.hasOwnProperty("par_body")) {
            properties.tagged_cont = 1;
            {
                var error = $root.ParWithRandom.verify(message.par_body);
                if (error)
                    return "par_body." + error;
            }
        }
        if (message.scala_body_ref != null && message.hasOwnProperty("scala_body_ref")) {
            if (properties.tagged_cont === 1)
                return "tagged_cont: multiple values";
            properties.tagged_cont = 1;
            if (!$util.isInteger(message.scala_body_ref) && !(message.scala_body_ref && $util.isInteger(message.scala_body_ref.low) && $util.isInteger(message.scala_body_ref.high)))
                return "scala_body_ref: integer|Long expected";
        }
        return null;
    };

    /**
     * Creates a TaggedContinuation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TaggedContinuation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TaggedContinuation} TaggedContinuation
     */
    TaggedContinuation.fromObject = function fromObject(object) {
        if (object instanceof $root.TaggedContinuation)
            return object;
        var message = new $root.TaggedContinuation();
        if (object.par_body != null) {
            if (typeof object.par_body !== "object")
                throw TypeError(".TaggedContinuation.par_body: object expected");
            message.par_body = $root.ParWithRandom.fromObject(object.par_body);
        }
        if (object.scala_body_ref != null)
            if ($util.Long)
                (message.scala_body_ref = $util.Long.fromValue(object.scala_body_ref)).unsigned = false;
            else if (typeof object.scala_body_ref === "string")
                message.scala_body_ref = parseInt(object.scala_body_ref, 10);
            else if (typeof object.scala_body_ref === "number")
                message.scala_body_ref = object.scala_body_ref;
            else if (typeof object.scala_body_ref === "object")
                message.scala_body_ref = new $util.LongBits(object.scala_body_ref.low >>> 0, object.scala_body_ref.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a TaggedContinuation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TaggedContinuation
     * @static
     * @param {TaggedContinuation} message TaggedContinuation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TaggedContinuation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (message.par_body != null && message.hasOwnProperty("par_body")) {
            object.par_body = $root.ParWithRandom.toObject(message.par_body, options);
            if (options.oneofs)
                object.tagged_cont = "par_body";
        }
        if (message.scala_body_ref != null && message.hasOwnProperty("scala_body_ref")) {
            if (typeof message.scala_body_ref === "number")
                object.scala_body_ref = options.longs === String ? String(message.scala_body_ref) : message.scala_body_ref;
            else
                object.scala_body_ref = options.longs === String ? $util.Long.prototype.toString.call(message.scala_body_ref) : options.longs === Number ? new $util.LongBits(message.scala_body_ref.low >>> 0, message.scala_body_ref.high >>> 0).toNumber() : message.scala_body_ref;
            if (options.oneofs)
                object.tagged_cont = "scala_body_ref";
        }
        return object;
    };

    /**
     * Converts this TaggedContinuation to JSON.
     * @function toJSON
     * @memberof TaggedContinuation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TaggedContinuation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TaggedContinuation;
})();

$root.ParWithRandom = (function() {

    /**
     * Properties of a ParWithRandom.
     * @exports IParWithRandom
     * @interface IParWithRandom
     * @property {IPar|null} [body] ParWithRandom body
     * @property {Uint8Array|null} [randomState] ParWithRandom randomState
     */

    /**
     * Constructs a new ParWithRandom.
     * @exports ParWithRandom
     * @classdesc Rholang code along with the state of a split random number
     * generator for generating new unforgeable names.
     * @implements IParWithRandom
     * @constructor
     * @param {IParWithRandom=} [properties] Properties to set
     */
    function ParWithRandom(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ParWithRandom body.
     * @member {IPar|null|undefined} body
     * @memberof ParWithRandom
     * @instance
     */
    ParWithRandom.prototype.body = null;

    /**
     * ParWithRandom randomState.
     * @member {Uint8Array} randomState
     * @memberof ParWithRandom
     * @instance
     */
    ParWithRandom.prototype.randomState = $util.newBuffer([]);

    /**
     * Creates a new ParWithRandom instance using the specified properties.
     * @function create
     * @memberof ParWithRandom
     * @static
     * @param {IParWithRandom=} [properties] Properties to set
     * @returns {ParWithRandom} ParWithRandom instance
     */
    ParWithRandom.create = function create(properties) {
        return new ParWithRandom(properties);
    };

    /**
     * Encodes the specified ParWithRandom message. Does not implicitly {@link ParWithRandom.verify|verify} messages.
     * @function encode
     * @memberof ParWithRandom
     * @static
     * @param {IParWithRandom} message ParWithRandom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParWithRandom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.body != null && message.hasOwnProperty("body"))
            $root.Par.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.randomState != null && message.hasOwnProperty("randomState"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.randomState);
        return writer;
    };

    /**
     * Encodes the specified ParWithRandom message, length delimited. Does not implicitly {@link ParWithRandom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ParWithRandom
     * @static
     * @param {IParWithRandom} message ParWithRandom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParWithRandom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ParWithRandom message from the specified reader or buffer.
     * @function decode
     * @memberof ParWithRandom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ParWithRandom} ParWithRandom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParWithRandom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ParWithRandom();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.body = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.randomState = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ParWithRandom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ParWithRandom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ParWithRandom} ParWithRandom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParWithRandom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ParWithRandom message.
     * @function verify
     * @memberof ParWithRandom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ParWithRandom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.body != null && message.hasOwnProperty("body")) {
            var error = $root.Par.verify(message.body);
            if (error)
                return "body." + error;
        }
        if (message.randomState != null && message.hasOwnProperty("randomState"))
            if (!(message.randomState && typeof message.randomState.length === "number" || $util.isString(message.randomState)))
                return "randomState: buffer expected";
        return null;
    };

    /**
     * Creates a ParWithRandom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ParWithRandom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ParWithRandom} ParWithRandom
     */
    ParWithRandom.fromObject = function fromObject(object) {
        if (object instanceof $root.ParWithRandom)
            return object;
        var message = new $root.ParWithRandom();
        if (object.body != null) {
            if (typeof object.body !== "object")
                throw TypeError(".ParWithRandom.body: object expected");
            message.body = $root.Par.fromObject(object.body);
        }
        if (object.randomState != null)
            if (typeof object.randomState === "string")
                $util.base64.decode(object.randomState, message.randomState = $util.newBuffer($util.base64.length(object.randomState)), 0);
            else if (object.randomState.length)
                message.randomState = object.randomState;
        return message;
    };

    /**
     * Creates a plain object from a ParWithRandom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ParWithRandom
     * @static
     * @param {ParWithRandom} message ParWithRandom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ParWithRandom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.body = null;
            if (options.bytes === String)
                object.randomState = "";
            else {
                object.randomState = [];
                if (options.bytes !== Array)
                    object.randomState = $util.newBuffer(object.randomState);
            }
        }
        if (message.body != null && message.hasOwnProperty("body"))
            object.body = $root.Par.toObject(message.body, options);
        if (message.randomState != null && message.hasOwnProperty("randomState"))
            object.randomState = options.bytes === String ? $util.base64.encode(message.randomState, 0, message.randomState.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomState) : message.randomState;
        return object;
    };

    /**
     * Converts this ParWithRandom to JSON.
     * @function toJSON
     * @memberof ParWithRandom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ParWithRandom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ParWithRandom;
})();

$root.PCost = (function() {

    /**
     * Properties of a PCost.
     * @exports IPCost
     * @interface IPCost
     * @property {number|Long|null} [cost] PCost cost
     */

    /**
     * Constructs a new PCost.
     * @exports PCost
     * @classdesc Cost of the performed operations.
     * @implements IPCost
     * @constructor
     * @param {IPCost=} [properties] Properties to set
     */
    function PCost(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PCost cost.
     * @member {number|Long} cost
     * @memberof PCost
     * @instance
     */
    PCost.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new PCost instance using the specified properties.
     * @function create
     * @memberof PCost
     * @static
     * @param {IPCost=} [properties] Properties to set
     * @returns {PCost} PCost instance
     */
    PCost.create = function create(properties) {
        return new PCost(properties);
    };

    /**
     * Encodes the specified PCost message. Does not implicitly {@link PCost.verify|verify} messages.
     * @function encode
     * @memberof PCost
     * @static
     * @param {IPCost} message PCost message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PCost.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.cost != null && message.hasOwnProperty("cost"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.cost);
        return writer;
    };

    /**
     * Encodes the specified PCost message, length delimited. Does not implicitly {@link PCost.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PCost
     * @static
     * @param {IPCost} message PCost message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PCost.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PCost message from the specified reader or buffer.
     * @function decode
     * @memberof PCost
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PCost} PCost
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PCost.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PCost();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.cost = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PCost message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PCost
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PCost} PCost
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PCost.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PCost message.
     * @function verify
     * @memberof PCost
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PCost.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.cost != null && message.hasOwnProperty("cost"))
            if (!$util.isInteger(message.cost) && !(message.cost && $util.isInteger(message.cost.low) && $util.isInteger(message.cost.high)))
                return "cost: integer|Long expected";
        return null;
    };

    /**
     * Creates a PCost message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PCost
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PCost} PCost
     */
    PCost.fromObject = function fromObject(object) {
        if (object instanceof $root.PCost)
            return object;
        var message = new $root.PCost();
        if (object.cost != null)
            if ($util.Long)
                (message.cost = $util.Long.fromValue(object.cost)).unsigned = true;
            else if (typeof object.cost === "string")
                message.cost = parseInt(object.cost, 10);
            else if (typeof object.cost === "number")
                message.cost = object.cost;
            else if (typeof object.cost === "object")
                message.cost = new $util.LongBits(object.cost.low >>> 0, object.cost.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a PCost message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PCost
     * @static
     * @param {PCost} message PCost
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PCost.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.cost = options.longs === String ? "0" : 0;
        if (message.cost != null && message.hasOwnProperty("cost"))
            if (typeof message.cost === "number")
                object.cost = options.longs === String ? String(message.cost) : message.cost;
            else
                object.cost = options.longs === String ? $util.Long.prototype.toString.call(message.cost) : options.longs === Number ? new $util.LongBits(message.cost.low >>> 0, message.cost.high >>> 0).toNumber(true) : message.cost;
        return object;
    };

    /**
     * Converts this PCost to JSON.
     * @function toJSON
     * @memberof PCost
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PCost.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PCost;
})();

$root.ListParWithRandom = (function() {

    /**
     * Properties of a ListParWithRandom.
     * @exports IListParWithRandom
     * @interface IListParWithRandom
     * @property {Array.<IPar>|null} [pars] ListParWithRandom pars
     * @property {Uint8Array|null} [randomState] ListParWithRandom randomState
     */

    /**
     * Constructs a new ListParWithRandom.
     * @exports ListParWithRandom
     * @classdesc Represents a ListParWithRandom.
     * @implements IListParWithRandom
     * @constructor
     * @param {IListParWithRandom=} [properties] Properties to set
     */
    function ListParWithRandom(properties) {
        this.pars = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListParWithRandom pars.
     * @member {Array.<IPar>} pars
     * @memberof ListParWithRandom
     * @instance
     */
    ListParWithRandom.prototype.pars = $util.emptyArray;

    /**
     * ListParWithRandom randomState.
     * @member {Uint8Array} randomState
     * @memberof ListParWithRandom
     * @instance
     */
    ListParWithRandom.prototype.randomState = $util.newBuffer([]);

    /**
     * Creates a new ListParWithRandom instance using the specified properties.
     * @function create
     * @memberof ListParWithRandom
     * @static
     * @param {IListParWithRandom=} [properties] Properties to set
     * @returns {ListParWithRandom} ListParWithRandom instance
     */
    ListParWithRandom.create = function create(properties) {
        return new ListParWithRandom(properties);
    };

    /**
     * Encodes the specified ListParWithRandom message. Does not implicitly {@link ListParWithRandom.verify|verify} messages.
     * @function encode
     * @memberof ListParWithRandom
     * @static
     * @param {IListParWithRandom} message ListParWithRandom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListParWithRandom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pars != null && message.pars.length)
            for (var i = 0; i < message.pars.length; ++i)
                $root.Par.encode(message.pars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.randomState != null && message.hasOwnProperty("randomState"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.randomState);
        return writer;
    };

    /**
     * Encodes the specified ListParWithRandom message, length delimited. Does not implicitly {@link ListParWithRandom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListParWithRandom
     * @static
     * @param {IListParWithRandom} message ListParWithRandom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListParWithRandom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListParWithRandom message from the specified reader or buffer.
     * @function decode
     * @memberof ListParWithRandom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListParWithRandom} ListParWithRandom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListParWithRandom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListParWithRandom();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.pars && message.pars.length))
                    message.pars = [];
                message.pars.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 2:
                message.randomState = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListParWithRandom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListParWithRandom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListParWithRandom} ListParWithRandom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListParWithRandom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListParWithRandom message.
     * @function verify
     * @memberof ListParWithRandom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListParWithRandom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pars != null && message.hasOwnProperty("pars")) {
            if (!Array.isArray(message.pars))
                return "pars: array expected";
            for (var i = 0; i < message.pars.length; ++i) {
                var error = $root.Par.verify(message.pars[i]);
                if (error)
                    return "pars." + error;
            }
        }
        if (message.randomState != null && message.hasOwnProperty("randomState"))
            if (!(message.randomState && typeof message.randomState.length === "number" || $util.isString(message.randomState)))
                return "randomState: buffer expected";
        return null;
    };

    /**
     * Creates a ListParWithRandom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListParWithRandom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListParWithRandom} ListParWithRandom
     */
    ListParWithRandom.fromObject = function fromObject(object) {
        if (object instanceof $root.ListParWithRandom)
            return object;
        var message = new $root.ListParWithRandom();
        if (object.pars) {
            if (!Array.isArray(object.pars))
                throw TypeError(".ListParWithRandom.pars: array expected");
            message.pars = [];
            for (var i = 0; i < object.pars.length; ++i) {
                if (typeof object.pars[i] !== "object")
                    throw TypeError(".ListParWithRandom.pars: object expected");
                message.pars[i] = $root.Par.fromObject(object.pars[i]);
            }
        }
        if (object.randomState != null)
            if (typeof object.randomState === "string")
                $util.base64.decode(object.randomState, message.randomState = $util.newBuffer($util.base64.length(object.randomState)), 0);
            else if (object.randomState.length)
                message.randomState = object.randomState;
        return message;
    };

    /**
     * Creates a plain object from a ListParWithRandom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListParWithRandom
     * @static
     * @param {ListParWithRandom} message ListParWithRandom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListParWithRandom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.pars = [];
        if (options.defaults)
            if (options.bytes === String)
                object.randomState = "";
            else {
                object.randomState = [];
                if (options.bytes !== Array)
                    object.randomState = $util.newBuffer(object.randomState);
            }
        if (message.pars && message.pars.length) {
            object.pars = [];
            for (var j = 0; j < message.pars.length; ++j)
                object.pars[j] = $root.Par.toObject(message.pars[j], options);
        }
        if (message.randomState != null && message.hasOwnProperty("randomState"))
            object.randomState = options.bytes === String ? $util.base64.encode(message.randomState, 0, message.randomState.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomState) : message.randomState;
        return object;
    };

    /**
     * Converts this ListParWithRandom to JSON.
     * @function toJSON
     * @memberof ListParWithRandom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListParWithRandom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListParWithRandom;
})();

$root.Var = (function() {

    /**
     * Properties of a Var.
     * @exports IVar
     * @interface IVar
     * @property {number|null} [bound_var] Var bound_var
     * @property {number|null} [free_var] Var free_var
     * @property {Var.IWildcardMsg|null} [wildcard] Var wildcard
     */

    /**
     * Constructs a new Var.
     * @exports Var
     * @classdesc Represents a Var.
     * @implements IVar
     * @constructor
     * @param {IVar=} [properties] Properties to set
     */
    function Var(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Var bound_var.
     * @member {number} bound_var
     * @memberof Var
     * @instance
     */
    Var.prototype.bound_var = 0;

    /**
     * Var free_var.
     * @member {number} free_var
     * @memberof Var
     * @instance
     */
    Var.prototype.free_var = 0;

    /**
     * Var wildcard.
     * @member {Var.IWildcardMsg|null|undefined} wildcard
     * @memberof Var
     * @instance
     */
    Var.prototype.wildcard = null;

    // OneOf field names bound to virtual getters and setters
    var $oneOfFields;

    /**
     * Var var_instance.
     * @member {"bound_var"|"free_var"|"wildcard"|undefined} var_instance
     * @memberof Var
     * @instance
     */
    Object.defineProperty(Var.prototype, "var_instance", {
        get: $util.oneOfGetter($oneOfFields = ["bound_var", "free_var", "wildcard"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new Var instance using the specified properties.
     * @function create
     * @memberof Var
     * @static
     * @param {IVar=} [properties] Properties to set
     * @returns {Var} Var instance
     */
    Var.create = function create(properties) {
        return new Var(properties);
    };

    /**
     * Encodes the specified Var message. Does not implicitly {@link Var.verify|verify} messages.
     * @function encode
     * @memberof Var
     * @static
     * @param {IVar} message Var message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Var.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bound_var != null && message.hasOwnProperty("bound_var"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.bound_var);
        if (message.free_var != null && message.hasOwnProperty("free_var"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.free_var);
        if (message.wildcard != null && message.hasOwnProperty("wildcard"))
            $root.Var.WildcardMsg.encode(message.wildcard, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Var message, length delimited. Does not implicitly {@link Var.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Var
     * @static
     * @param {IVar} message Var message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Var.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Var message from the specified reader or buffer.
     * @function decode
     * @memberof Var
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Var} Var
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Var.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Var();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bound_var = reader.sint32();
                break;
            case 2:
                message.free_var = reader.sint32();
                break;
            case 3:
                message.wildcard = $root.Var.WildcardMsg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Var message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Var
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Var} Var
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Var.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Var message.
     * @function verify
     * @memberof Var
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Var.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        var properties = {};
        if (message.bound_var != null && message.hasOwnProperty("bound_var")) {
            properties.var_instance = 1;
            if (!$util.isInteger(message.bound_var))
                return "bound_var: integer expected";
        }
        if (message.free_var != null && message.hasOwnProperty("free_var")) {
            if (properties.var_instance === 1)
                return "var_instance: multiple values";
            properties.var_instance = 1;
            if (!$util.isInteger(message.free_var))
                return "free_var: integer expected";
        }
        if (message.wildcard != null && message.hasOwnProperty("wildcard")) {
            if (properties.var_instance === 1)
                return "var_instance: multiple values";
            properties.var_instance = 1;
            {
                var error = $root.Var.WildcardMsg.verify(message.wildcard);
                if (error)
                    return "wildcard." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Var message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Var
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Var} Var
     */
    Var.fromObject = function fromObject(object) {
        if (object instanceof $root.Var)
            return object;
        var message = new $root.Var();
        if (object.bound_var != null)
            message.bound_var = object.bound_var | 0;
        if (object.free_var != null)
            message.free_var = object.free_var | 0;
        if (object.wildcard != null) {
            if (typeof object.wildcard !== "object")
                throw TypeError(".Var.wildcard: object expected");
            message.wildcard = $root.Var.WildcardMsg.fromObject(object.wildcard);
        }
        return message;
    };

    /**
     * Creates a plain object from a Var message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Var
     * @static
     * @param {Var} message Var
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Var.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (message.bound_var != null && message.hasOwnProperty("bound_var")) {
            object.bound_var = message.bound_var;
            if (options.oneofs)
                object.var_instance = "bound_var";
        }
        if (message.free_var != null && message.hasOwnProperty("free_var")) {
            object.free_var = message.free_var;
            if (options.oneofs)
                object.var_instance = "free_var";
        }
        if (message.wildcard != null && message.hasOwnProperty("wildcard")) {
            object.wildcard = $root.Var.WildcardMsg.toObject(message.wildcard, options);
            if (options.oneofs)
                object.var_instance = "wildcard";
        }
        return object;
    };

    /**
     * Converts this Var to JSON.
     * @function toJSON
     * @memberof Var
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Var.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Var.WildcardMsg = (function() {

        /**
         * Properties of a WildcardMsg.
         * @memberof Var
         * @interface IWildcardMsg
         */

        /**
         * Constructs a new WildcardMsg.
         * @memberof Var
         * @classdesc Represents a WildcardMsg.
         * @implements IWildcardMsg
         * @constructor
         * @param {Var.IWildcardMsg=} [properties] Properties to set
         */
        function WildcardMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WildcardMsg instance using the specified properties.
         * @function create
         * @memberof Var.WildcardMsg
         * @static
         * @param {Var.IWildcardMsg=} [properties] Properties to set
         * @returns {Var.WildcardMsg} WildcardMsg instance
         */
        WildcardMsg.create = function create(properties) {
            return new WildcardMsg(properties);
        };

        /**
         * Encodes the specified WildcardMsg message. Does not implicitly {@link Var.WildcardMsg.verify|verify} messages.
         * @function encode
         * @memberof Var.WildcardMsg
         * @static
         * @param {Var.IWildcardMsg} message WildcardMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WildcardMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WildcardMsg message, length delimited. Does not implicitly {@link Var.WildcardMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Var.WildcardMsg
         * @static
         * @param {Var.IWildcardMsg} message WildcardMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WildcardMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WildcardMsg message from the specified reader or buffer.
         * @function decode
         * @memberof Var.WildcardMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Var.WildcardMsg} WildcardMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WildcardMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Var.WildcardMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WildcardMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Var.WildcardMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Var.WildcardMsg} WildcardMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WildcardMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WildcardMsg message.
         * @function verify
         * @memberof Var.WildcardMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WildcardMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WildcardMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Var.WildcardMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Var.WildcardMsg} WildcardMsg
         */
        WildcardMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.Var.WildcardMsg)
                return object;
            return new $root.Var.WildcardMsg();
        };

        /**
         * Creates a plain object from a WildcardMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Var.WildcardMsg
         * @static
         * @param {Var.WildcardMsg} message WildcardMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WildcardMsg.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WildcardMsg to JSON.
         * @function toJSON
         * @memberof Var.WildcardMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WildcardMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WildcardMsg;
    })();

    return Var;
})();

$root.Bundle = (function() {

    /**
     * Properties of a Bundle.
     * @exports IBundle
     * @interface IBundle
     * @property {IPar|null} [body] Bundle body
     * @property {boolean|null} [writeFlag] Bundle writeFlag
     * @property {boolean|null} [readFlag] Bundle readFlag
     */

    /**
     * Constructs a new Bundle.
     * @exports Bundle
     * @classdesc Nothing can be received from a (quoted) bundle with `readFlag = false`.
     * Likeise nothing can be sent to a (quoted) bundle with `writeFlag = false`.
     * 
     * If both flags are set to false, bundle allows only for equivalance check.
     * @implements IBundle
     * @constructor
     * @param {IBundle=} [properties] Properties to set
     */
    function Bundle(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Bundle body.
     * @member {IPar|null|undefined} body
     * @memberof Bundle
     * @instance
     */
    Bundle.prototype.body = null;

    /**
     * Bundle writeFlag.
     * @member {boolean} writeFlag
     * @memberof Bundle
     * @instance
     */
    Bundle.prototype.writeFlag = false;

    /**
     * Bundle readFlag.
     * @member {boolean} readFlag
     * @memberof Bundle
     * @instance
     */
    Bundle.prototype.readFlag = false;

    /**
     * Creates a new Bundle instance using the specified properties.
     * @function create
     * @memberof Bundle
     * @static
     * @param {IBundle=} [properties] Properties to set
     * @returns {Bundle} Bundle instance
     */
    Bundle.create = function create(properties) {
        return new Bundle(properties);
    };

    /**
     * Encodes the specified Bundle message. Does not implicitly {@link Bundle.verify|verify} messages.
     * @function encode
     * @memberof Bundle
     * @static
     * @param {IBundle} message Bundle message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Bundle.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.body != null && message.hasOwnProperty("body"))
            $root.Par.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.writeFlag != null && message.hasOwnProperty("writeFlag"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.writeFlag);
        if (message.readFlag != null && message.hasOwnProperty("readFlag"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readFlag);
        return writer;
    };

    /**
     * Encodes the specified Bundle message, length delimited. Does not implicitly {@link Bundle.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Bundle
     * @static
     * @param {IBundle} message Bundle message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Bundle.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Bundle message from the specified reader or buffer.
     * @function decode
     * @memberof Bundle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Bundle} Bundle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Bundle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Bundle();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.body = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.writeFlag = reader.bool();
                break;
            case 3:
                message.readFlag = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Bundle message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Bundle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Bundle} Bundle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Bundle.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Bundle message.
     * @function verify
     * @memberof Bundle
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Bundle.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.body != null && message.hasOwnProperty("body")) {
            var error = $root.Par.verify(message.body);
            if (error)
                return "body." + error;
        }
        if (message.writeFlag != null && message.hasOwnProperty("writeFlag"))
            if (typeof message.writeFlag !== "boolean")
                return "writeFlag: boolean expected";
        if (message.readFlag != null && message.hasOwnProperty("readFlag"))
            if (typeof message.readFlag !== "boolean")
                return "readFlag: boolean expected";
        return null;
    };

    /**
     * Creates a Bundle message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Bundle
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Bundle} Bundle
     */
    Bundle.fromObject = function fromObject(object) {
        if (object instanceof $root.Bundle)
            return object;
        var message = new $root.Bundle();
        if (object.body != null) {
            if (typeof object.body !== "object")
                throw TypeError(".Bundle.body: object expected");
            message.body = $root.Par.fromObject(object.body);
        }
        if (object.writeFlag != null)
            message.writeFlag = Boolean(object.writeFlag);
        if (object.readFlag != null)
            message.readFlag = Boolean(object.readFlag);
        return message;
    };

    /**
     * Creates a plain object from a Bundle message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Bundle
     * @static
     * @param {Bundle} message Bundle
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Bundle.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.body = null;
            object.writeFlag = false;
            object.readFlag = false;
        }
        if (message.body != null && message.hasOwnProperty("body"))
            object.body = $root.Par.toObject(message.body, options);
        if (message.writeFlag != null && message.hasOwnProperty("writeFlag"))
            object.writeFlag = message.writeFlag;
        if (message.readFlag != null && message.hasOwnProperty("readFlag"))
            object.readFlag = message.readFlag;
        return object;
    };

    /**
     * Converts this Bundle to JSON.
     * @function toJSON
     * @memberof Bundle
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Bundle.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Bundle;
})();

$root.Send = (function() {

    /**
     * Properties of a Send.
     * @exports ISend
     * @interface ISend
     * @property {IPar|null} [chan] Send chan
     * @property {Array.<IPar>|null} [data] Send data
     * @property {boolean|null} [persistent] Send persistent
     * @property {Uint8Array|null} [locallyFree] Send locallyFree
     * @property {boolean|null} [connective_used] Send connective_used
     */

    /**
     * Constructs a new Send.
     * @exports Send
     * @classdesc A send is written `chan!(data)` or `chan!!(data)` for a persistent send.
     * 
     * Upon send, all free variables in data are substituted with their values.
     * @implements ISend
     * @constructor
     * @param {ISend=} [properties] Properties to set
     */
    function Send(properties) {
        this.data = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Send chan.
     * @member {IPar|null|undefined} chan
     * @memberof Send
     * @instance
     */
    Send.prototype.chan = null;

    /**
     * Send data.
     * @member {Array.<IPar>} data
     * @memberof Send
     * @instance
     */
    Send.prototype.data = $util.emptyArray;

    /**
     * Send persistent.
     * @member {boolean} persistent
     * @memberof Send
     * @instance
     */
    Send.prototype.persistent = false;

    /**
     * Send locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof Send
     * @instance
     */
    Send.prototype.locallyFree = $util.newBuffer([]);

    /**
     * Send connective_used.
     * @member {boolean} connective_used
     * @memberof Send
     * @instance
     */
    Send.prototype.connective_used = false;

    /**
     * Creates a new Send instance using the specified properties.
     * @function create
     * @memberof Send
     * @static
     * @param {ISend=} [properties] Properties to set
     * @returns {Send} Send instance
     */
    Send.create = function create(properties) {
        return new Send(properties);
    };

    /**
     * Encodes the specified Send message. Does not implicitly {@link Send.verify|verify} messages.
     * @function encode
     * @memberof Send
     * @static
     * @param {ISend} message Send message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Send.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chan != null && message.hasOwnProperty("chan"))
            $root.Par.encode(message.chan, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.data != null && message.data.length)
            for (var i = 0; i < message.data.length; ++i)
                $root.Par.encode(message.data[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.persistent != null && message.hasOwnProperty("persistent"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.connective_used);
        return writer;
    };

    /**
     * Encodes the specified Send message, length delimited. Does not implicitly {@link Send.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Send
     * @static
     * @param {ISend} message Send message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Send.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Send message from the specified reader or buffer.
     * @function decode
     * @memberof Send
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Send} Send
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Send.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Send();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chan = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.data && message.data.length))
                    message.data = [];
                message.data.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 3:
                message.persistent = reader.bool();
                break;
            case 5:
                message.locallyFree = reader.bytes();
                break;
            case 6:
                message.connective_used = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Send message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Send
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Send} Send
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Send.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Send message.
     * @function verify
     * @memberof Send
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Send.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chan != null && message.hasOwnProperty("chan")) {
            var error = $root.Par.verify(message.chan);
            if (error)
                return "chan." + error;
        }
        if (message.data != null && message.hasOwnProperty("data")) {
            if (!Array.isArray(message.data))
                return "data: array expected";
            for (var i = 0; i < message.data.length; ++i) {
                var error = $root.Par.verify(message.data[i]);
                if (error)
                    return "data." + error;
            }
        }
        if (message.persistent != null && message.hasOwnProperty("persistent"))
            if (typeof message.persistent !== "boolean")
                return "persistent: boolean expected";
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        return null;
    };

    /**
     * Creates a Send message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Send
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Send} Send
     */
    Send.fromObject = function fromObject(object) {
        if (object instanceof $root.Send)
            return object;
        var message = new $root.Send();
        if (object.chan != null) {
            if (typeof object.chan !== "object")
                throw TypeError(".Send.chan: object expected");
            message.chan = $root.Par.fromObject(object.chan);
        }
        if (object.data) {
            if (!Array.isArray(object.data))
                throw TypeError(".Send.data: array expected");
            message.data = [];
            for (var i = 0; i < object.data.length; ++i) {
                if (typeof object.data[i] !== "object")
                    throw TypeError(".Send.data: object expected");
                message.data[i] = $root.Par.fromObject(object.data[i]);
            }
        }
        if (object.persistent != null)
            message.persistent = Boolean(object.persistent);
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        return message;
    };

    /**
     * Creates a plain object from a Send message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Send
     * @static
     * @param {Send} message Send
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Send.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.data = [];
        if (options.defaults) {
            object.chan = null;
            object.persistent = false;
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
        }
        if (message.chan != null && message.hasOwnProperty("chan"))
            object.chan = $root.Par.toObject(message.chan, options);
        if (message.data && message.data.length) {
            object.data = [];
            for (var j = 0; j < message.data.length; ++j)
                object.data[j] = $root.Par.toObject(message.data[j], options);
        }
        if (message.persistent != null && message.hasOwnProperty("persistent"))
            object.persistent = message.persistent;
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        return object;
    };

    /**
     * Converts this Send to JSON.
     * @function toJSON
     * @memberof Send
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Send.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Send;
})();

$root.ReceiveBind = (function() {

    /**
     * Properties of a ReceiveBind.
     * @exports IReceiveBind
     * @interface IReceiveBind
     * @property {Array.<IPar>|null} [patterns] ReceiveBind patterns
     * @property {IPar|null} [source] ReceiveBind source
     * @property {IVar|null} [remainder] ReceiveBind remainder
     * @property {number|null} [freeCount] ReceiveBind freeCount
     */

    /**
     * Constructs a new ReceiveBind.
     * @exports ReceiveBind
     * @classdesc Represents a ReceiveBind.
     * @implements IReceiveBind
     * @constructor
     * @param {IReceiveBind=} [properties] Properties to set
     */
    function ReceiveBind(properties) {
        this.patterns = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReceiveBind patterns.
     * @member {Array.<IPar>} patterns
     * @memberof ReceiveBind
     * @instance
     */
    ReceiveBind.prototype.patterns = $util.emptyArray;

    /**
     * ReceiveBind source.
     * @member {IPar|null|undefined} source
     * @memberof ReceiveBind
     * @instance
     */
    ReceiveBind.prototype.source = null;

    /**
     * ReceiveBind remainder.
     * @member {IVar|null|undefined} remainder
     * @memberof ReceiveBind
     * @instance
     */
    ReceiveBind.prototype.remainder = null;

    /**
     * ReceiveBind freeCount.
     * @member {number} freeCount
     * @memberof ReceiveBind
     * @instance
     */
    ReceiveBind.prototype.freeCount = 0;

    /**
     * Creates a new ReceiveBind instance using the specified properties.
     * @function create
     * @memberof ReceiveBind
     * @static
     * @param {IReceiveBind=} [properties] Properties to set
     * @returns {ReceiveBind} ReceiveBind instance
     */
    ReceiveBind.create = function create(properties) {
        return new ReceiveBind(properties);
    };

    /**
     * Encodes the specified ReceiveBind message. Does not implicitly {@link ReceiveBind.verify|verify} messages.
     * @function encode
     * @memberof ReceiveBind
     * @static
     * @param {IReceiveBind} message ReceiveBind message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReceiveBind.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.patterns != null && message.patterns.length)
            for (var i = 0; i < message.patterns.length; ++i)
                $root.Par.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.source != null && message.hasOwnProperty("source"))
            $root.Par.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            $root.Var.encode(message.remainder, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.freeCount);
        return writer;
    };

    /**
     * Encodes the specified ReceiveBind message, length delimited. Does not implicitly {@link ReceiveBind.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReceiveBind
     * @static
     * @param {IReceiveBind} message ReceiveBind message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReceiveBind.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReceiveBind message from the specified reader or buffer.
     * @function decode
     * @memberof ReceiveBind
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReceiveBind} ReceiveBind
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReceiveBind.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReceiveBind();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.patterns && message.patterns.length))
                    message.patterns = [];
                message.patterns.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 2:
                message.source = $root.Par.decode(reader, reader.uint32());
                break;
            case 3:
                message.remainder = $root.Var.decode(reader, reader.uint32());
                break;
            case 4:
                message.freeCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReceiveBind message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReceiveBind
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReceiveBind} ReceiveBind
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReceiveBind.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReceiveBind message.
     * @function verify
     * @memberof ReceiveBind
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReceiveBind.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.patterns != null && message.hasOwnProperty("patterns")) {
            if (!Array.isArray(message.patterns))
                return "patterns: array expected";
            for (var i = 0; i < message.patterns.length; ++i) {
                var error = $root.Par.verify(message.patterns[i]);
                if (error)
                    return "patterns." + error;
            }
        }
        if (message.source != null && message.hasOwnProperty("source")) {
            var error = $root.Par.verify(message.source);
            if (error)
                return "source." + error;
        }
        if (message.remainder != null && message.hasOwnProperty("remainder")) {
            var error = $root.Var.verify(message.remainder);
            if (error)
                return "remainder." + error;
        }
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            if (!$util.isInteger(message.freeCount))
                return "freeCount: integer expected";
        return null;
    };

    /**
     * Creates a ReceiveBind message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReceiveBind
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReceiveBind} ReceiveBind
     */
    ReceiveBind.fromObject = function fromObject(object) {
        if (object instanceof $root.ReceiveBind)
            return object;
        var message = new $root.ReceiveBind();
        if (object.patterns) {
            if (!Array.isArray(object.patterns))
                throw TypeError(".ReceiveBind.patterns: array expected");
            message.patterns = [];
            for (var i = 0; i < object.patterns.length; ++i) {
                if (typeof object.patterns[i] !== "object")
                    throw TypeError(".ReceiveBind.patterns: object expected");
                message.patterns[i] = $root.Par.fromObject(object.patterns[i]);
            }
        }
        if (object.source != null) {
            if (typeof object.source !== "object")
                throw TypeError(".ReceiveBind.source: object expected");
            message.source = $root.Par.fromObject(object.source);
        }
        if (object.remainder != null) {
            if (typeof object.remainder !== "object")
                throw TypeError(".ReceiveBind.remainder: object expected");
            message.remainder = $root.Var.fromObject(object.remainder);
        }
        if (object.freeCount != null)
            message.freeCount = object.freeCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a ReceiveBind message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReceiveBind
     * @static
     * @param {ReceiveBind} message ReceiveBind
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReceiveBind.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.patterns = [];
        if (options.defaults) {
            object.source = null;
            object.remainder = null;
            object.freeCount = 0;
        }
        if (message.patterns && message.patterns.length) {
            object.patterns = [];
            for (var j = 0; j < message.patterns.length; ++j)
                object.patterns[j] = $root.Par.toObject(message.patterns[j], options);
        }
        if (message.source != null && message.hasOwnProperty("source"))
            object.source = $root.Par.toObject(message.source, options);
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            object.remainder = $root.Var.toObject(message.remainder, options);
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            object.freeCount = message.freeCount;
        return object;
    };

    /**
     * Converts this ReceiveBind to JSON.
     * @function toJSON
     * @memberof ReceiveBind
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReceiveBind.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReceiveBind;
})();

$root.BindPattern = (function() {

    /**
     * Properties of a BindPattern.
     * @exports IBindPattern
     * @interface IBindPattern
     * @property {Array.<IPar>|null} [patterns] BindPattern patterns
     * @property {IVar|null} [remainder] BindPattern remainder
     * @property {number|null} [freeCount] BindPattern freeCount
     */

    /**
     * Constructs a new BindPattern.
     * @exports BindPattern
     * @classdesc Represents a BindPattern.
     * @implements IBindPattern
     * @constructor
     * @param {IBindPattern=} [properties] Properties to set
     */
    function BindPattern(properties) {
        this.patterns = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BindPattern patterns.
     * @member {Array.<IPar>} patterns
     * @memberof BindPattern
     * @instance
     */
    BindPattern.prototype.patterns = $util.emptyArray;

    /**
     * BindPattern remainder.
     * @member {IVar|null|undefined} remainder
     * @memberof BindPattern
     * @instance
     */
    BindPattern.prototype.remainder = null;

    /**
     * BindPattern freeCount.
     * @member {number} freeCount
     * @memberof BindPattern
     * @instance
     */
    BindPattern.prototype.freeCount = 0;

    /**
     * Creates a new BindPattern instance using the specified properties.
     * @function create
     * @memberof BindPattern
     * @static
     * @param {IBindPattern=} [properties] Properties to set
     * @returns {BindPattern} BindPattern instance
     */
    BindPattern.create = function create(properties) {
        return new BindPattern(properties);
    };

    /**
     * Encodes the specified BindPattern message. Does not implicitly {@link BindPattern.verify|verify} messages.
     * @function encode
     * @memberof BindPattern
     * @static
     * @param {IBindPattern} message BindPattern message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BindPattern.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.patterns != null && message.patterns.length)
            for (var i = 0; i < message.patterns.length; ++i)
                $root.Par.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            $root.Var.encode(message.remainder, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.freeCount);
        return writer;
    };

    /**
     * Encodes the specified BindPattern message, length delimited. Does not implicitly {@link BindPattern.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BindPattern
     * @static
     * @param {IBindPattern} message BindPattern message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BindPattern.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BindPattern message from the specified reader or buffer.
     * @function decode
     * @memberof BindPattern
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BindPattern} BindPattern
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BindPattern.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BindPattern();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.patterns && message.patterns.length))
                    message.patterns = [];
                message.patterns.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 2:
                message.remainder = $root.Var.decode(reader, reader.uint32());
                break;
            case 3:
                message.freeCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BindPattern message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BindPattern
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BindPattern} BindPattern
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BindPattern.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BindPattern message.
     * @function verify
     * @memberof BindPattern
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BindPattern.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.patterns != null && message.hasOwnProperty("patterns")) {
            if (!Array.isArray(message.patterns))
                return "patterns: array expected";
            for (var i = 0; i < message.patterns.length; ++i) {
                var error = $root.Par.verify(message.patterns[i]);
                if (error)
                    return "patterns." + error;
            }
        }
        if (message.remainder != null && message.hasOwnProperty("remainder")) {
            var error = $root.Var.verify(message.remainder);
            if (error)
                return "remainder." + error;
        }
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            if (!$util.isInteger(message.freeCount))
                return "freeCount: integer expected";
        return null;
    };

    /**
     * Creates a BindPattern message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BindPattern
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BindPattern} BindPattern
     */
    BindPattern.fromObject = function fromObject(object) {
        if (object instanceof $root.BindPattern)
            return object;
        var message = new $root.BindPattern();
        if (object.patterns) {
            if (!Array.isArray(object.patterns))
                throw TypeError(".BindPattern.patterns: array expected");
            message.patterns = [];
            for (var i = 0; i < object.patterns.length; ++i) {
                if (typeof object.patterns[i] !== "object")
                    throw TypeError(".BindPattern.patterns: object expected");
                message.patterns[i] = $root.Par.fromObject(object.patterns[i]);
            }
        }
        if (object.remainder != null) {
            if (typeof object.remainder !== "object")
                throw TypeError(".BindPattern.remainder: object expected");
            message.remainder = $root.Var.fromObject(object.remainder);
        }
        if (object.freeCount != null)
            message.freeCount = object.freeCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a BindPattern message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BindPattern
     * @static
     * @param {BindPattern} message BindPattern
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BindPattern.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.patterns = [];
        if (options.defaults) {
            object.remainder = null;
            object.freeCount = 0;
        }
        if (message.patterns && message.patterns.length) {
            object.patterns = [];
            for (var j = 0; j < message.patterns.length; ++j)
                object.patterns[j] = $root.Par.toObject(message.patterns[j], options);
        }
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            object.remainder = $root.Var.toObject(message.remainder, options);
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            object.freeCount = message.freeCount;
        return object;
    };

    /**
     * Converts this BindPattern to JSON.
     * @function toJSON
     * @memberof BindPattern
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BindPattern.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BindPattern;
})();

$root.ListBindPatterns = (function() {

    /**
     * Properties of a ListBindPatterns.
     * @exports IListBindPatterns
     * @interface IListBindPatterns
     * @property {Array.<IBindPattern>|null} [patterns] ListBindPatterns patterns
     */

    /**
     * Constructs a new ListBindPatterns.
     * @exports ListBindPatterns
     * @classdesc Represents a ListBindPatterns.
     * @implements IListBindPatterns
     * @constructor
     * @param {IListBindPatterns=} [properties] Properties to set
     */
    function ListBindPatterns(properties) {
        this.patterns = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListBindPatterns patterns.
     * @member {Array.<IBindPattern>} patterns
     * @memberof ListBindPatterns
     * @instance
     */
    ListBindPatterns.prototype.patterns = $util.emptyArray;

    /**
     * Creates a new ListBindPatterns instance using the specified properties.
     * @function create
     * @memberof ListBindPatterns
     * @static
     * @param {IListBindPatterns=} [properties] Properties to set
     * @returns {ListBindPatterns} ListBindPatterns instance
     */
    ListBindPatterns.create = function create(properties) {
        return new ListBindPatterns(properties);
    };

    /**
     * Encodes the specified ListBindPatterns message. Does not implicitly {@link ListBindPatterns.verify|verify} messages.
     * @function encode
     * @memberof ListBindPatterns
     * @static
     * @param {IListBindPatterns} message ListBindPatterns message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBindPatterns.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.patterns != null && message.patterns.length)
            for (var i = 0; i < message.patterns.length; ++i)
                $root.BindPattern.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListBindPatterns message, length delimited. Does not implicitly {@link ListBindPatterns.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListBindPatterns
     * @static
     * @param {IListBindPatterns} message ListBindPatterns message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBindPatterns.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListBindPatterns message from the specified reader or buffer.
     * @function decode
     * @memberof ListBindPatterns
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListBindPatterns} ListBindPatterns
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBindPatterns.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListBindPatterns();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.patterns && message.patterns.length))
                    message.patterns = [];
                message.patterns.push($root.BindPattern.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListBindPatterns message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListBindPatterns
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListBindPatterns} ListBindPatterns
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBindPatterns.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListBindPatterns message.
     * @function verify
     * @memberof ListBindPatterns
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListBindPatterns.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.patterns != null && message.hasOwnProperty("patterns")) {
            if (!Array.isArray(message.patterns))
                return "patterns: array expected";
            for (var i = 0; i < message.patterns.length; ++i) {
                var error = $root.BindPattern.verify(message.patterns[i]);
                if (error)
                    return "patterns." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListBindPatterns message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListBindPatterns
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListBindPatterns} ListBindPatterns
     */
    ListBindPatterns.fromObject = function fromObject(object) {
        if (object instanceof $root.ListBindPatterns)
            return object;
        var message = new $root.ListBindPatterns();
        if (object.patterns) {
            if (!Array.isArray(object.patterns))
                throw TypeError(".ListBindPatterns.patterns: array expected");
            message.patterns = [];
            for (var i = 0; i < object.patterns.length; ++i) {
                if (typeof object.patterns[i] !== "object")
                    throw TypeError(".ListBindPatterns.patterns: object expected");
                message.patterns[i] = $root.BindPattern.fromObject(object.patterns[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListBindPatterns message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListBindPatterns
     * @static
     * @param {ListBindPatterns} message ListBindPatterns
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListBindPatterns.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.patterns = [];
        if (message.patterns && message.patterns.length) {
            object.patterns = [];
            for (var j = 0; j < message.patterns.length; ++j)
                object.patterns[j] = $root.BindPattern.toObject(message.patterns[j], options);
        }
        return object;
    };

    /**
     * Converts this ListBindPatterns to JSON.
     * @function toJSON
     * @memberof ListBindPatterns
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListBindPatterns.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListBindPatterns;
})();

$root.Receive = (function() {

    /**
     * Properties of a Receive.
     * @exports IReceive
     * @interface IReceive
     * @property {Array.<IReceiveBind>|null} [binds] Receive binds
     * @property {IPar|null} [body] Receive body
     * @property {boolean|null} [persistent] Receive persistent
     * @property {boolean|null} [peek] Receive peek
     * @property {number|null} [bindCount] Receive bindCount
     * @property {Uint8Array|null} [locallyFree] Receive locallyFree
     * @property {boolean|null} [connective_used] Receive connective_used
     */

    /**
     * Constructs a new Receive.
     * @exports Receive
     * @classdesc A receive is written `for(binds) { body }`
     * i.e. `for(patterns <- source) { body }`
     * or for a persistent recieve: `for(patterns <= source) { body }`.
     * 
     * It's an error for free Variable to occur more than once in a pattern.
     * @implements IReceive
     * @constructor
     * @param {IReceive=} [properties] Properties to set
     */
    function Receive(properties) {
        this.binds = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Receive binds.
     * @member {Array.<IReceiveBind>} binds
     * @memberof Receive
     * @instance
     */
    Receive.prototype.binds = $util.emptyArray;

    /**
     * Receive body.
     * @member {IPar|null|undefined} body
     * @memberof Receive
     * @instance
     */
    Receive.prototype.body = null;

    /**
     * Receive persistent.
     * @member {boolean} persistent
     * @memberof Receive
     * @instance
     */
    Receive.prototype.persistent = false;

    /**
     * Receive peek.
     * @member {boolean} peek
     * @memberof Receive
     * @instance
     */
    Receive.prototype.peek = false;

    /**
     * Receive bindCount.
     * @member {number} bindCount
     * @memberof Receive
     * @instance
     */
    Receive.prototype.bindCount = 0;

    /**
     * Receive locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof Receive
     * @instance
     */
    Receive.prototype.locallyFree = $util.newBuffer([]);

    /**
     * Receive connective_used.
     * @member {boolean} connective_used
     * @memberof Receive
     * @instance
     */
    Receive.prototype.connective_used = false;

    /**
     * Creates a new Receive instance using the specified properties.
     * @function create
     * @memberof Receive
     * @static
     * @param {IReceive=} [properties] Properties to set
     * @returns {Receive} Receive instance
     */
    Receive.create = function create(properties) {
        return new Receive(properties);
    };

    /**
     * Encodes the specified Receive message. Does not implicitly {@link Receive.verify|verify} messages.
     * @function encode
     * @memberof Receive
     * @static
     * @param {IReceive} message Receive message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Receive.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.binds != null && message.binds.length)
            for (var i = 0; i < message.binds.length; ++i)
                $root.ReceiveBind.encode(message.binds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.body != null && message.hasOwnProperty("body"))
            $root.Par.encode(message.body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.persistent != null && message.hasOwnProperty("persistent"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
        if (message.peek != null && message.hasOwnProperty("peek"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.peek);
        if (message.bindCount != null && message.hasOwnProperty("bindCount"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.bindCount);
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.connective_used);
        return writer;
    };

    /**
     * Encodes the specified Receive message, length delimited. Does not implicitly {@link Receive.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Receive
     * @static
     * @param {IReceive} message Receive message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Receive.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Receive message from the specified reader or buffer.
     * @function decode
     * @memberof Receive
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Receive} Receive
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Receive.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receive();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.binds && message.binds.length))
                    message.binds = [];
                message.binds.push($root.ReceiveBind.decode(reader, reader.uint32()));
                break;
            case 2:
                message.body = $root.Par.decode(reader, reader.uint32());
                break;
            case 3:
                message.persistent = reader.bool();
                break;
            case 4:
                message.peek = reader.bool();
                break;
            case 5:
                message.bindCount = reader.int32();
                break;
            case 6:
                message.locallyFree = reader.bytes();
                break;
            case 7:
                message.connective_used = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Receive message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Receive
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Receive} Receive
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Receive.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Receive message.
     * @function verify
     * @memberof Receive
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Receive.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.binds != null && message.hasOwnProperty("binds")) {
            if (!Array.isArray(message.binds))
                return "binds: array expected";
            for (var i = 0; i < message.binds.length; ++i) {
                var error = $root.ReceiveBind.verify(message.binds[i]);
                if (error)
                    return "binds." + error;
            }
        }
        if (message.body != null && message.hasOwnProperty("body")) {
            var error = $root.Par.verify(message.body);
            if (error)
                return "body." + error;
        }
        if (message.persistent != null && message.hasOwnProperty("persistent"))
            if (typeof message.persistent !== "boolean")
                return "persistent: boolean expected";
        if (message.peek != null && message.hasOwnProperty("peek"))
            if (typeof message.peek !== "boolean")
                return "peek: boolean expected";
        if (message.bindCount != null && message.hasOwnProperty("bindCount"))
            if (!$util.isInteger(message.bindCount))
                return "bindCount: integer expected";
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        return null;
    };

    /**
     * Creates a Receive message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Receive
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Receive} Receive
     */
    Receive.fromObject = function fromObject(object) {
        if (object instanceof $root.Receive)
            return object;
        var message = new $root.Receive();
        if (object.binds) {
            if (!Array.isArray(object.binds))
                throw TypeError(".Receive.binds: array expected");
            message.binds = [];
            for (var i = 0; i < object.binds.length; ++i) {
                if (typeof object.binds[i] !== "object")
                    throw TypeError(".Receive.binds: object expected");
                message.binds[i] = $root.ReceiveBind.fromObject(object.binds[i]);
            }
        }
        if (object.body != null) {
            if (typeof object.body !== "object")
                throw TypeError(".Receive.body: object expected");
            message.body = $root.Par.fromObject(object.body);
        }
        if (object.persistent != null)
            message.persistent = Boolean(object.persistent);
        if (object.peek != null)
            message.peek = Boolean(object.peek);
        if (object.bindCount != null)
            message.bindCount = object.bindCount | 0;
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        return message;
    };

    /**
     * Creates a plain object from a Receive message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Receive
     * @static
     * @param {Receive} message Receive
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Receive.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.binds = [];
        if (options.defaults) {
            object.body = null;
            object.persistent = false;
            object.peek = false;
            object.bindCount = 0;
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
        }
        if (message.binds && message.binds.length) {
            object.binds = [];
            for (var j = 0; j < message.binds.length; ++j)
                object.binds[j] = $root.ReceiveBind.toObject(message.binds[j], options);
        }
        if (message.body != null && message.hasOwnProperty("body"))
            object.body = $root.Par.toObject(message.body, options);
        if (message.persistent != null && message.hasOwnProperty("persistent"))
            object.persistent = message.persistent;
        if (message.peek != null && message.hasOwnProperty("peek"))
            object.peek = message.peek;
        if (message.bindCount != null && message.hasOwnProperty("bindCount"))
            object.bindCount = message.bindCount;
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        return object;
    };

    /**
     * Converts this Receive to JSON.
     * @function toJSON
     * @memberof Receive
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Receive.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Receive;
})();

$root.New = (function() {

    /**
     * Properties of a New.
     * @exports INew
     * @interface INew
     * @property {number|null} [bindCount] New bindCount
     * @property {IPar|null} [p] New p
     * @property {Array.<string>|null} [uri] New uri
     * @property {IDeployId|null} [deployId] New deployId
     * @property {IDeployerId|null} [deployerId] New deployerId
     * @property {Uint8Array|null} [locallyFree] New locallyFree
     */

    /**
     * Constructs a new New.
     * @exports New
     * @classdesc Represents a New.
     * @implements INew
     * @constructor
     * @param {INew=} [properties] Properties to set
     */
    function New(properties) {
        this.uri = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * New bindCount.
     * @member {number} bindCount
     * @memberof New
     * @instance
     */
    New.prototype.bindCount = 0;

    /**
     * New p.
     * @member {IPar|null|undefined} p
     * @memberof New
     * @instance
     */
    New.prototype.p = null;

    /**
     * New uri.
     * @member {Array.<string>} uri
     * @memberof New
     * @instance
     */
    New.prototype.uri = $util.emptyArray;

    /**
     * New deployId.
     * @member {IDeployId|null|undefined} deployId
     * @memberof New
     * @instance
     */
    New.prototype.deployId = null;

    /**
     * New deployerId.
     * @member {IDeployerId|null|undefined} deployerId
     * @memberof New
     * @instance
     */
    New.prototype.deployerId = null;

    /**
     * New locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof New
     * @instance
     */
    New.prototype.locallyFree = $util.newBuffer([]);

    /**
     * Creates a new New instance using the specified properties.
     * @function create
     * @memberof New
     * @static
     * @param {INew=} [properties] Properties to set
     * @returns {New} New instance
     */
    New.create = function create(properties) {
        return new New(properties);
    };

    /**
     * Encodes the specified New message. Does not implicitly {@link New.verify|verify} messages.
     * @function encode
     * @memberof New
     * @static
     * @param {INew} message New message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    New.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bindCount != null && message.hasOwnProperty("bindCount"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.bindCount);
        if (message.p != null && message.hasOwnProperty("p"))
            $root.Par.encode(message.p, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.uri != null && message.uri.length)
            for (var i = 0; i < message.uri.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.uri[i]);
        if (message.deployId != null && message.hasOwnProperty("deployId"))
            $root.DeployId.encode(message.deployId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.deployerId != null && message.hasOwnProperty("deployerId"))
            $root.DeployerId.encode(message.deployerId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.locallyFree);
        return writer;
    };

    /**
     * Encodes the specified New message, length delimited. Does not implicitly {@link New.verify|verify} messages.
     * @function encodeDelimited
     * @memberof New
     * @static
     * @param {INew} message New message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    New.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a New message from the specified reader or buffer.
     * @function decode
     * @memberof New
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {New} New
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    New.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.New();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bindCount = reader.sint32();
                break;
            case 2:
                message.p = $root.Par.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.uri && message.uri.length))
                    message.uri = [];
                message.uri.push(reader.string());
                break;
            case 4:
                message.deployId = $root.DeployId.decode(reader, reader.uint32());
                break;
            case 5:
                message.deployerId = $root.DeployerId.decode(reader, reader.uint32());
                break;
            case 6:
                message.locallyFree = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a New message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof New
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {New} New
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    New.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a New message.
     * @function verify
     * @memberof New
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    New.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bindCount != null && message.hasOwnProperty("bindCount"))
            if (!$util.isInteger(message.bindCount))
                return "bindCount: integer expected";
        if (message.p != null && message.hasOwnProperty("p")) {
            var error = $root.Par.verify(message.p);
            if (error)
                return "p." + error;
        }
        if (message.uri != null && message.hasOwnProperty("uri")) {
            if (!Array.isArray(message.uri))
                return "uri: array expected";
            for (var i = 0; i < message.uri.length; ++i)
                if (!$util.isString(message.uri[i]))
                    return "uri: string[] expected";
        }
        if (message.deployId != null && message.hasOwnProperty("deployId")) {
            var error = $root.DeployId.verify(message.deployId);
            if (error)
                return "deployId." + error;
        }
        if (message.deployerId != null && message.hasOwnProperty("deployerId")) {
            var error = $root.DeployerId.verify(message.deployerId);
            if (error)
                return "deployerId." + error;
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        return null;
    };

    /**
     * Creates a New message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof New
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {New} New
     */
    New.fromObject = function fromObject(object) {
        if (object instanceof $root.New)
            return object;
        var message = new $root.New();
        if (object.bindCount != null)
            message.bindCount = object.bindCount | 0;
        if (object.p != null) {
            if (typeof object.p !== "object")
                throw TypeError(".New.p: object expected");
            message.p = $root.Par.fromObject(object.p);
        }
        if (object.uri) {
            if (!Array.isArray(object.uri))
                throw TypeError(".New.uri: array expected");
            message.uri = [];
            for (var i = 0; i < object.uri.length; ++i)
                message.uri[i] = String(object.uri[i]);
        }
        if (object.deployId != null) {
            if (typeof object.deployId !== "object")
                throw TypeError(".New.deployId: object expected");
            message.deployId = $root.DeployId.fromObject(object.deployId);
        }
        if (object.deployerId != null) {
            if (typeof object.deployerId !== "object")
                throw TypeError(".New.deployerId: object expected");
            message.deployerId = $root.DeployerId.fromObject(object.deployerId);
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        return message;
    };

    /**
     * Creates a plain object from a New message. Also converts values to other types if specified.
     * @function toObject
     * @memberof New
     * @static
     * @param {New} message New
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    New.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.uri = [];
        if (options.defaults) {
            object.bindCount = 0;
            object.p = null;
            object.deployId = null;
            object.deployerId = null;
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
        }
        if (message.bindCount != null && message.hasOwnProperty("bindCount"))
            object.bindCount = message.bindCount;
        if (message.p != null && message.hasOwnProperty("p"))
            object.p = $root.Par.toObject(message.p, options);
        if (message.uri && message.uri.length) {
            object.uri = [];
            for (var j = 0; j < message.uri.length; ++j)
                object.uri[j] = message.uri[j];
        }
        if (message.deployId != null && message.hasOwnProperty("deployId"))
            object.deployId = $root.DeployId.toObject(message.deployId, options);
        if (message.deployerId != null && message.hasOwnProperty("deployerId"))
            object.deployerId = $root.DeployerId.toObject(message.deployerId, options);
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        return object;
    };

    /**
     * Converts this New to JSON.
     * @function toJSON
     * @memberof New
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    New.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return New;
})();

$root.MatchCase = (function() {

    /**
     * Properties of a MatchCase.
     * @exports IMatchCase
     * @interface IMatchCase
     * @property {IPar|null} [pattern] MatchCase pattern
     * @property {IPar|null} [source] MatchCase source
     * @property {number|null} [freeCount] MatchCase freeCount
     */

    /**
     * Constructs a new MatchCase.
     * @exports MatchCase
     * @classdesc Represents a MatchCase.
     * @implements IMatchCase
     * @constructor
     * @param {IMatchCase=} [properties] Properties to set
     */
    function MatchCase(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MatchCase pattern.
     * @member {IPar|null|undefined} pattern
     * @memberof MatchCase
     * @instance
     */
    MatchCase.prototype.pattern = null;

    /**
     * MatchCase source.
     * @member {IPar|null|undefined} source
     * @memberof MatchCase
     * @instance
     */
    MatchCase.prototype.source = null;

    /**
     * MatchCase freeCount.
     * @member {number} freeCount
     * @memberof MatchCase
     * @instance
     */
    MatchCase.prototype.freeCount = 0;

    /**
     * Creates a new MatchCase instance using the specified properties.
     * @function create
     * @memberof MatchCase
     * @static
     * @param {IMatchCase=} [properties] Properties to set
     * @returns {MatchCase} MatchCase instance
     */
    MatchCase.create = function create(properties) {
        return new MatchCase(properties);
    };

    /**
     * Encodes the specified MatchCase message. Does not implicitly {@link MatchCase.verify|verify} messages.
     * @function encode
     * @memberof MatchCase
     * @static
     * @param {IMatchCase} message MatchCase message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MatchCase.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pattern != null && message.hasOwnProperty("pattern"))
            $root.Par.encode(message.pattern, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.source != null && message.hasOwnProperty("source"))
            $root.Par.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.freeCount);
        return writer;
    };

    /**
     * Encodes the specified MatchCase message, length delimited. Does not implicitly {@link MatchCase.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MatchCase
     * @static
     * @param {IMatchCase} message MatchCase message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MatchCase.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MatchCase message from the specified reader or buffer.
     * @function decode
     * @memberof MatchCase
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MatchCase} MatchCase
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MatchCase.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MatchCase();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.pattern = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.source = $root.Par.decode(reader, reader.uint32());
                break;
            case 3:
                message.freeCount = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MatchCase message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MatchCase
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MatchCase} MatchCase
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MatchCase.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MatchCase message.
     * @function verify
     * @memberof MatchCase
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MatchCase.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pattern != null && message.hasOwnProperty("pattern")) {
            var error = $root.Par.verify(message.pattern);
            if (error)
                return "pattern." + error;
        }
        if (message.source != null && message.hasOwnProperty("source")) {
            var error = $root.Par.verify(message.source);
            if (error)
                return "source." + error;
        }
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            if (!$util.isInteger(message.freeCount))
                return "freeCount: integer expected";
        return null;
    };

    /**
     * Creates a MatchCase message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MatchCase
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MatchCase} MatchCase
     */
    MatchCase.fromObject = function fromObject(object) {
        if (object instanceof $root.MatchCase)
            return object;
        var message = new $root.MatchCase();
        if (object.pattern != null) {
            if (typeof object.pattern !== "object")
                throw TypeError(".MatchCase.pattern: object expected");
            message.pattern = $root.Par.fromObject(object.pattern);
        }
        if (object.source != null) {
            if (typeof object.source !== "object")
                throw TypeError(".MatchCase.source: object expected");
            message.source = $root.Par.fromObject(object.source);
        }
        if (object.freeCount != null)
            message.freeCount = object.freeCount | 0;
        return message;
    };

    /**
     * Creates a plain object from a MatchCase message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MatchCase
     * @static
     * @param {MatchCase} message MatchCase
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MatchCase.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.pattern = null;
            object.source = null;
            object.freeCount = 0;
        }
        if (message.pattern != null && message.hasOwnProperty("pattern"))
            object.pattern = $root.Par.toObject(message.pattern, options);
        if (message.source != null && message.hasOwnProperty("source"))
            object.source = $root.Par.toObject(message.source, options);
        if (message.freeCount != null && message.hasOwnProperty("freeCount"))
            object.freeCount = message.freeCount;
        return object;
    };

    /**
     * Converts this MatchCase to JSON.
     * @function toJSON
     * @memberof MatchCase
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MatchCase.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MatchCase;
})();

$root.Match = (function() {

    /**
     * Properties of a Match.
     * @exports IMatch
     * @interface IMatch
     * @property {IPar|null} [target] Match target
     * @property {Array.<IMatchCase>|null} [cases] Match cases
     * @property {Uint8Array|null} [locallyFree] Match locallyFree
     * @property {boolean|null} [connective_used] Match connective_used
     */

    /**
     * Constructs a new Match.
     * @exports Match
     * @classdesc Represents a Match.
     * @implements IMatch
     * @constructor
     * @param {IMatch=} [properties] Properties to set
     */
    function Match(properties) {
        this.cases = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Match target.
     * @member {IPar|null|undefined} target
     * @memberof Match
     * @instance
     */
    Match.prototype.target = null;

    /**
     * Match cases.
     * @member {Array.<IMatchCase>} cases
     * @memberof Match
     * @instance
     */
    Match.prototype.cases = $util.emptyArray;

    /**
     * Match locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof Match
     * @instance
     */
    Match.prototype.locallyFree = $util.newBuffer([]);

    /**
     * Match connective_used.
     * @member {boolean} connective_used
     * @memberof Match
     * @instance
     */
    Match.prototype.connective_used = false;

    /**
     * Creates a new Match instance using the specified properties.
     * @function create
     * @memberof Match
     * @static
     * @param {IMatch=} [properties] Properties to set
     * @returns {Match} Match instance
     */
    Match.create = function create(properties) {
        return new Match(properties);
    };

    /**
     * Encodes the specified Match message. Does not implicitly {@link Match.verify|verify} messages.
     * @function encode
     * @memberof Match
     * @static
     * @param {IMatch} message Match message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Match.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.target != null && message.hasOwnProperty("target"))
            $root.Par.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.cases != null && message.cases.length)
            for (var i = 0; i < message.cases.length; ++i)
                $root.MatchCase.encode(message.cases[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.connective_used);
        return writer;
    };

    /**
     * Encodes the specified Match message, length delimited. Does not implicitly {@link Match.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Match
     * @static
     * @param {IMatch} message Match message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Match.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Match message from the specified reader or buffer.
     * @function decode
     * @memberof Match
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Match} Match
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Match.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Match();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.target = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.cases && message.cases.length))
                    message.cases = [];
                message.cases.push($root.MatchCase.decode(reader, reader.uint32()));
                break;
            case 4:
                message.locallyFree = reader.bytes();
                break;
            case 5:
                message.connective_used = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Match message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Match
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Match} Match
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Match.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Match message.
     * @function verify
     * @memberof Match
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Match.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.target != null && message.hasOwnProperty("target")) {
            var error = $root.Par.verify(message.target);
            if (error)
                return "target." + error;
        }
        if (message.cases != null && message.hasOwnProperty("cases")) {
            if (!Array.isArray(message.cases))
                return "cases: array expected";
            for (var i = 0; i < message.cases.length; ++i) {
                var error = $root.MatchCase.verify(message.cases[i]);
                if (error)
                    return "cases." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        return null;
    };

    /**
     * Creates a Match message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Match
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Match} Match
     */
    Match.fromObject = function fromObject(object) {
        if (object instanceof $root.Match)
            return object;
        var message = new $root.Match();
        if (object.target != null) {
            if (typeof object.target !== "object")
                throw TypeError(".Match.target: object expected");
            message.target = $root.Par.fromObject(object.target);
        }
        if (object.cases) {
            if (!Array.isArray(object.cases))
                throw TypeError(".Match.cases: array expected");
            message.cases = [];
            for (var i = 0; i < object.cases.length; ++i) {
                if (typeof object.cases[i] !== "object")
                    throw TypeError(".Match.cases: object expected");
                message.cases[i] = $root.MatchCase.fromObject(object.cases[i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        return message;
    };

    /**
     * Creates a plain object from a Match message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Match
     * @static
     * @param {Match} message Match
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Match.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.cases = [];
        if (options.defaults) {
            object.target = null;
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
        }
        if (message.target != null && message.hasOwnProperty("target"))
            object.target = $root.Par.toObject(message.target, options);
        if (message.cases && message.cases.length) {
            object.cases = [];
            for (var j = 0; j < message.cases.length; ++j)
                object.cases[j] = $root.MatchCase.toObject(message.cases[j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        return object;
    };

    /**
     * Converts this Match to JSON.
     * @function toJSON
     * @memberof Match
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Match.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Match;
})();

$root.Expr = (function() {

    /**
     * Properties of an Expr.
     * @exports IExpr
     * @interface IExpr
     * @property {boolean|null} [g_bool] Expr g_bool
     * @property {number|Long|null} [g_int] Expr g_int
     * @property {string|null} [g_string] Expr g_string
     * @property {string|null} [g_uri] Expr g_uri
     * @property {Uint8Array|null} [g_byte_array] Expr g_byte_array
     * @property {IENot|null} [e_not_body] Expr e_not_body
     * @property {IENeg|null} [e_neg_body] Expr e_neg_body
     * @property {IEMult|null} [e_mult_body] Expr e_mult_body
     * @property {IEDiv|null} [e_div_body] Expr e_div_body
     * @property {IEPlus|null} [e_plus_body] Expr e_plus_body
     * @property {IEMinus|null} [e_minus_body] Expr e_minus_body
     * @property {IELt|null} [e_lt_body] Expr e_lt_body
     * @property {IELte|null} [e_lte_body] Expr e_lte_body
     * @property {IEGt|null} [e_gt_body] Expr e_gt_body
     * @property {IEGte|null} [e_gte_body] Expr e_gte_body
     * @property {IEEq|null} [e_eq_body] Expr e_eq_body
     * @property {IENeq|null} [e_neq_body] Expr e_neq_body
     * @property {IEAnd|null} [e_and_body] Expr e_and_body
     * @property {IEOr|null} [e_or_body] Expr e_or_body
     * @property {IEVar|null} [e_var_body] Expr e_var_body
     * @property {IEList|null} [e_list_body] Expr e_list_body
     * @property {IETuple|null} [e_tuple_body] Expr e_tuple_body
     * @property {IESet|null} [e_set_body] Expr e_set_body
     * @property {IEMap|null} [e_map_body] Expr e_map_body
     * @property {IEMethod|null} [e_method_body] Expr e_method_body
     * @property {IEMatches|null} [e_matches_body] Expr e_matches_body
     * @property {IEPercentPercent|null} [e_percent_percent_body] Expr e_percent_percent_body
     * @property {IEPlusPlus|null} [e_plus_plus_body] Expr e_plus_plus_body
     * @property {IEMinusMinus|null} [e_minus_minus_body] Expr e_minus_minus_body
     * @property {IEMod|null} [e_mod_body] Expr e_mod_body
     */

    /**
     * Constructs a new Expr.
     * @exports Expr
     * @classdesc Represents an Expr.
     * @implements IExpr
     * @constructor
     * @param {IExpr=} [properties] Properties to set
     */
    function Expr(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Expr g_bool.
     * @member {boolean} g_bool
     * @memberof Expr
     * @instance
     */
    Expr.prototype.g_bool = false;

    /**
     * Expr g_int.
     * @member {number|Long} g_int
     * @memberof Expr
     * @instance
     */
    Expr.prototype.g_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Expr g_string.
     * @member {string} g_string
     * @memberof Expr
     * @instance
     */
    Expr.prototype.g_string = "";

    /**
     * Expr g_uri.
     * @member {string} g_uri
     * @memberof Expr
     * @instance
     */
    Expr.prototype.g_uri = "";

    /**
     * Expr g_byte_array.
     * @member {Uint8Array} g_byte_array
     * @memberof Expr
     * @instance
     */
    Expr.prototype.g_byte_array = $util.newBuffer([]);

    /**
     * Expr e_not_body.
     * @member {IENot|null|undefined} e_not_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_not_body = null;

    /**
     * Expr e_neg_body.
     * @member {IENeg|null|undefined} e_neg_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_neg_body = null;

    /**
     * Expr e_mult_body.
     * @member {IEMult|null|undefined} e_mult_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_mult_body = null;

    /**
     * Expr e_div_body.
     * @member {IEDiv|null|undefined} e_div_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_div_body = null;

    /**
     * Expr e_plus_body.
     * @member {IEPlus|null|undefined} e_plus_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_plus_body = null;

    /**
     * Expr e_minus_body.
     * @member {IEMinus|null|undefined} e_minus_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_minus_body = null;

    /**
     * Expr e_lt_body.
     * @member {IELt|null|undefined} e_lt_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_lt_body = null;

    /**
     * Expr e_lte_body.
     * @member {IELte|null|undefined} e_lte_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_lte_body = null;

    /**
     * Expr e_gt_body.
     * @member {IEGt|null|undefined} e_gt_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_gt_body = null;

    /**
     * Expr e_gte_body.
     * @member {IEGte|null|undefined} e_gte_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_gte_body = null;

    /**
     * Expr e_eq_body.
     * @member {IEEq|null|undefined} e_eq_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_eq_body = null;

    /**
     * Expr e_neq_body.
     * @member {IENeq|null|undefined} e_neq_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_neq_body = null;

    /**
     * Expr e_and_body.
     * @member {IEAnd|null|undefined} e_and_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_and_body = null;

    /**
     * Expr e_or_body.
     * @member {IEOr|null|undefined} e_or_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_or_body = null;

    /**
     * Expr e_var_body.
     * @member {IEVar|null|undefined} e_var_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_var_body = null;

    /**
     * Expr e_list_body.
     * @member {IEList|null|undefined} e_list_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_list_body = null;

    /**
     * Expr e_tuple_body.
     * @member {IETuple|null|undefined} e_tuple_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_tuple_body = null;

    /**
     * Expr e_set_body.
     * @member {IESet|null|undefined} e_set_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_set_body = null;

    /**
     * Expr e_map_body.
     * @member {IEMap|null|undefined} e_map_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_map_body = null;

    /**
     * Expr e_method_body.
     * @member {IEMethod|null|undefined} e_method_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_method_body = null;

    /**
     * Expr e_matches_body.
     * @member {IEMatches|null|undefined} e_matches_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_matches_body = null;

    /**
     * Expr e_percent_percent_body.
     * @member {IEPercentPercent|null|undefined} e_percent_percent_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_percent_percent_body = null;

    /**
     * Expr e_plus_plus_body.
     * @member {IEPlusPlus|null|undefined} e_plus_plus_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_plus_plus_body = null;

    /**
     * Expr e_minus_minus_body.
     * @member {IEMinusMinus|null|undefined} e_minus_minus_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_minus_minus_body = null;

    /**
     * Expr e_mod_body.
     * @member {IEMod|null|undefined} e_mod_body
     * @memberof Expr
     * @instance
     */
    Expr.prototype.e_mod_body = null;

    // OneOf field names bound to virtual getters and setters
    var $oneOfFields;

    /**
     * Expr expr_instance.
     * @member {"g_bool"|"g_int"|"g_string"|"g_uri"|"g_byte_array"|"e_not_body"|"e_neg_body"|"e_mult_body"|"e_div_body"|"e_plus_body"|"e_minus_body"|"e_lt_body"|"e_lte_body"|"e_gt_body"|"e_gte_body"|"e_eq_body"|"e_neq_body"|"e_and_body"|"e_or_body"|"e_var_body"|"e_list_body"|"e_tuple_body"|"e_set_body"|"e_map_body"|"e_method_body"|"e_matches_body"|"e_percent_percent_body"|"e_plus_plus_body"|"e_minus_minus_body"|"e_mod_body"|undefined} expr_instance
     * @memberof Expr
     * @instance
     */
    Object.defineProperty(Expr.prototype, "expr_instance", {
        get: $util.oneOfGetter($oneOfFields = ["g_bool", "g_int", "g_string", "g_uri", "g_byte_array", "e_not_body", "e_neg_body", "e_mult_body", "e_div_body", "e_plus_body", "e_minus_body", "e_lt_body", "e_lte_body", "e_gt_body", "e_gte_body", "e_eq_body", "e_neq_body", "e_and_body", "e_or_body", "e_var_body", "e_list_body", "e_tuple_body", "e_set_body", "e_map_body", "e_method_body", "e_matches_body", "e_percent_percent_body", "e_plus_plus_body", "e_minus_minus_body", "e_mod_body"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new Expr instance using the specified properties.
     * @function create
     * @memberof Expr
     * @static
     * @param {IExpr=} [properties] Properties to set
     * @returns {Expr} Expr instance
     */
    Expr.create = function create(properties) {
        return new Expr(properties);
    };

    /**
     * Encodes the specified Expr message. Does not implicitly {@link Expr.verify|verify} messages.
     * @function encode
     * @memberof Expr
     * @static
     * @param {IExpr} message Expr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Expr.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.g_bool != null && message.hasOwnProperty("g_bool"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.g_bool);
        if (message.g_int != null && message.hasOwnProperty("g_int"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.g_int);
        if (message.g_string != null && message.hasOwnProperty("g_string"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.g_string);
        if (message.g_uri != null && message.hasOwnProperty("g_uri"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.g_uri);
        if (message.e_not_body != null && message.hasOwnProperty("e_not_body"))
            $root.ENot.encode(message.e_not_body, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.e_neg_body != null && message.hasOwnProperty("e_neg_body"))
            $root.ENeg.encode(message.e_neg_body, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.e_mult_body != null && message.hasOwnProperty("e_mult_body"))
            $root.EMult.encode(message.e_mult_body, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.e_div_body != null && message.hasOwnProperty("e_div_body"))
            $root.EDiv.encode(message.e_div_body, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.e_plus_body != null && message.hasOwnProperty("e_plus_body"))
            $root.EPlus.encode(message.e_plus_body, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.e_minus_body != null && message.hasOwnProperty("e_minus_body"))
            $root.EMinus.encode(message.e_minus_body, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.e_lt_body != null && message.hasOwnProperty("e_lt_body"))
            $root.ELt.encode(message.e_lt_body, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.e_lte_body != null && message.hasOwnProperty("e_lte_body"))
            $root.ELte.encode(message.e_lte_body, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.e_gt_body != null && message.hasOwnProperty("e_gt_body"))
            $root.EGt.encode(message.e_gt_body, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.e_gte_body != null && message.hasOwnProperty("e_gte_body"))
            $root.EGte.encode(message.e_gte_body, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.e_eq_body != null && message.hasOwnProperty("e_eq_body"))
            $root.EEq.encode(message.e_eq_body, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.e_neq_body != null && message.hasOwnProperty("e_neq_body"))
            $root.ENeq.encode(message.e_neq_body, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        if (message.e_and_body != null && message.hasOwnProperty("e_and_body"))
            $root.EAnd.encode(message.e_and_body, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.e_or_body != null && message.hasOwnProperty("e_or_body"))
            $root.EOr.encode(message.e_or_body, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.e_var_body != null && message.hasOwnProperty("e_var_body"))
            $root.EVar.encode(message.e_var_body, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        if (message.e_list_body != null && message.hasOwnProperty("e_list_body"))
            $root.EList.encode(message.e_list_body, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
        if (message.e_tuple_body != null && message.hasOwnProperty("e_tuple_body"))
            $root.ETuple.encode(message.e_tuple_body, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
        if (message.e_set_body != null && message.hasOwnProperty("e_set_body"))
            $root.ESet.encode(message.e_set_body, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
        if (message.e_map_body != null && message.hasOwnProperty("e_map_body"))
            $root.EMap.encode(message.e_map_body, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
        if (message.e_method_body != null && message.hasOwnProperty("e_method_body"))
            $root.EMethod.encode(message.e_method_body, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
        if (message.g_byte_array != null && message.hasOwnProperty("g_byte_array"))
            writer.uint32(/* id 25, wireType 2 =*/202).bytes(message.g_byte_array);
        if (message.e_matches_body != null && message.hasOwnProperty("e_matches_body"))
            $root.EMatches.encode(message.e_matches_body, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
        if (message.e_percent_percent_body != null && message.hasOwnProperty("e_percent_percent_body"))
            $root.EPercentPercent.encode(message.e_percent_percent_body, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
        if (message.e_plus_plus_body != null && message.hasOwnProperty("e_plus_plus_body"))
            $root.EPlusPlus.encode(message.e_plus_plus_body, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
        if (message.e_minus_minus_body != null && message.hasOwnProperty("e_minus_minus_body"))
            $root.EMinusMinus.encode(message.e_minus_minus_body, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
        if (message.e_mod_body != null && message.hasOwnProperty("e_mod_body"))
            $root.EMod.encode(message.e_mod_body, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Expr message, length delimited. Does not implicitly {@link Expr.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Expr
     * @static
     * @param {IExpr} message Expr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Expr.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Expr message from the specified reader or buffer.
     * @function decode
     * @memberof Expr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Expr} Expr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Expr.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Expr();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.g_bool = reader.bool();
                break;
            case 2:
                message.g_int = reader.sint64();
                break;
            case 3:
                message.g_string = reader.string();
                break;
            case 4:
                message.g_uri = reader.string();
                break;
            case 25:
                message.g_byte_array = reader.bytes();
                break;
            case 5:
                message.e_not_body = $root.ENot.decode(reader, reader.uint32());
                break;
            case 6:
                message.e_neg_body = $root.ENeg.decode(reader, reader.uint32());
                break;
            case 7:
                message.e_mult_body = $root.EMult.decode(reader, reader.uint32());
                break;
            case 8:
                message.e_div_body = $root.EDiv.decode(reader, reader.uint32());
                break;
            case 9:
                message.e_plus_body = $root.EPlus.decode(reader, reader.uint32());
                break;
            case 10:
                message.e_minus_body = $root.EMinus.decode(reader, reader.uint32());
                break;
            case 11:
                message.e_lt_body = $root.ELt.decode(reader, reader.uint32());
                break;
            case 12:
                message.e_lte_body = $root.ELte.decode(reader, reader.uint32());
                break;
            case 13:
                message.e_gt_body = $root.EGt.decode(reader, reader.uint32());
                break;
            case 14:
                message.e_gte_body = $root.EGte.decode(reader, reader.uint32());
                break;
            case 15:
                message.e_eq_body = $root.EEq.decode(reader, reader.uint32());
                break;
            case 16:
                message.e_neq_body = $root.ENeq.decode(reader, reader.uint32());
                break;
            case 17:
                message.e_and_body = $root.EAnd.decode(reader, reader.uint32());
                break;
            case 18:
                message.e_or_body = $root.EOr.decode(reader, reader.uint32());
                break;
            case 19:
                message.e_var_body = $root.EVar.decode(reader, reader.uint32());
                break;
            case 20:
                message.e_list_body = $root.EList.decode(reader, reader.uint32());
                break;
            case 21:
                message.e_tuple_body = $root.ETuple.decode(reader, reader.uint32());
                break;
            case 22:
                message.e_set_body = $root.ESet.decode(reader, reader.uint32());
                break;
            case 23:
                message.e_map_body = $root.EMap.decode(reader, reader.uint32());
                break;
            case 24:
                message.e_method_body = $root.EMethod.decode(reader, reader.uint32());
                break;
            case 27:
                message.e_matches_body = $root.EMatches.decode(reader, reader.uint32());
                break;
            case 28:
                message.e_percent_percent_body = $root.EPercentPercent.decode(reader, reader.uint32());
                break;
            case 29:
                message.e_plus_plus_body = $root.EPlusPlus.decode(reader, reader.uint32());
                break;
            case 30:
                message.e_minus_minus_body = $root.EMinusMinus.decode(reader, reader.uint32());
                break;
            case 31:
                message.e_mod_body = $root.EMod.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Expr message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Expr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Expr} Expr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Expr.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Expr message.
     * @function verify
     * @memberof Expr
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Expr.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        var properties = {};
        if (message.g_bool != null && message.hasOwnProperty("g_bool")) {
            properties.expr_instance = 1;
            if (typeof message.g_bool !== "boolean")
                return "g_bool: boolean expected";
        }
        if (message.g_int != null && message.hasOwnProperty("g_int")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            if (!$util.isInteger(message.g_int) && !(message.g_int && $util.isInteger(message.g_int.low) && $util.isInteger(message.g_int.high)))
                return "g_int: integer|Long expected";
        }
        if (message.g_string != null && message.hasOwnProperty("g_string")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            if (!$util.isString(message.g_string))
                return "g_string: string expected";
        }
        if (message.g_uri != null && message.hasOwnProperty("g_uri")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            if (!$util.isString(message.g_uri))
                return "g_uri: string expected";
        }
        if (message.g_byte_array != null && message.hasOwnProperty("g_byte_array")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            if (!(message.g_byte_array && typeof message.g_byte_array.length === "number" || $util.isString(message.g_byte_array)))
                return "g_byte_array: buffer expected";
        }
        if (message.e_not_body != null && message.hasOwnProperty("e_not_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ENot.verify(message.e_not_body);
                if (error)
                    return "e_not_body." + error;
            }
        }
        if (message.e_neg_body != null && message.hasOwnProperty("e_neg_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ENeg.verify(message.e_neg_body);
                if (error)
                    return "e_neg_body." + error;
            }
        }
        if (message.e_mult_body != null && message.hasOwnProperty("e_mult_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMult.verify(message.e_mult_body);
                if (error)
                    return "e_mult_body." + error;
            }
        }
        if (message.e_div_body != null && message.hasOwnProperty("e_div_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EDiv.verify(message.e_div_body);
                if (error)
                    return "e_div_body." + error;
            }
        }
        if (message.e_plus_body != null && message.hasOwnProperty("e_plus_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EPlus.verify(message.e_plus_body);
                if (error)
                    return "e_plus_body." + error;
            }
        }
        if (message.e_minus_body != null && message.hasOwnProperty("e_minus_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMinus.verify(message.e_minus_body);
                if (error)
                    return "e_minus_body." + error;
            }
        }
        if (message.e_lt_body != null && message.hasOwnProperty("e_lt_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ELt.verify(message.e_lt_body);
                if (error)
                    return "e_lt_body." + error;
            }
        }
        if (message.e_lte_body != null && message.hasOwnProperty("e_lte_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ELte.verify(message.e_lte_body);
                if (error)
                    return "e_lte_body." + error;
            }
        }
        if (message.e_gt_body != null && message.hasOwnProperty("e_gt_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EGt.verify(message.e_gt_body);
                if (error)
                    return "e_gt_body." + error;
            }
        }
        if (message.e_gte_body != null && message.hasOwnProperty("e_gte_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EGte.verify(message.e_gte_body);
                if (error)
                    return "e_gte_body." + error;
            }
        }
        if (message.e_eq_body != null && message.hasOwnProperty("e_eq_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EEq.verify(message.e_eq_body);
                if (error)
                    return "e_eq_body." + error;
            }
        }
        if (message.e_neq_body != null && message.hasOwnProperty("e_neq_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ENeq.verify(message.e_neq_body);
                if (error)
                    return "e_neq_body." + error;
            }
        }
        if (message.e_and_body != null && message.hasOwnProperty("e_and_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EAnd.verify(message.e_and_body);
                if (error)
                    return "e_and_body." + error;
            }
        }
        if (message.e_or_body != null && message.hasOwnProperty("e_or_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EOr.verify(message.e_or_body);
                if (error)
                    return "e_or_body." + error;
            }
        }
        if (message.e_var_body != null && message.hasOwnProperty("e_var_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EVar.verify(message.e_var_body);
                if (error)
                    return "e_var_body." + error;
            }
        }
        if (message.e_list_body != null && message.hasOwnProperty("e_list_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EList.verify(message.e_list_body);
                if (error)
                    return "e_list_body." + error;
            }
        }
        if (message.e_tuple_body != null && message.hasOwnProperty("e_tuple_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ETuple.verify(message.e_tuple_body);
                if (error)
                    return "e_tuple_body." + error;
            }
        }
        if (message.e_set_body != null && message.hasOwnProperty("e_set_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.ESet.verify(message.e_set_body);
                if (error)
                    return "e_set_body." + error;
            }
        }
        if (message.e_map_body != null && message.hasOwnProperty("e_map_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMap.verify(message.e_map_body);
                if (error)
                    return "e_map_body." + error;
            }
        }
        if (message.e_method_body != null && message.hasOwnProperty("e_method_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMethod.verify(message.e_method_body);
                if (error)
                    return "e_method_body." + error;
            }
        }
        if (message.e_matches_body != null && message.hasOwnProperty("e_matches_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMatches.verify(message.e_matches_body);
                if (error)
                    return "e_matches_body." + error;
            }
        }
        if (message.e_percent_percent_body != null && message.hasOwnProperty("e_percent_percent_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EPercentPercent.verify(message.e_percent_percent_body);
                if (error)
                    return "e_percent_percent_body." + error;
            }
        }
        if (message.e_plus_plus_body != null && message.hasOwnProperty("e_plus_plus_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EPlusPlus.verify(message.e_plus_plus_body);
                if (error)
                    return "e_plus_plus_body." + error;
            }
        }
        if (message.e_minus_minus_body != null && message.hasOwnProperty("e_minus_minus_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMinusMinus.verify(message.e_minus_minus_body);
                if (error)
                    return "e_minus_minus_body." + error;
            }
        }
        if (message.e_mod_body != null && message.hasOwnProperty("e_mod_body")) {
            if (properties.expr_instance === 1)
                return "expr_instance: multiple values";
            properties.expr_instance = 1;
            {
                var error = $root.EMod.verify(message.e_mod_body);
                if (error)
                    return "e_mod_body." + error;
            }
        }
        return null;
    };

    /**
     * Creates an Expr message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Expr
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Expr} Expr
     */
    Expr.fromObject = function fromObject(object) {
        if (object instanceof $root.Expr)
            return object;
        var message = new $root.Expr();
        if (object.g_bool != null)
            message.g_bool = Boolean(object.g_bool);
        if (object.g_int != null)
            if ($util.Long)
                (message.g_int = $util.Long.fromValue(object.g_int)).unsigned = false;
            else if (typeof object.g_int === "string")
                message.g_int = parseInt(object.g_int, 10);
            else if (typeof object.g_int === "number")
                message.g_int = object.g_int;
            else if (typeof object.g_int === "object")
                message.g_int = new $util.LongBits(object.g_int.low >>> 0, object.g_int.high >>> 0).toNumber();
        if (object.g_string != null)
            message.g_string = String(object.g_string);
        if (object.g_uri != null)
            message.g_uri = String(object.g_uri);
        if (object.g_byte_array != null)
            if (typeof object.g_byte_array === "string")
                $util.base64.decode(object.g_byte_array, message.g_byte_array = $util.newBuffer($util.base64.length(object.g_byte_array)), 0);
            else if (object.g_byte_array.length)
                message.g_byte_array = object.g_byte_array;
        if (object.e_not_body != null) {
            if (typeof object.e_not_body !== "object")
                throw TypeError(".Expr.e_not_body: object expected");
            message.e_not_body = $root.ENot.fromObject(object.e_not_body);
        }
        if (object.e_neg_body != null) {
            if (typeof object.e_neg_body !== "object")
                throw TypeError(".Expr.e_neg_body: object expected");
            message.e_neg_body = $root.ENeg.fromObject(object.e_neg_body);
        }
        if (object.e_mult_body != null) {
            if (typeof object.e_mult_body !== "object")
                throw TypeError(".Expr.e_mult_body: object expected");
            message.e_mult_body = $root.EMult.fromObject(object.e_mult_body);
        }
        if (object.e_div_body != null) {
            if (typeof object.e_div_body !== "object")
                throw TypeError(".Expr.e_div_body: object expected");
            message.e_div_body = $root.EDiv.fromObject(object.e_div_body);
        }
        if (object.e_plus_body != null) {
            if (typeof object.e_plus_body !== "object")
                throw TypeError(".Expr.e_plus_body: object expected");
            message.e_plus_body = $root.EPlus.fromObject(object.e_plus_body);
        }
        if (object.e_minus_body != null) {
            if (typeof object.e_minus_body !== "object")
                throw TypeError(".Expr.e_minus_body: object expected");
            message.e_minus_body = $root.EMinus.fromObject(object.e_minus_body);
        }
        if (object.e_lt_body != null) {
            if (typeof object.e_lt_body !== "object")
                throw TypeError(".Expr.e_lt_body: object expected");
            message.e_lt_body = $root.ELt.fromObject(object.e_lt_body);
        }
        if (object.e_lte_body != null) {
            if (typeof object.e_lte_body !== "object")
                throw TypeError(".Expr.e_lte_body: object expected");
            message.e_lte_body = $root.ELte.fromObject(object.e_lte_body);
        }
        if (object.e_gt_body != null) {
            if (typeof object.e_gt_body !== "object")
                throw TypeError(".Expr.e_gt_body: object expected");
            message.e_gt_body = $root.EGt.fromObject(object.e_gt_body);
        }
        if (object.e_gte_body != null) {
            if (typeof object.e_gte_body !== "object")
                throw TypeError(".Expr.e_gte_body: object expected");
            message.e_gte_body = $root.EGte.fromObject(object.e_gte_body);
        }
        if (object.e_eq_body != null) {
            if (typeof object.e_eq_body !== "object")
                throw TypeError(".Expr.e_eq_body: object expected");
            message.e_eq_body = $root.EEq.fromObject(object.e_eq_body);
        }
        if (object.e_neq_body != null) {
            if (typeof object.e_neq_body !== "object")
                throw TypeError(".Expr.e_neq_body: object expected");
            message.e_neq_body = $root.ENeq.fromObject(object.e_neq_body);
        }
        if (object.e_and_body != null) {
            if (typeof object.e_and_body !== "object")
                throw TypeError(".Expr.e_and_body: object expected");
            message.e_and_body = $root.EAnd.fromObject(object.e_and_body);
        }
        if (object.e_or_body != null) {
            if (typeof object.e_or_body !== "object")
                throw TypeError(".Expr.e_or_body: object expected");
            message.e_or_body = $root.EOr.fromObject(object.e_or_body);
        }
        if (object.e_var_body != null) {
            if (typeof object.e_var_body !== "object")
                throw TypeError(".Expr.e_var_body: object expected");
            message.e_var_body = $root.EVar.fromObject(object.e_var_body);
        }
        if (object.e_list_body != null) {
            if (typeof object.e_list_body !== "object")
                throw TypeError(".Expr.e_list_body: object expected");
            message.e_list_body = $root.EList.fromObject(object.e_list_body);
        }
        if (object.e_tuple_body != null) {
            if (typeof object.e_tuple_body !== "object")
                throw TypeError(".Expr.e_tuple_body: object expected");
            message.e_tuple_body = $root.ETuple.fromObject(object.e_tuple_body);
        }
        if (object.e_set_body != null) {
            if (typeof object.e_set_body !== "object")
                throw TypeError(".Expr.e_set_body: object expected");
            message.e_set_body = $root.ESet.fromObject(object.e_set_body);
        }
        if (object.e_map_body != null) {
            if (typeof object.e_map_body !== "object")
                throw TypeError(".Expr.e_map_body: object expected");
            message.e_map_body = $root.EMap.fromObject(object.e_map_body);
        }
        if (object.e_method_body != null) {
            if (typeof object.e_method_body !== "object")
                throw TypeError(".Expr.e_method_body: object expected");
            message.e_method_body = $root.EMethod.fromObject(object.e_method_body);
        }
        if (object.e_matches_body != null) {
            if (typeof object.e_matches_body !== "object")
                throw TypeError(".Expr.e_matches_body: object expected");
            message.e_matches_body = $root.EMatches.fromObject(object.e_matches_body);
        }
        if (object.e_percent_percent_body != null) {
            if (typeof object.e_percent_percent_body !== "object")
                throw TypeError(".Expr.e_percent_percent_body: object expected");
            message.e_percent_percent_body = $root.EPercentPercent.fromObject(object.e_percent_percent_body);
        }
        if (object.e_plus_plus_body != null) {
            if (typeof object.e_plus_plus_body !== "object")
                throw TypeError(".Expr.e_plus_plus_body: object expected");
            message.e_plus_plus_body = $root.EPlusPlus.fromObject(object.e_plus_plus_body);
        }
        if (object.e_minus_minus_body != null) {
            if (typeof object.e_minus_minus_body !== "object")
                throw TypeError(".Expr.e_minus_minus_body: object expected");
            message.e_minus_minus_body = $root.EMinusMinus.fromObject(object.e_minus_minus_body);
        }
        if (object.e_mod_body != null) {
            if (typeof object.e_mod_body !== "object")
                throw TypeError(".Expr.e_mod_body: object expected");
            message.e_mod_body = $root.EMod.fromObject(object.e_mod_body);
        }
        return message;
    };

    /**
     * Creates a plain object from an Expr message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Expr
     * @static
     * @param {Expr} message Expr
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Expr.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (message.g_bool != null && message.hasOwnProperty("g_bool")) {
            object.g_bool = message.g_bool;
            if (options.oneofs)
                object.expr_instance = "g_bool";
        }
        if (message.g_int != null && message.hasOwnProperty("g_int")) {
            if (typeof message.g_int === "number")
                object.g_int = options.longs === String ? String(message.g_int) : message.g_int;
            else
                object.g_int = options.longs === String ? $util.Long.prototype.toString.call(message.g_int) : options.longs === Number ? new $util.LongBits(message.g_int.low >>> 0, message.g_int.high >>> 0).toNumber() : message.g_int;
            if (options.oneofs)
                object.expr_instance = "g_int";
        }
        if (message.g_string != null && message.hasOwnProperty("g_string")) {
            object.g_string = message.g_string;
            if (options.oneofs)
                object.expr_instance = "g_string";
        }
        if (message.g_uri != null && message.hasOwnProperty("g_uri")) {
            object.g_uri = message.g_uri;
            if (options.oneofs)
                object.expr_instance = "g_uri";
        }
        if (message.e_not_body != null && message.hasOwnProperty("e_not_body")) {
            object.e_not_body = $root.ENot.toObject(message.e_not_body, options);
            if (options.oneofs)
                object.expr_instance = "e_not_body";
        }
        if (message.e_neg_body != null && message.hasOwnProperty("e_neg_body")) {
            object.e_neg_body = $root.ENeg.toObject(message.e_neg_body, options);
            if (options.oneofs)
                object.expr_instance = "e_neg_body";
        }
        if (message.e_mult_body != null && message.hasOwnProperty("e_mult_body")) {
            object.e_mult_body = $root.EMult.toObject(message.e_mult_body, options);
            if (options.oneofs)
                object.expr_instance = "e_mult_body";
        }
        if (message.e_div_body != null && message.hasOwnProperty("e_div_body")) {
            object.e_div_body = $root.EDiv.toObject(message.e_div_body, options);
            if (options.oneofs)
                object.expr_instance = "e_div_body";
        }
        if (message.e_plus_body != null && message.hasOwnProperty("e_plus_body")) {
            object.e_plus_body = $root.EPlus.toObject(message.e_plus_body, options);
            if (options.oneofs)
                object.expr_instance = "e_plus_body";
        }
        if (message.e_minus_body != null && message.hasOwnProperty("e_minus_body")) {
            object.e_minus_body = $root.EMinus.toObject(message.e_minus_body, options);
            if (options.oneofs)
                object.expr_instance = "e_minus_body";
        }
        if (message.e_lt_body != null && message.hasOwnProperty("e_lt_body")) {
            object.e_lt_body = $root.ELt.toObject(message.e_lt_body, options);
            if (options.oneofs)
                object.expr_instance = "e_lt_body";
        }
        if (message.e_lte_body != null && message.hasOwnProperty("e_lte_body")) {
            object.e_lte_body = $root.ELte.toObject(message.e_lte_body, options);
            if (options.oneofs)
                object.expr_instance = "e_lte_body";
        }
        if (message.e_gt_body != null && message.hasOwnProperty("e_gt_body")) {
            object.e_gt_body = $root.EGt.toObject(message.e_gt_body, options);
            if (options.oneofs)
                object.expr_instance = "e_gt_body";
        }
        if (message.e_gte_body != null && message.hasOwnProperty("e_gte_body")) {
            object.e_gte_body = $root.EGte.toObject(message.e_gte_body, options);
            if (options.oneofs)
                object.expr_instance = "e_gte_body";
        }
        if (message.e_eq_body != null && message.hasOwnProperty("e_eq_body")) {
            object.e_eq_body = $root.EEq.toObject(message.e_eq_body, options);
            if (options.oneofs)
                object.expr_instance = "e_eq_body";
        }
        if (message.e_neq_body != null && message.hasOwnProperty("e_neq_body")) {
            object.e_neq_body = $root.ENeq.toObject(message.e_neq_body, options);
            if (options.oneofs)
                object.expr_instance = "e_neq_body";
        }
        if (message.e_and_body != null && message.hasOwnProperty("e_and_body")) {
            object.e_and_body = $root.EAnd.toObject(message.e_and_body, options);
            if (options.oneofs)
                object.expr_instance = "e_and_body";
        }
        if (message.e_or_body != null && message.hasOwnProperty("e_or_body")) {
            object.e_or_body = $root.EOr.toObject(message.e_or_body, options);
            if (options.oneofs)
                object.expr_instance = "e_or_body";
        }
        if (message.e_var_body != null && message.hasOwnProperty("e_var_body")) {
            object.e_var_body = $root.EVar.toObject(message.e_var_body, options);
            if (options.oneofs)
                object.expr_instance = "e_var_body";
        }
        if (message.e_list_body != null && message.hasOwnProperty("e_list_body")) {
            object.e_list_body = $root.EList.toObject(message.e_list_body, options);
            if (options.oneofs)
                object.expr_instance = "e_list_body";
        }
        if (message.e_tuple_body != null && message.hasOwnProperty("e_tuple_body")) {
            object.e_tuple_body = $root.ETuple.toObject(message.e_tuple_body, options);
            if (options.oneofs)
                object.expr_instance = "e_tuple_body";
        }
        if (message.e_set_body != null && message.hasOwnProperty("e_set_body")) {
            object.e_set_body = $root.ESet.toObject(message.e_set_body, options);
            if (options.oneofs)
                object.expr_instance = "e_set_body";
        }
        if (message.e_map_body != null && message.hasOwnProperty("e_map_body")) {
            object.e_map_body = $root.EMap.toObject(message.e_map_body, options);
            if (options.oneofs)
                object.expr_instance = "e_map_body";
        }
        if (message.e_method_body != null && message.hasOwnProperty("e_method_body")) {
            object.e_method_body = $root.EMethod.toObject(message.e_method_body, options);
            if (options.oneofs)
                object.expr_instance = "e_method_body";
        }
        if (message.g_byte_array != null && message.hasOwnProperty("g_byte_array")) {
            object.g_byte_array = options.bytes === String ? $util.base64.encode(message.g_byte_array, 0, message.g_byte_array.length) : options.bytes === Array ? Array.prototype.slice.call(message.g_byte_array) : message.g_byte_array;
            if (options.oneofs)
                object.expr_instance = "g_byte_array";
        }
        if (message.e_matches_body != null && message.hasOwnProperty("e_matches_body")) {
            object.e_matches_body = $root.EMatches.toObject(message.e_matches_body, options);
            if (options.oneofs)
                object.expr_instance = "e_matches_body";
        }
        if (message.e_percent_percent_body != null && message.hasOwnProperty("e_percent_percent_body")) {
            object.e_percent_percent_body = $root.EPercentPercent.toObject(message.e_percent_percent_body, options);
            if (options.oneofs)
                object.expr_instance = "e_percent_percent_body";
        }
        if (message.e_plus_plus_body != null && message.hasOwnProperty("e_plus_plus_body")) {
            object.e_plus_plus_body = $root.EPlusPlus.toObject(message.e_plus_plus_body, options);
            if (options.oneofs)
                object.expr_instance = "e_plus_plus_body";
        }
        if (message.e_minus_minus_body != null && message.hasOwnProperty("e_minus_minus_body")) {
            object.e_minus_minus_body = $root.EMinusMinus.toObject(message.e_minus_minus_body, options);
            if (options.oneofs)
                object.expr_instance = "e_minus_minus_body";
        }
        if (message.e_mod_body != null && message.hasOwnProperty("e_mod_body")) {
            object.e_mod_body = $root.EMod.toObject(message.e_mod_body, options);
            if (options.oneofs)
                object.expr_instance = "e_mod_body";
        }
        return object;
    };

    /**
     * Converts this Expr to JSON.
     * @function toJSON
     * @memberof Expr
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Expr.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Expr;
})();

$root.EList = (function() {

    /**
     * Properties of a EList.
     * @exports IEList
     * @interface IEList
     * @property {Array.<IPar>|null} [ps] EList ps
     * @property {Uint8Array|null} [locallyFree] EList locallyFree
     * @property {boolean|null} [connective_used] EList connective_used
     * @property {IVar|null} [remainder] EList remainder
     */

    /**
     * Constructs a new EList.
     * @exports EList
     * @classdesc Represents a EList.
     * @implements IEList
     * @constructor
     * @param {IEList=} [properties] Properties to set
     */
    function EList(properties) {
        this.ps = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EList ps.
     * @member {Array.<IPar>} ps
     * @memberof EList
     * @instance
     */
    EList.prototype.ps = $util.emptyArray;

    /**
     * EList locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof EList
     * @instance
     */
    EList.prototype.locallyFree = $util.newBuffer([]);

    /**
     * EList connective_used.
     * @member {boolean} connective_used
     * @memberof EList
     * @instance
     */
    EList.prototype.connective_used = false;

    /**
     * EList remainder.
     * @member {IVar|null|undefined} remainder
     * @memberof EList
     * @instance
     */
    EList.prototype.remainder = null;

    /**
     * Creates a new EList instance using the specified properties.
     * @function create
     * @memberof EList
     * @static
     * @param {IEList=} [properties] Properties to set
     * @returns {EList} EList instance
     */
    EList.create = function create(properties) {
        return new EList(properties);
    };

    /**
     * Encodes the specified EList message. Does not implicitly {@link EList.verify|verify} messages.
     * @function encode
     * @memberof EList
     * @static
     * @param {IEList} message EList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EList.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ps != null && message.ps.length)
            for (var i = 0; i < message.ps.length; ++i)
                $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            $root.Var.encode(message.remainder, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EList message, length delimited. Does not implicitly {@link EList.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EList
     * @static
     * @param {IEList} message EList message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EList message from the specified reader or buffer.
     * @function decode
     * @memberof EList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EList} EList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.ps && message.ps.length))
                    message.ps = [];
                message.ps.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 3:
                message.locallyFree = reader.bytes();
                break;
            case 4:
                message.connective_used = reader.bool();
                break;
            case 5:
                message.remainder = $root.Var.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EList message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EList} EList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EList message.
     * @function verify
     * @memberof EList
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EList.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ps != null && message.hasOwnProperty("ps")) {
            if (!Array.isArray(message.ps))
                return "ps: array expected";
            for (var i = 0; i < message.ps.length; ++i) {
                var error = $root.Par.verify(message.ps[i]);
                if (error)
                    return "ps." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        if (message.remainder != null && message.hasOwnProperty("remainder")) {
            var error = $root.Var.verify(message.remainder);
            if (error)
                return "remainder." + error;
        }
        return null;
    };

    /**
     * Creates a EList message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EList
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EList} EList
     */
    EList.fromObject = function fromObject(object) {
        if (object instanceof $root.EList)
            return object;
        var message = new $root.EList();
        if (object.ps) {
            if (!Array.isArray(object.ps))
                throw TypeError(".EList.ps: array expected");
            message.ps = [];
            for (var i = 0; i < object.ps.length; ++i) {
                if (typeof object.ps[i] !== "object")
                    throw TypeError(".EList.ps: object expected");
                message.ps[i] = $root.Par.fromObject(object.ps[i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        if (object.remainder != null) {
            if (typeof object.remainder !== "object")
                throw TypeError(".EList.remainder: object expected");
            message.remainder = $root.Var.fromObject(object.remainder);
        }
        return message;
    };

    /**
     * Creates a plain object from a EList message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EList
     * @static
     * @param {EList} message EList
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EList.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ps = [];
        if (options.defaults) {
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
            object.remainder = null;
        }
        if (message.ps && message.ps.length) {
            object.ps = [];
            for (var j = 0; j < message.ps.length; ++j)
                object.ps[j] = $root.Par.toObject(message.ps[j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            object.remainder = $root.Var.toObject(message.remainder, options);
        return object;
    };

    /**
     * Converts this EList to JSON.
     * @function toJSON
     * @memberof EList
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EList;
})();

$root.ETuple = (function() {

    /**
     * Properties of a ETuple.
     * @exports IETuple
     * @interface IETuple
     * @property {Array.<IPar>|null} [ps] ETuple ps
     * @property {Uint8Array|null} [locallyFree] ETuple locallyFree
     * @property {boolean|null} [connective_used] ETuple connective_used
     */

    /**
     * Constructs a new ETuple.
     * @exports ETuple
     * @classdesc Represents a ETuple.
     * @implements IETuple
     * @constructor
     * @param {IETuple=} [properties] Properties to set
     */
    function ETuple(properties) {
        this.ps = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ETuple ps.
     * @member {Array.<IPar>} ps
     * @memberof ETuple
     * @instance
     */
    ETuple.prototype.ps = $util.emptyArray;

    /**
     * ETuple locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof ETuple
     * @instance
     */
    ETuple.prototype.locallyFree = $util.newBuffer([]);

    /**
     * ETuple connective_used.
     * @member {boolean} connective_used
     * @memberof ETuple
     * @instance
     */
    ETuple.prototype.connective_used = false;

    /**
     * Creates a new ETuple instance using the specified properties.
     * @function create
     * @memberof ETuple
     * @static
     * @param {IETuple=} [properties] Properties to set
     * @returns {ETuple} ETuple instance
     */
    ETuple.create = function create(properties) {
        return new ETuple(properties);
    };

    /**
     * Encodes the specified ETuple message. Does not implicitly {@link ETuple.verify|verify} messages.
     * @function encode
     * @memberof ETuple
     * @static
     * @param {IETuple} message ETuple message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ETuple.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ps != null && message.ps.length)
            for (var i = 0; i < message.ps.length; ++i)
                $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
        return writer;
    };

    /**
     * Encodes the specified ETuple message, length delimited. Does not implicitly {@link ETuple.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ETuple
     * @static
     * @param {IETuple} message ETuple message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ETuple.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ETuple message from the specified reader or buffer.
     * @function decode
     * @memberof ETuple
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ETuple} ETuple
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ETuple.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ETuple();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.ps && message.ps.length))
                    message.ps = [];
                message.ps.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 3:
                message.locallyFree = reader.bytes();
                break;
            case 4:
                message.connective_used = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ETuple message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ETuple
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ETuple} ETuple
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ETuple.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ETuple message.
     * @function verify
     * @memberof ETuple
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ETuple.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ps != null && message.hasOwnProperty("ps")) {
            if (!Array.isArray(message.ps))
                return "ps: array expected";
            for (var i = 0; i < message.ps.length; ++i) {
                var error = $root.Par.verify(message.ps[i]);
                if (error)
                    return "ps." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        return null;
    };

    /**
     * Creates a ETuple message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ETuple
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ETuple} ETuple
     */
    ETuple.fromObject = function fromObject(object) {
        if (object instanceof $root.ETuple)
            return object;
        var message = new $root.ETuple();
        if (object.ps) {
            if (!Array.isArray(object.ps))
                throw TypeError(".ETuple.ps: array expected");
            message.ps = [];
            for (var i = 0; i < object.ps.length; ++i) {
                if (typeof object.ps[i] !== "object")
                    throw TypeError(".ETuple.ps: object expected");
                message.ps[i] = $root.Par.fromObject(object.ps[i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        return message;
    };

    /**
     * Creates a plain object from a ETuple message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ETuple
     * @static
     * @param {ETuple} message ETuple
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ETuple.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ps = [];
        if (options.defaults) {
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
        }
        if (message.ps && message.ps.length) {
            object.ps = [];
            for (var j = 0; j < message.ps.length; ++j)
                object.ps[j] = $root.Par.toObject(message.ps[j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        return object;
    };

    /**
     * Converts this ETuple to JSON.
     * @function toJSON
     * @memberof ETuple
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ETuple.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ETuple;
})();

$root.ESet = (function() {

    /**
     * Properties of a ESet.
     * @exports IESet
     * @interface IESet
     * @property {Array.<IPar>|null} [ps] ESet ps
     * @property {Uint8Array|null} [locallyFree] ESet locallyFree
     * @property {boolean|null} [connective_used] ESet connective_used
     * @property {IVar|null} [remainder] ESet remainder
     */

    /**
     * Constructs a new ESet.
     * @exports ESet
     * @classdesc Represents a ESet.
     * @implements IESet
     * @constructor
     * @param {IESet=} [properties] Properties to set
     */
    function ESet(properties) {
        this.ps = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ESet ps.
     * @member {Array.<IPar>} ps
     * @memberof ESet
     * @instance
     */
    ESet.prototype.ps = $util.emptyArray;

    /**
     * ESet locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof ESet
     * @instance
     */
    ESet.prototype.locallyFree = $util.newBuffer([]);

    /**
     * ESet connective_used.
     * @member {boolean} connective_used
     * @memberof ESet
     * @instance
     */
    ESet.prototype.connective_used = false;

    /**
     * ESet remainder.
     * @member {IVar|null|undefined} remainder
     * @memberof ESet
     * @instance
     */
    ESet.prototype.remainder = null;

    /**
     * Creates a new ESet instance using the specified properties.
     * @function create
     * @memberof ESet
     * @static
     * @param {IESet=} [properties] Properties to set
     * @returns {ESet} ESet instance
     */
    ESet.create = function create(properties) {
        return new ESet(properties);
    };

    /**
     * Encodes the specified ESet message. Does not implicitly {@link ESet.verify|verify} messages.
     * @function encode
     * @memberof ESet
     * @static
     * @param {IESet} message ESet message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ESet.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ps != null && message.ps.length)
            for (var i = 0; i < message.ps.length; ++i)
                $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            $root.Var.encode(message.remainder, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ESet message, length delimited. Does not implicitly {@link ESet.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ESet
     * @static
     * @param {IESet} message ESet message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ESet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ESet message from the specified reader or buffer.
     * @function decode
     * @memberof ESet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ESet} ESet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ESet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ESet();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.ps && message.ps.length))
                    message.ps = [];
                message.ps.push($root.Par.decode(reader, reader.uint32()));
                break;
            case 3:
                message.locallyFree = reader.bytes();
                break;
            case 4:
                message.connective_used = reader.bool();
                break;
            case 5:
                message.remainder = $root.Var.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ESet message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ESet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ESet} ESet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ESet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ESet message.
     * @function verify
     * @memberof ESet
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ESet.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ps != null && message.hasOwnProperty("ps")) {
            if (!Array.isArray(message.ps))
                return "ps: array expected";
            for (var i = 0; i < message.ps.length; ++i) {
                var error = $root.Par.verify(message.ps[i]);
                if (error)
                    return "ps." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        if (message.remainder != null && message.hasOwnProperty("remainder")) {
            var error = $root.Var.verify(message.remainder);
            if (error)
                return "remainder." + error;
        }
        return null;
    };

    /**
     * Creates a ESet message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ESet
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ESet} ESet
     */
    ESet.fromObject = function fromObject(object) {
        if (object instanceof $root.ESet)
            return object;
        var message = new $root.ESet();
        if (object.ps) {
            if (!Array.isArray(object.ps))
                throw TypeError(".ESet.ps: array expected");
            message.ps = [];
            for (var i = 0; i < object.ps.length; ++i) {
                if (typeof object.ps[i] !== "object")
                    throw TypeError(".ESet.ps: object expected");
                message.ps[i] = $root.Par.fromObject(object.ps[i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        if (object.remainder != null) {
            if (typeof object.remainder !== "object")
                throw TypeError(".ESet.remainder: object expected");
            message.remainder = $root.Var.fromObject(object.remainder);
        }
        return message;
    };

    /**
     * Creates a plain object from a ESet message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ESet
     * @static
     * @param {ESet} message ESet
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ESet.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ps = [];
        if (options.defaults) {
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
            object.remainder = null;
        }
        if (message.ps && message.ps.length) {
            object.ps = [];
            for (var j = 0; j < message.ps.length; ++j)
                object.ps[j] = $root.Par.toObject(message.ps[j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            object.remainder = $root.Var.toObject(message.remainder, options);
        return object;
    };

    /**
     * Converts this ESet to JSON.
     * @function toJSON
     * @memberof ESet
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ESet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ESet;
})();

$root.EMap = (function() {

    /**
     * Properties of a EMap.
     * @exports IEMap
     * @interface IEMap
     * @property {Array.<IKeyValuePair>|null} [kvs] EMap kvs
     * @property {Uint8Array|null} [locallyFree] EMap locallyFree
     * @property {boolean|null} [connective_used] EMap connective_used
     * @property {IVar|null} [remainder] EMap remainder
     */

    /**
     * Constructs a new EMap.
     * @exports EMap
     * @classdesc Represents a EMap.
     * @implements IEMap
     * @constructor
     * @param {IEMap=} [properties] Properties to set
     */
    function EMap(properties) {
        this.kvs = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMap kvs.
     * @member {Array.<IKeyValuePair>} kvs
     * @memberof EMap
     * @instance
     */
    EMap.prototype.kvs = $util.emptyArray;

    /**
     * EMap locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof EMap
     * @instance
     */
    EMap.prototype.locallyFree = $util.newBuffer([]);

    /**
     * EMap connective_used.
     * @member {boolean} connective_used
     * @memberof EMap
     * @instance
     */
    EMap.prototype.connective_used = false;

    /**
     * EMap remainder.
     * @member {IVar|null|undefined} remainder
     * @memberof EMap
     * @instance
     */
    EMap.prototype.remainder = null;

    /**
     * Creates a new EMap instance using the specified properties.
     * @function create
     * @memberof EMap
     * @static
     * @param {IEMap=} [properties] Properties to set
     * @returns {EMap} EMap instance
     */
    EMap.create = function create(properties) {
        return new EMap(properties);
    };

    /**
     * Encodes the specified EMap message. Does not implicitly {@link EMap.verify|verify} messages.
     * @function encode
     * @memberof EMap
     * @static
     * @param {IEMap} message EMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMap.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.kvs != null && message.kvs.length)
            for (var i = 0; i < message.kvs.length; ++i)
                $root.KeyValuePair.encode(message.kvs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            $root.Var.encode(message.remainder, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EMap message, length delimited. Does not implicitly {@link EMap.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMap
     * @static
     * @param {IEMap} message EMap message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMap message from the specified reader or buffer.
     * @function decode
     * @memberof EMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMap} EMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.kvs && message.kvs.length))
                    message.kvs = [];
                message.kvs.push($root.KeyValuePair.decode(reader, reader.uint32()));
                break;
            case 3:
                message.locallyFree = reader.bytes();
                break;
            case 4:
                message.connective_used = reader.bool();
                break;
            case 5:
                message.remainder = $root.Var.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMap message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMap
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMap} EMap
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMap message.
     * @function verify
     * @memberof EMap
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMap.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.kvs != null && message.hasOwnProperty("kvs")) {
            if (!Array.isArray(message.kvs))
                return "kvs: array expected";
            for (var i = 0; i < message.kvs.length; ++i) {
                var error = $root.KeyValuePair.verify(message.kvs[i]);
                if (error)
                    return "kvs." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        if (message.remainder != null && message.hasOwnProperty("remainder")) {
            var error = $root.Var.verify(message.remainder);
            if (error)
                return "remainder." + error;
        }
        return null;
    };

    /**
     * Creates a EMap message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMap
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMap} EMap
     */
    EMap.fromObject = function fromObject(object) {
        if (object instanceof $root.EMap)
            return object;
        var message = new $root.EMap();
        if (object.kvs) {
            if (!Array.isArray(object.kvs))
                throw TypeError(".EMap.kvs: array expected");
            message.kvs = [];
            for (var i = 0; i < object.kvs.length; ++i) {
                if (typeof object.kvs[i] !== "object")
                    throw TypeError(".EMap.kvs: object expected");
                message.kvs[i] = $root.KeyValuePair.fromObject(object.kvs[i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        if (object.remainder != null) {
            if (typeof object.remainder !== "object")
                throw TypeError(".EMap.remainder: object expected");
            message.remainder = $root.Var.fromObject(object.remainder);
        }
        return message;
    };

    /**
     * Creates a plain object from a EMap message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMap
     * @static
     * @param {EMap} message EMap
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMap.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.kvs = [];
        if (options.defaults) {
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
            object.remainder = null;
        }
        if (message.kvs && message.kvs.length) {
            object.kvs = [];
            for (var j = 0; j < message.kvs.length; ++j)
                object.kvs[j] = $root.KeyValuePair.toObject(message.kvs[j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        if (message.remainder != null && message.hasOwnProperty("remainder"))
            object.remainder = $root.Var.toObject(message.remainder, options);
        return object;
    };

    /**
     * Converts this EMap to JSON.
     * @function toJSON
     * @memberof EMap
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMap;
})();

$root.EMethod = (function() {

    /**
     * Properties of a EMethod.
     * @exports IEMethod
     * @interface IEMethod
     * @property {string|null} [methodName] EMethod methodName
     * @property {IPar|null} [target] EMethod target
     * @property {Array.<IPar>|null} ["arguments"] EMethod arguments
     * @property {Uint8Array|null} [locallyFree] EMethod locallyFree
     * @property {boolean|null} [connective_used] EMethod connective_used
     */

    /**
     * Constructs a new EMethod.
     * @exports EMethod
     * @classdesc `target.method(arguments)`
     * @implements IEMethod
     * @constructor
     * @param {IEMethod=} [properties] Properties to set
     */
    function EMethod(properties) {
        this["arguments"] = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMethod methodName.
     * @member {string} methodName
     * @memberof EMethod
     * @instance
     */
    EMethod.prototype.methodName = "";

    /**
     * EMethod target.
     * @member {IPar|null|undefined} target
     * @memberof EMethod
     * @instance
     */
    EMethod.prototype.target = null;

    /**
     * EMethod arguments.
     * @member {Array.<IPar>} arguments
     * @memberof EMethod
     * @instance
     */
    EMethod.prototype["arguments"] = $util.emptyArray;

    /**
     * EMethod locallyFree.
     * @member {Uint8Array} locallyFree
     * @memberof EMethod
     * @instance
     */
    EMethod.prototype.locallyFree = $util.newBuffer([]);

    /**
     * EMethod connective_used.
     * @member {boolean} connective_used
     * @memberof EMethod
     * @instance
     */
    EMethod.prototype.connective_used = false;

    /**
     * Creates a new EMethod instance using the specified properties.
     * @function create
     * @memberof EMethod
     * @static
     * @param {IEMethod=} [properties] Properties to set
     * @returns {EMethod} EMethod instance
     */
    EMethod.create = function create(properties) {
        return new EMethod(properties);
    };

    /**
     * Encodes the specified EMethod message. Does not implicitly {@link EMethod.verify|verify} messages.
     * @function encode
     * @memberof EMethod
     * @static
     * @param {IEMethod} message EMethod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMethod.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.methodName != null && message.hasOwnProperty("methodName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.methodName);
        if (message.target != null && message.hasOwnProperty("target"))
            $root.Par.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message["arguments"] != null && message["arguments"].length)
            for (var i = 0; i < message["arguments"].length; ++i)
                $root.Par.encode(message["arguments"][i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.locallyFree);
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.connective_used);
        return writer;
    };

    /**
     * Encodes the specified EMethod message, length delimited. Does not implicitly {@link EMethod.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMethod
     * @static
     * @param {IEMethod} message EMethod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMethod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMethod message from the specified reader or buffer.
     * @function decode
     * @memberof EMethod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMethod} EMethod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMethod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMethod();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.methodName = reader.string();
                break;
            case 2:
                message.target = $root.Par.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message["arguments"] && message["arguments"].length))
                    message["arguments"] = [];
                message["arguments"].push($root.Par.decode(reader, reader.uint32()));
                break;
            case 5:
                message.locallyFree = reader.bytes();
                break;
            case 6:
                message.connective_used = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMethod message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMethod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMethod} EMethod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMethod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMethod message.
     * @function verify
     * @memberof EMethod
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMethod.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.methodName != null && message.hasOwnProperty("methodName"))
            if (!$util.isString(message.methodName))
                return "methodName: string expected";
        if (message.target != null && message.hasOwnProperty("target")) {
            var error = $root.Par.verify(message.target);
            if (error)
                return "target." + error;
        }
        if (message["arguments"] != null && message.hasOwnProperty("arguments")) {
            if (!Array.isArray(message["arguments"]))
                return "arguments: array expected";
            for (var i = 0; i < message["arguments"].length; ++i) {
                var error = $root.Par.verify(message["arguments"][i]);
                if (error)
                    return "arguments." + error;
            }
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                return "locallyFree: buffer expected";
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            if (typeof message.connective_used !== "boolean")
                return "connective_used: boolean expected";
        return null;
    };

    /**
     * Creates a EMethod message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMethod
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMethod} EMethod
     */
    EMethod.fromObject = function fromObject(object) {
        if (object instanceof $root.EMethod)
            return object;
        var message = new $root.EMethod();
        if (object.methodName != null)
            message.methodName = String(object.methodName);
        if (object.target != null) {
            if (typeof object.target !== "object")
                throw TypeError(".EMethod.target: object expected");
            message.target = $root.Par.fromObject(object.target);
        }
        if (object["arguments"]) {
            if (!Array.isArray(object["arguments"]))
                throw TypeError(".EMethod.arguments: array expected");
            message["arguments"] = [];
            for (var i = 0; i < object["arguments"].length; ++i) {
                if (typeof object["arguments"][i] !== "object")
                    throw TypeError(".EMethod.arguments: object expected");
                message["arguments"][i] = $root.Par.fromObject(object["arguments"][i]);
            }
        }
        if (object.locallyFree != null)
            if (typeof object.locallyFree === "string")
                $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
            else if (object.locallyFree.length)
                message.locallyFree = object.locallyFree;
        if (object.connective_used != null)
            message.connective_used = Boolean(object.connective_used);
        return message;
    };

    /**
     * Creates a plain object from a EMethod message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMethod
     * @static
     * @param {EMethod} message EMethod
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMethod.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object["arguments"] = [];
        if (options.defaults) {
            object.methodName = "";
            object.target = null;
            if (options.bytes === String)
                object.locallyFree = "";
            else {
                object.locallyFree = [];
                if (options.bytes !== Array)
                    object.locallyFree = $util.newBuffer(object.locallyFree);
            }
            object.connective_used = false;
        }
        if (message.methodName != null && message.hasOwnProperty("methodName"))
            object.methodName = message.methodName;
        if (message.target != null && message.hasOwnProperty("target"))
            object.target = $root.Par.toObject(message.target, options);
        if (message["arguments"] && message["arguments"].length) {
            object["arguments"] = [];
            for (var j = 0; j < message["arguments"].length; ++j)
                object["arguments"][j] = $root.Par.toObject(message["arguments"][j], options);
        }
        if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
            object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
        if (message.connective_used != null && message.hasOwnProperty("connective_used"))
            object.connective_used = message.connective_used;
        return object;
    };

    /**
     * Converts this EMethod to JSON.
     * @function toJSON
     * @memberof EMethod
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMethod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMethod;
})();

$root.KeyValuePair = (function() {

    /**
     * Properties of a KeyValuePair.
     * @exports IKeyValuePair
     * @interface IKeyValuePair
     * @property {IPar|null} [key] KeyValuePair key
     * @property {IPar|null} [value] KeyValuePair value
     */

    /**
     * Constructs a new KeyValuePair.
     * @exports KeyValuePair
     * @classdesc Represents a KeyValuePair.
     * @implements IKeyValuePair
     * @constructor
     * @param {IKeyValuePair=} [properties] Properties to set
     */
    function KeyValuePair(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * KeyValuePair key.
     * @member {IPar|null|undefined} key
     * @memberof KeyValuePair
     * @instance
     */
    KeyValuePair.prototype.key = null;

    /**
     * KeyValuePair value.
     * @member {IPar|null|undefined} value
     * @memberof KeyValuePair
     * @instance
     */
    KeyValuePair.prototype.value = null;

    /**
     * Creates a new KeyValuePair instance using the specified properties.
     * @function create
     * @memberof KeyValuePair
     * @static
     * @param {IKeyValuePair=} [properties] Properties to set
     * @returns {KeyValuePair} KeyValuePair instance
     */
    KeyValuePair.create = function create(properties) {
        return new KeyValuePair(properties);
    };

    /**
     * Encodes the specified KeyValuePair message. Does not implicitly {@link KeyValuePair.verify|verify} messages.
     * @function encode
     * @memberof KeyValuePair
     * @static
     * @param {IKeyValuePair} message KeyValuePair message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    KeyValuePair.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && message.hasOwnProperty("key"))
            $root.Par.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.value != null && message.hasOwnProperty("value"))
            $root.Par.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified KeyValuePair message, length delimited. Does not implicitly {@link KeyValuePair.verify|verify} messages.
     * @function encodeDelimited
     * @memberof KeyValuePair
     * @static
     * @param {IKeyValuePair} message KeyValuePair message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    KeyValuePair.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a KeyValuePair message from the specified reader or buffer.
     * @function decode
     * @memberof KeyValuePair
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {KeyValuePair} KeyValuePair
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    KeyValuePair.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeyValuePair();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.value = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a KeyValuePair message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof KeyValuePair
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {KeyValuePair} KeyValuePair
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    KeyValuePair.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a KeyValuePair message.
     * @function verify
     * @memberof KeyValuePair
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    KeyValuePair.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            var error = $root.Par.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.value != null && message.hasOwnProperty("value")) {
            var error = $root.Par.verify(message.value);
            if (error)
                return "value." + error;
        }
        return null;
    };

    /**
     * Creates a KeyValuePair message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof KeyValuePair
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {KeyValuePair} KeyValuePair
     */
    KeyValuePair.fromObject = function fromObject(object) {
        if (object instanceof $root.KeyValuePair)
            return object;
        var message = new $root.KeyValuePair();
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".KeyValuePair.key: object expected");
            message.key = $root.Par.fromObject(object.key);
        }
        if (object.value != null) {
            if (typeof object.value !== "object")
                throw TypeError(".KeyValuePair.value: object expected");
            message.value = $root.Par.fromObject(object.value);
        }
        return message;
    };

    /**
     * Creates a plain object from a KeyValuePair message. Also converts values to other types if specified.
     * @function toObject
     * @memberof KeyValuePair
     * @static
     * @param {KeyValuePair} message KeyValuePair
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    KeyValuePair.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.key = null;
            object.value = null;
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Par.toObject(message.key, options);
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = $root.Par.toObject(message.value, options);
        return object;
    };

    /**
     * Converts this KeyValuePair to JSON.
     * @function toJSON
     * @memberof KeyValuePair
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    KeyValuePair.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return KeyValuePair;
})();

$root.EVar = (function() {

    /**
     * Properties of a EVar.
     * @exports IEVar
     * @interface IEVar
     * @property {IVar|null} [v] EVar v
     */

    /**
     * Constructs a new EVar.
     * @exports EVar
     * @classdesc Represents a EVar.
     * @implements IEVar
     * @constructor
     * @param {IEVar=} [properties] Properties to set
     */
    function EVar(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EVar v.
     * @member {IVar|null|undefined} v
     * @memberof EVar
     * @instance
     */
    EVar.prototype.v = null;

    /**
     * Creates a new EVar instance using the specified properties.
     * @function create
     * @memberof EVar
     * @static
     * @param {IEVar=} [properties] Properties to set
     * @returns {EVar} EVar instance
     */
    EVar.create = function create(properties) {
        return new EVar(properties);
    };

    /**
     * Encodes the specified EVar message. Does not implicitly {@link EVar.verify|verify} messages.
     * @function encode
     * @memberof EVar
     * @static
     * @param {IEVar} message EVar message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EVar.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.hasOwnProperty("v"))
            $root.Var.encode(message.v, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EVar message, length delimited. Does not implicitly {@link EVar.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EVar
     * @static
     * @param {IEVar} message EVar message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EVar.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EVar message from the specified reader or buffer.
     * @function decode
     * @memberof EVar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EVar} EVar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EVar.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EVar();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.v = $root.Var.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EVar message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EVar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EVar} EVar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EVar.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EVar message.
     * @function verify
     * @memberof EVar
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EVar.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            var error = $root.Var.verify(message.v);
            if (error)
                return "v." + error;
        }
        return null;
    };

    /**
     * Creates a EVar message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EVar
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EVar} EVar
     */
    EVar.fromObject = function fromObject(object) {
        if (object instanceof $root.EVar)
            return object;
        var message = new $root.EVar();
        if (object.v != null) {
            if (typeof object.v !== "object")
                throw TypeError(".EVar.v: object expected");
            message.v = $root.Var.fromObject(object.v);
        }
        return message;
    };

    /**
     * Creates a plain object from a EVar message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EVar
     * @static
     * @param {EVar} message EVar
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EVar.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.v = null;
        if (message.v != null && message.hasOwnProperty("v"))
            object.v = $root.Var.toObject(message.v, options);
        return object;
    };

    /**
     * Converts this EVar to JSON.
     * @function toJSON
     * @memberof EVar
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EVar.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EVar;
})();

$root.ENot = (function() {

    /**
     * Properties of a ENot.
     * @exports IENot
     * @interface IENot
     * @property {IPar|null} [p] ENot p
     */

    /**
     * Constructs a new ENot.
     * @exports ENot
     * @classdesc Represents a ENot.
     * @implements IENot
     * @constructor
     * @param {IENot=} [properties] Properties to set
     */
    function ENot(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ENot p.
     * @member {IPar|null|undefined} p
     * @memberof ENot
     * @instance
     */
    ENot.prototype.p = null;

    /**
     * Creates a new ENot instance using the specified properties.
     * @function create
     * @memberof ENot
     * @static
     * @param {IENot=} [properties] Properties to set
     * @returns {ENot} ENot instance
     */
    ENot.create = function create(properties) {
        return new ENot(properties);
    };

    /**
     * Encodes the specified ENot message. Does not implicitly {@link ENot.verify|verify} messages.
     * @function encode
     * @memberof ENot
     * @static
     * @param {IENot} message ENot message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ENot.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p != null && message.hasOwnProperty("p"))
            $root.Par.encode(message.p, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ENot message, length delimited. Does not implicitly {@link ENot.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ENot
     * @static
     * @param {IENot} message ENot message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ENot.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ENot message from the specified reader or buffer.
     * @function decode
     * @memberof ENot
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ENot} ENot
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ENot.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ENot();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ENot message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ENot
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ENot} ENot
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ENot.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ENot message.
     * @function verify
     * @memberof ENot
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ENot.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p != null && message.hasOwnProperty("p")) {
            var error = $root.Par.verify(message.p);
            if (error)
                return "p." + error;
        }
        return null;
    };

    /**
     * Creates a ENot message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ENot
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ENot} ENot
     */
    ENot.fromObject = function fromObject(object) {
        if (object instanceof $root.ENot)
            return object;
        var message = new $root.ENot();
        if (object.p != null) {
            if (typeof object.p !== "object")
                throw TypeError(".ENot.p: object expected");
            message.p = $root.Par.fromObject(object.p);
        }
        return message;
    };

    /**
     * Creates a plain object from a ENot message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ENot
     * @static
     * @param {ENot} message ENot
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ENot.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.p = null;
        if (message.p != null && message.hasOwnProperty("p"))
            object.p = $root.Par.toObject(message.p, options);
        return object;
    };

    /**
     * Converts this ENot to JSON.
     * @function toJSON
     * @memberof ENot
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ENot.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ENot;
})();

$root.ENeg = (function() {

    /**
     * Properties of a ENeg.
     * @exports IENeg
     * @interface IENeg
     * @property {IPar|null} [p] ENeg p
     */

    /**
     * Constructs a new ENeg.
     * @exports ENeg
     * @classdesc Represents a ENeg.
     * @implements IENeg
     * @constructor
     * @param {IENeg=} [properties] Properties to set
     */
    function ENeg(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ENeg p.
     * @member {IPar|null|undefined} p
     * @memberof ENeg
     * @instance
     */
    ENeg.prototype.p = null;

    /**
     * Creates a new ENeg instance using the specified properties.
     * @function create
     * @memberof ENeg
     * @static
     * @param {IENeg=} [properties] Properties to set
     * @returns {ENeg} ENeg instance
     */
    ENeg.create = function create(properties) {
        return new ENeg(properties);
    };

    /**
     * Encodes the specified ENeg message. Does not implicitly {@link ENeg.verify|verify} messages.
     * @function encode
     * @memberof ENeg
     * @static
     * @param {IENeg} message ENeg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ENeg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p != null && message.hasOwnProperty("p"))
            $root.Par.encode(message.p, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ENeg message, length delimited. Does not implicitly {@link ENeg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ENeg
     * @static
     * @param {IENeg} message ENeg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ENeg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ENeg message from the specified reader or buffer.
     * @function decode
     * @memberof ENeg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ENeg} ENeg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ENeg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ENeg();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ENeg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ENeg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ENeg} ENeg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ENeg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ENeg message.
     * @function verify
     * @memberof ENeg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ENeg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p != null && message.hasOwnProperty("p")) {
            var error = $root.Par.verify(message.p);
            if (error)
                return "p." + error;
        }
        return null;
    };

    /**
     * Creates a ENeg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ENeg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ENeg} ENeg
     */
    ENeg.fromObject = function fromObject(object) {
        if (object instanceof $root.ENeg)
            return object;
        var message = new $root.ENeg();
        if (object.p != null) {
            if (typeof object.p !== "object")
                throw TypeError(".ENeg.p: object expected");
            message.p = $root.Par.fromObject(object.p);
        }
        return message;
    };

    /**
     * Creates a plain object from a ENeg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ENeg
     * @static
     * @param {ENeg} message ENeg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ENeg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.p = null;
        if (message.p != null && message.hasOwnProperty("p"))
            object.p = $root.Par.toObject(message.p, options);
        return object;
    };

    /**
     * Converts this ENeg to JSON.
     * @function toJSON
     * @memberof ENeg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ENeg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ENeg;
})();

$root.EMult = (function() {

    /**
     * Properties of a EMult.
     * @exports IEMult
     * @interface IEMult
     * @property {IPar|null} [p1] EMult p1
     * @property {IPar|null} [p2] EMult p2
     */

    /**
     * Constructs a new EMult.
     * @exports EMult
     * @classdesc Represents a EMult.
     * @implements IEMult
     * @constructor
     * @param {IEMult=} [properties] Properties to set
     */
    function EMult(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMult p1.
     * @member {IPar|null|undefined} p1
     * @memberof EMult
     * @instance
     */
    EMult.prototype.p1 = null;

    /**
     * EMult p2.
     * @member {IPar|null|undefined} p2
     * @memberof EMult
     * @instance
     */
    EMult.prototype.p2 = null;

    /**
     * Creates a new EMult instance using the specified properties.
     * @function create
     * @memberof EMult
     * @static
     * @param {IEMult=} [properties] Properties to set
     * @returns {EMult} EMult instance
     */
    EMult.create = function create(properties) {
        return new EMult(properties);
    };

    /**
     * Encodes the specified EMult message. Does not implicitly {@link EMult.verify|verify} messages.
     * @function encode
     * @memberof EMult
     * @static
     * @param {IEMult} message EMult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMult.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EMult message, length delimited. Does not implicitly {@link EMult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMult
     * @static
     * @param {IEMult} message EMult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMult.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMult message from the specified reader or buffer.
     * @function decode
     * @memberof EMult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMult} EMult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMult.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMult();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMult} EMult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMult.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMult message.
     * @function verify
     * @memberof EMult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMult.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EMult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMult} EMult
     */
    EMult.fromObject = function fromObject(object) {
        if (object instanceof $root.EMult)
            return object;
        var message = new $root.EMult();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EMult.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EMult.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EMult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMult
     * @static
     * @param {EMult} message EMult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMult.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EMult to JSON.
     * @function toJSON
     * @memberof EMult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMult.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMult;
})();

$root.EDiv = (function() {

    /**
     * Properties of a EDiv.
     * @exports IEDiv
     * @interface IEDiv
     * @property {IPar|null} [p1] EDiv p1
     * @property {IPar|null} [p2] EDiv p2
     */

    /**
     * Constructs a new EDiv.
     * @exports EDiv
     * @classdesc Represents a EDiv.
     * @implements IEDiv
     * @constructor
     * @param {IEDiv=} [properties] Properties to set
     */
    function EDiv(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EDiv p1.
     * @member {IPar|null|undefined} p1
     * @memberof EDiv
     * @instance
     */
    EDiv.prototype.p1 = null;

    /**
     * EDiv p2.
     * @member {IPar|null|undefined} p2
     * @memberof EDiv
     * @instance
     */
    EDiv.prototype.p2 = null;

    /**
     * Creates a new EDiv instance using the specified properties.
     * @function create
     * @memberof EDiv
     * @static
     * @param {IEDiv=} [properties] Properties to set
     * @returns {EDiv} EDiv instance
     */
    EDiv.create = function create(properties) {
        return new EDiv(properties);
    };

    /**
     * Encodes the specified EDiv message. Does not implicitly {@link EDiv.verify|verify} messages.
     * @function encode
     * @memberof EDiv
     * @static
     * @param {IEDiv} message EDiv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EDiv.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EDiv message, length delimited. Does not implicitly {@link EDiv.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EDiv
     * @static
     * @param {IEDiv} message EDiv message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EDiv.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EDiv message from the specified reader or buffer.
     * @function decode
     * @memberof EDiv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EDiv} EDiv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EDiv.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EDiv();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EDiv message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EDiv
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EDiv} EDiv
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EDiv.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EDiv message.
     * @function verify
     * @memberof EDiv
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EDiv.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EDiv message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EDiv
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EDiv} EDiv
     */
    EDiv.fromObject = function fromObject(object) {
        if (object instanceof $root.EDiv)
            return object;
        var message = new $root.EDiv();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EDiv.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EDiv.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EDiv message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EDiv
     * @static
     * @param {EDiv} message EDiv
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EDiv.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EDiv to JSON.
     * @function toJSON
     * @memberof EDiv
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EDiv.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EDiv;
})();

$root.EMod = (function() {

    /**
     * Properties of a EMod.
     * @exports IEMod
     * @interface IEMod
     * @property {IPar|null} [p1] EMod p1
     * @property {IPar|null} [p2] EMod p2
     */

    /**
     * Constructs a new EMod.
     * @exports EMod
     * @classdesc Represents a EMod.
     * @implements IEMod
     * @constructor
     * @param {IEMod=} [properties] Properties to set
     */
    function EMod(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMod p1.
     * @member {IPar|null|undefined} p1
     * @memberof EMod
     * @instance
     */
    EMod.prototype.p1 = null;

    /**
     * EMod p2.
     * @member {IPar|null|undefined} p2
     * @memberof EMod
     * @instance
     */
    EMod.prototype.p2 = null;

    /**
     * Creates a new EMod instance using the specified properties.
     * @function create
     * @memberof EMod
     * @static
     * @param {IEMod=} [properties] Properties to set
     * @returns {EMod} EMod instance
     */
    EMod.create = function create(properties) {
        return new EMod(properties);
    };

    /**
     * Encodes the specified EMod message. Does not implicitly {@link EMod.verify|verify} messages.
     * @function encode
     * @memberof EMod
     * @static
     * @param {IEMod} message EMod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMod.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EMod message, length delimited. Does not implicitly {@link EMod.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMod
     * @static
     * @param {IEMod} message EMod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMod message from the specified reader or buffer.
     * @function decode
     * @memberof EMod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMod} EMod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMod();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMod message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMod} EMod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMod message.
     * @function verify
     * @memberof EMod
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMod.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EMod message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMod
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMod} EMod
     */
    EMod.fromObject = function fromObject(object) {
        if (object instanceof $root.EMod)
            return object;
        var message = new $root.EMod();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EMod.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EMod.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EMod message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMod
     * @static
     * @param {EMod} message EMod
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMod.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EMod to JSON.
     * @function toJSON
     * @memberof EMod
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMod;
})();

$root.EPlus = (function() {

    /**
     * Properties of a EPlus.
     * @exports IEPlus
     * @interface IEPlus
     * @property {IPar|null} [p1] EPlus p1
     * @property {IPar|null} [p2] EPlus p2
     */

    /**
     * Constructs a new EPlus.
     * @exports EPlus
     * @classdesc Represents a EPlus.
     * @implements IEPlus
     * @constructor
     * @param {IEPlus=} [properties] Properties to set
     */
    function EPlus(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EPlus p1.
     * @member {IPar|null|undefined} p1
     * @memberof EPlus
     * @instance
     */
    EPlus.prototype.p1 = null;

    /**
     * EPlus p2.
     * @member {IPar|null|undefined} p2
     * @memberof EPlus
     * @instance
     */
    EPlus.prototype.p2 = null;

    /**
     * Creates a new EPlus instance using the specified properties.
     * @function create
     * @memberof EPlus
     * @static
     * @param {IEPlus=} [properties] Properties to set
     * @returns {EPlus} EPlus instance
     */
    EPlus.create = function create(properties) {
        return new EPlus(properties);
    };

    /**
     * Encodes the specified EPlus message. Does not implicitly {@link EPlus.verify|verify} messages.
     * @function encode
     * @memberof EPlus
     * @static
     * @param {IEPlus} message EPlus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EPlus.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EPlus message, length delimited. Does not implicitly {@link EPlus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EPlus
     * @static
     * @param {IEPlus} message EPlus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EPlus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EPlus message from the specified reader or buffer.
     * @function decode
     * @memberof EPlus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EPlus} EPlus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EPlus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EPlus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EPlus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EPlus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EPlus} EPlus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EPlus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EPlus message.
     * @function verify
     * @memberof EPlus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EPlus.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EPlus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EPlus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EPlus} EPlus
     */
    EPlus.fromObject = function fromObject(object) {
        if (object instanceof $root.EPlus)
            return object;
        var message = new $root.EPlus();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EPlus.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EPlus.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EPlus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EPlus
     * @static
     * @param {EPlus} message EPlus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EPlus.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EPlus to JSON.
     * @function toJSON
     * @memberof EPlus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EPlus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EPlus;
})();

$root.EMinus = (function() {

    /**
     * Properties of a EMinus.
     * @exports IEMinus
     * @interface IEMinus
     * @property {IPar|null} [p1] EMinus p1
     * @property {IPar|null} [p2] EMinus p2
     */

    /**
     * Constructs a new EMinus.
     * @exports EMinus
     * @classdesc Represents a EMinus.
     * @implements IEMinus
     * @constructor
     * @param {IEMinus=} [properties] Properties to set
     */
    function EMinus(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMinus p1.
     * @member {IPar|null|undefined} p1
     * @memberof EMinus
     * @instance
     */
    EMinus.prototype.p1 = null;

    /**
     * EMinus p2.
     * @member {IPar|null|undefined} p2
     * @memberof EMinus
     * @instance
     */
    EMinus.prototype.p2 = null;

    /**
     * Creates a new EMinus instance using the specified properties.
     * @function create
     * @memberof EMinus
     * @static
     * @param {IEMinus=} [properties] Properties to set
     * @returns {EMinus} EMinus instance
     */
    EMinus.create = function create(properties) {
        return new EMinus(properties);
    };

    /**
     * Encodes the specified EMinus message. Does not implicitly {@link EMinus.verify|verify} messages.
     * @function encode
     * @memberof EMinus
     * @static
     * @param {IEMinus} message EMinus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMinus.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EMinus message, length delimited. Does not implicitly {@link EMinus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMinus
     * @static
     * @param {IEMinus} message EMinus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMinus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMinus message from the specified reader or buffer.
     * @function decode
     * @memberof EMinus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMinus} EMinus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMinus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMinus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMinus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMinus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMinus} EMinus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMinus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMinus message.
     * @function verify
     * @memberof EMinus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMinus.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EMinus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMinus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMinus} EMinus
     */
    EMinus.fromObject = function fromObject(object) {
        if (object instanceof $root.EMinus)
            return object;
        var message = new $root.EMinus();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EMinus.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EMinus.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EMinus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMinus
     * @static
     * @param {EMinus} message EMinus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMinus.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EMinus to JSON.
     * @function toJSON
     * @memberof EMinus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMinus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMinus;
})();

$root.ELt = (function() {

    /**
     * Properties of a ELt.
     * @exports IELt
     * @interface IELt
     * @property {IPar|null} [p1] ELt p1
     * @property {IPar|null} [p2] ELt p2
     */

    /**
     * Constructs a new ELt.
     * @exports ELt
     * @classdesc Represents a ELt.
     * @implements IELt
     * @constructor
     * @param {IELt=} [properties] Properties to set
     */
    function ELt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ELt p1.
     * @member {IPar|null|undefined} p1
     * @memberof ELt
     * @instance
     */
    ELt.prototype.p1 = null;

    /**
     * ELt p2.
     * @member {IPar|null|undefined} p2
     * @memberof ELt
     * @instance
     */
    ELt.prototype.p2 = null;

    /**
     * Creates a new ELt instance using the specified properties.
     * @function create
     * @memberof ELt
     * @static
     * @param {IELt=} [properties] Properties to set
     * @returns {ELt} ELt instance
     */
    ELt.create = function create(properties) {
        return new ELt(properties);
    };

    /**
     * Encodes the specified ELt message. Does not implicitly {@link ELt.verify|verify} messages.
     * @function encode
     * @memberof ELt
     * @static
     * @param {IELt} message ELt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ELt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ELt message, length delimited. Does not implicitly {@link ELt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ELt
     * @static
     * @param {IELt} message ELt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ELt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ELt message from the specified reader or buffer.
     * @function decode
     * @memberof ELt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ELt} ELt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ELt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ELt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ELt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ELt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ELt} ELt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ELt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ELt message.
     * @function verify
     * @memberof ELt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ELt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a ELt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ELt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ELt} ELt
     */
    ELt.fromObject = function fromObject(object) {
        if (object instanceof $root.ELt)
            return object;
        var message = new $root.ELt();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".ELt.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".ELt.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a ELt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ELt
     * @static
     * @param {ELt} message ELt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ELt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this ELt to JSON.
     * @function toJSON
     * @memberof ELt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ELt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ELt;
})();

$root.ELte = (function() {

    /**
     * Properties of a ELte.
     * @exports IELte
     * @interface IELte
     * @property {IPar|null} [p1] ELte p1
     * @property {IPar|null} [p2] ELte p2
     */

    /**
     * Constructs a new ELte.
     * @exports ELte
     * @classdesc Represents a ELte.
     * @implements IELte
     * @constructor
     * @param {IELte=} [properties] Properties to set
     */
    function ELte(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ELte p1.
     * @member {IPar|null|undefined} p1
     * @memberof ELte
     * @instance
     */
    ELte.prototype.p1 = null;

    /**
     * ELte p2.
     * @member {IPar|null|undefined} p2
     * @memberof ELte
     * @instance
     */
    ELte.prototype.p2 = null;

    /**
     * Creates a new ELte instance using the specified properties.
     * @function create
     * @memberof ELte
     * @static
     * @param {IELte=} [properties] Properties to set
     * @returns {ELte} ELte instance
     */
    ELte.create = function create(properties) {
        return new ELte(properties);
    };

    /**
     * Encodes the specified ELte message. Does not implicitly {@link ELte.verify|verify} messages.
     * @function encode
     * @memberof ELte
     * @static
     * @param {IELte} message ELte message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ELte.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ELte message, length delimited. Does not implicitly {@link ELte.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ELte
     * @static
     * @param {IELte} message ELte message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ELte.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ELte message from the specified reader or buffer.
     * @function decode
     * @memberof ELte
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ELte} ELte
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ELte.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ELte();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ELte message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ELte
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ELte} ELte
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ELte.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ELte message.
     * @function verify
     * @memberof ELte
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ELte.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a ELte message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ELte
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ELte} ELte
     */
    ELte.fromObject = function fromObject(object) {
        if (object instanceof $root.ELte)
            return object;
        var message = new $root.ELte();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".ELte.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".ELte.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a ELte message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ELte
     * @static
     * @param {ELte} message ELte
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ELte.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this ELte to JSON.
     * @function toJSON
     * @memberof ELte
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ELte.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ELte;
})();

$root.EGt = (function() {

    /**
     * Properties of a EGt.
     * @exports IEGt
     * @interface IEGt
     * @property {IPar|null} [p1] EGt p1
     * @property {IPar|null} [p2] EGt p2
     */

    /**
     * Constructs a new EGt.
     * @exports EGt
     * @classdesc Represents a EGt.
     * @implements IEGt
     * @constructor
     * @param {IEGt=} [properties] Properties to set
     */
    function EGt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EGt p1.
     * @member {IPar|null|undefined} p1
     * @memberof EGt
     * @instance
     */
    EGt.prototype.p1 = null;

    /**
     * EGt p2.
     * @member {IPar|null|undefined} p2
     * @memberof EGt
     * @instance
     */
    EGt.prototype.p2 = null;

    /**
     * Creates a new EGt instance using the specified properties.
     * @function create
     * @memberof EGt
     * @static
     * @param {IEGt=} [properties] Properties to set
     * @returns {EGt} EGt instance
     */
    EGt.create = function create(properties) {
        return new EGt(properties);
    };

    /**
     * Encodes the specified EGt message. Does not implicitly {@link EGt.verify|verify} messages.
     * @function encode
     * @memberof EGt
     * @static
     * @param {IEGt} message EGt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EGt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EGt message, length delimited. Does not implicitly {@link EGt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EGt
     * @static
     * @param {IEGt} message EGt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EGt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EGt message from the specified reader or buffer.
     * @function decode
     * @memberof EGt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EGt} EGt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EGt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EGt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EGt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EGt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EGt} EGt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EGt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EGt message.
     * @function verify
     * @memberof EGt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EGt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EGt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EGt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EGt} EGt
     */
    EGt.fromObject = function fromObject(object) {
        if (object instanceof $root.EGt)
            return object;
        var message = new $root.EGt();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EGt.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EGt.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EGt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EGt
     * @static
     * @param {EGt} message EGt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EGt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EGt to JSON.
     * @function toJSON
     * @memberof EGt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EGt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EGt;
})();

$root.EGte = (function() {

    /**
     * Properties of a EGte.
     * @exports IEGte
     * @interface IEGte
     * @property {IPar|null} [p1] EGte p1
     * @property {IPar|null} [p2] EGte p2
     */

    /**
     * Constructs a new EGte.
     * @exports EGte
     * @classdesc Represents a EGte.
     * @implements IEGte
     * @constructor
     * @param {IEGte=} [properties] Properties to set
     */
    function EGte(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EGte p1.
     * @member {IPar|null|undefined} p1
     * @memberof EGte
     * @instance
     */
    EGte.prototype.p1 = null;

    /**
     * EGte p2.
     * @member {IPar|null|undefined} p2
     * @memberof EGte
     * @instance
     */
    EGte.prototype.p2 = null;

    /**
     * Creates a new EGte instance using the specified properties.
     * @function create
     * @memberof EGte
     * @static
     * @param {IEGte=} [properties] Properties to set
     * @returns {EGte} EGte instance
     */
    EGte.create = function create(properties) {
        return new EGte(properties);
    };

    /**
     * Encodes the specified EGte message. Does not implicitly {@link EGte.verify|verify} messages.
     * @function encode
     * @memberof EGte
     * @static
     * @param {IEGte} message EGte message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EGte.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EGte message, length delimited. Does not implicitly {@link EGte.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EGte
     * @static
     * @param {IEGte} message EGte message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EGte.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EGte message from the specified reader or buffer.
     * @function decode
     * @memberof EGte
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EGte} EGte
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EGte.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EGte();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EGte message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EGte
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EGte} EGte
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EGte.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EGte message.
     * @function verify
     * @memberof EGte
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EGte.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EGte message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EGte
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EGte} EGte
     */
    EGte.fromObject = function fromObject(object) {
        if (object instanceof $root.EGte)
            return object;
        var message = new $root.EGte();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EGte.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EGte.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EGte message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EGte
     * @static
     * @param {EGte} message EGte
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EGte.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EGte to JSON.
     * @function toJSON
     * @memberof EGte
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EGte.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EGte;
})();

$root.EEq = (function() {

    /**
     * Properties of a EEq.
     * @exports IEEq
     * @interface IEEq
     * @property {IPar|null} [p1] EEq p1
     * @property {IPar|null} [p2] EEq p2
     */

    /**
     * Constructs a new EEq.
     * @exports EEq
     * @classdesc Represents a EEq.
     * @implements IEEq
     * @constructor
     * @param {IEEq=} [properties] Properties to set
     */
    function EEq(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EEq p1.
     * @member {IPar|null|undefined} p1
     * @memberof EEq
     * @instance
     */
    EEq.prototype.p1 = null;

    /**
     * EEq p2.
     * @member {IPar|null|undefined} p2
     * @memberof EEq
     * @instance
     */
    EEq.prototype.p2 = null;

    /**
     * Creates a new EEq instance using the specified properties.
     * @function create
     * @memberof EEq
     * @static
     * @param {IEEq=} [properties] Properties to set
     * @returns {EEq} EEq instance
     */
    EEq.create = function create(properties) {
        return new EEq(properties);
    };

    /**
     * Encodes the specified EEq message. Does not implicitly {@link EEq.verify|verify} messages.
     * @function encode
     * @memberof EEq
     * @static
     * @param {IEEq} message EEq message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EEq.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EEq message, length delimited. Does not implicitly {@link EEq.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EEq
     * @static
     * @param {IEEq} message EEq message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EEq.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EEq message from the specified reader or buffer.
     * @function decode
     * @memberof EEq
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EEq} EEq
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EEq.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EEq();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EEq message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EEq
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EEq} EEq
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EEq.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EEq message.
     * @function verify
     * @memberof EEq
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EEq.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EEq message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EEq
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EEq} EEq
     */
    EEq.fromObject = function fromObject(object) {
        if (object instanceof $root.EEq)
            return object;
        var message = new $root.EEq();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EEq.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EEq.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EEq message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EEq
     * @static
     * @param {EEq} message EEq
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EEq.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EEq to JSON.
     * @function toJSON
     * @memberof EEq
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EEq.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EEq;
})();

$root.ENeq = (function() {

    /**
     * Properties of a ENeq.
     * @exports IENeq
     * @interface IENeq
     * @property {IPar|null} [p1] ENeq p1
     * @property {IPar|null} [p2] ENeq p2
     */

    /**
     * Constructs a new ENeq.
     * @exports ENeq
     * @classdesc Represents a ENeq.
     * @implements IENeq
     * @constructor
     * @param {IENeq=} [properties] Properties to set
     */
    function ENeq(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ENeq p1.
     * @member {IPar|null|undefined} p1
     * @memberof ENeq
     * @instance
     */
    ENeq.prototype.p1 = null;

    /**
     * ENeq p2.
     * @member {IPar|null|undefined} p2
     * @memberof ENeq
     * @instance
     */
    ENeq.prototype.p2 = null;

    /**
     * Creates a new ENeq instance using the specified properties.
     * @function create
     * @memberof ENeq
     * @static
     * @param {IENeq=} [properties] Properties to set
     * @returns {ENeq} ENeq instance
     */
    ENeq.create = function create(properties) {
        return new ENeq(properties);
    };

    /**
     * Encodes the specified ENeq message. Does not implicitly {@link ENeq.verify|verify} messages.
     * @function encode
     * @memberof ENeq
     * @static
     * @param {IENeq} message ENeq message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ENeq.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ENeq message, length delimited. Does not implicitly {@link ENeq.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ENeq
     * @static
     * @param {IENeq} message ENeq message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ENeq.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ENeq message from the specified reader or buffer.
     * @function decode
     * @memberof ENeq
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ENeq} ENeq
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ENeq.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ENeq();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ENeq message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ENeq
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ENeq} ENeq
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ENeq.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ENeq message.
     * @function verify
     * @memberof ENeq
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ENeq.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a ENeq message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ENeq
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ENeq} ENeq
     */
    ENeq.fromObject = function fromObject(object) {
        if (object instanceof $root.ENeq)
            return object;
        var message = new $root.ENeq();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".ENeq.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".ENeq.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a ENeq message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ENeq
     * @static
     * @param {ENeq} message ENeq
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ENeq.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this ENeq to JSON.
     * @function toJSON
     * @memberof ENeq
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ENeq.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ENeq;
})();

$root.EAnd = (function() {

    /**
     * Properties of a EAnd.
     * @exports IEAnd
     * @interface IEAnd
     * @property {IPar|null} [p1] EAnd p1
     * @property {IPar|null} [p2] EAnd p2
     */

    /**
     * Constructs a new EAnd.
     * @exports EAnd
     * @classdesc Represents a EAnd.
     * @implements IEAnd
     * @constructor
     * @param {IEAnd=} [properties] Properties to set
     */
    function EAnd(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EAnd p1.
     * @member {IPar|null|undefined} p1
     * @memberof EAnd
     * @instance
     */
    EAnd.prototype.p1 = null;

    /**
     * EAnd p2.
     * @member {IPar|null|undefined} p2
     * @memberof EAnd
     * @instance
     */
    EAnd.prototype.p2 = null;

    /**
     * Creates a new EAnd instance using the specified properties.
     * @function create
     * @memberof EAnd
     * @static
     * @param {IEAnd=} [properties] Properties to set
     * @returns {EAnd} EAnd instance
     */
    EAnd.create = function create(properties) {
        return new EAnd(properties);
    };

    /**
     * Encodes the specified EAnd message. Does not implicitly {@link EAnd.verify|verify} messages.
     * @function encode
     * @memberof EAnd
     * @static
     * @param {IEAnd} message EAnd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EAnd.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EAnd message, length delimited. Does not implicitly {@link EAnd.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EAnd
     * @static
     * @param {IEAnd} message EAnd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EAnd.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EAnd message from the specified reader or buffer.
     * @function decode
     * @memberof EAnd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EAnd} EAnd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EAnd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EAnd();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EAnd message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EAnd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EAnd} EAnd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EAnd.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EAnd message.
     * @function verify
     * @memberof EAnd
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EAnd.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EAnd message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EAnd
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EAnd} EAnd
     */
    EAnd.fromObject = function fromObject(object) {
        if (object instanceof $root.EAnd)
            return object;
        var message = new $root.EAnd();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EAnd.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EAnd.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EAnd message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EAnd
     * @static
     * @param {EAnd} message EAnd
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EAnd.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EAnd to JSON.
     * @function toJSON
     * @memberof EAnd
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EAnd.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EAnd;
})();

$root.EOr = (function() {

    /**
     * Properties of a EOr.
     * @exports IEOr
     * @interface IEOr
     * @property {IPar|null} [p1] EOr p1
     * @property {IPar|null} [p2] EOr p2
     */

    /**
     * Constructs a new EOr.
     * @exports EOr
     * @classdesc Represents a EOr.
     * @implements IEOr
     * @constructor
     * @param {IEOr=} [properties] Properties to set
     */
    function EOr(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EOr p1.
     * @member {IPar|null|undefined} p1
     * @memberof EOr
     * @instance
     */
    EOr.prototype.p1 = null;

    /**
     * EOr p2.
     * @member {IPar|null|undefined} p2
     * @memberof EOr
     * @instance
     */
    EOr.prototype.p2 = null;

    /**
     * Creates a new EOr instance using the specified properties.
     * @function create
     * @memberof EOr
     * @static
     * @param {IEOr=} [properties] Properties to set
     * @returns {EOr} EOr instance
     */
    EOr.create = function create(properties) {
        return new EOr(properties);
    };

    /**
     * Encodes the specified EOr message. Does not implicitly {@link EOr.verify|verify} messages.
     * @function encode
     * @memberof EOr
     * @static
     * @param {IEOr} message EOr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EOr.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EOr message, length delimited. Does not implicitly {@link EOr.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EOr
     * @static
     * @param {IEOr} message EOr message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EOr.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EOr message from the specified reader or buffer.
     * @function decode
     * @memberof EOr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EOr} EOr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EOr.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EOr();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EOr message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EOr
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EOr} EOr
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EOr.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EOr message.
     * @function verify
     * @memberof EOr
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EOr.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EOr message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EOr
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EOr} EOr
     */
    EOr.fromObject = function fromObject(object) {
        if (object instanceof $root.EOr)
            return object;
        var message = new $root.EOr();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EOr.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EOr.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EOr message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EOr
     * @static
     * @param {EOr} message EOr
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EOr.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EOr to JSON.
     * @function toJSON
     * @memberof EOr
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EOr.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EOr;
})();

$root.EMatches = (function() {

    /**
     * Properties of a EMatches.
     * @exports IEMatches
     * @interface IEMatches
     * @property {IPar|null} [target] EMatches target
     * @property {IPar|null} [pattern] EMatches pattern
     */

    /**
     * Constructs a new EMatches.
     * @exports EMatches
     * @classdesc Represents a EMatches.
     * @implements IEMatches
     * @constructor
     * @param {IEMatches=} [properties] Properties to set
     */
    function EMatches(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMatches target.
     * @member {IPar|null|undefined} target
     * @memberof EMatches
     * @instance
     */
    EMatches.prototype.target = null;

    /**
     * EMatches pattern.
     * @member {IPar|null|undefined} pattern
     * @memberof EMatches
     * @instance
     */
    EMatches.prototype.pattern = null;

    /**
     * Creates a new EMatches instance using the specified properties.
     * @function create
     * @memberof EMatches
     * @static
     * @param {IEMatches=} [properties] Properties to set
     * @returns {EMatches} EMatches instance
     */
    EMatches.create = function create(properties) {
        return new EMatches(properties);
    };

    /**
     * Encodes the specified EMatches message. Does not implicitly {@link EMatches.verify|verify} messages.
     * @function encode
     * @memberof EMatches
     * @static
     * @param {IEMatches} message EMatches message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMatches.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.target != null && message.hasOwnProperty("target"))
            $root.Par.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.pattern != null && message.hasOwnProperty("pattern"))
            $root.Par.encode(message.pattern, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EMatches message, length delimited. Does not implicitly {@link EMatches.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMatches
     * @static
     * @param {IEMatches} message EMatches message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMatches.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMatches message from the specified reader or buffer.
     * @function decode
     * @memberof EMatches
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMatches} EMatches
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMatches.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMatches();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.target = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.pattern = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMatches message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMatches
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMatches} EMatches
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMatches.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMatches message.
     * @function verify
     * @memberof EMatches
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMatches.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.target != null && message.hasOwnProperty("target")) {
            var error = $root.Par.verify(message.target);
            if (error)
                return "target." + error;
        }
        if (message.pattern != null && message.hasOwnProperty("pattern")) {
            var error = $root.Par.verify(message.pattern);
            if (error)
                return "pattern." + error;
        }
        return null;
    };

    /**
     * Creates a EMatches message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMatches
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMatches} EMatches
     */
    EMatches.fromObject = function fromObject(object) {
        if (object instanceof $root.EMatches)
            return object;
        var message = new $root.EMatches();
        if (object.target != null) {
            if (typeof object.target !== "object")
                throw TypeError(".EMatches.target: object expected");
            message.target = $root.Par.fromObject(object.target);
        }
        if (object.pattern != null) {
            if (typeof object.pattern !== "object")
                throw TypeError(".EMatches.pattern: object expected");
            message.pattern = $root.Par.fromObject(object.pattern);
        }
        return message;
    };

    /**
     * Creates a plain object from a EMatches message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMatches
     * @static
     * @param {EMatches} message EMatches
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMatches.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.target = null;
            object.pattern = null;
        }
        if (message.target != null && message.hasOwnProperty("target"))
            object.target = $root.Par.toObject(message.target, options);
        if (message.pattern != null && message.hasOwnProperty("pattern"))
            object.pattern = $root.Par.toObject(message.pattern, options);
        return object;
    };

    /**
     * Converts this EMatches to JSON.
     * @function toJSON
     * @memberof EMatches
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMatches.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMatches;
})();

$root.EPercentPercent = (function() {

    /**
     * Properties of a EPercentPercent.
     * @exports IEPercentPercent
     * @interface IEPercentPercent
     * @property {IPar|null} [p1] EPercentPercent p1
     * @property {IPar|null} [p2] EPercentPercent p2
     */

    /**
     * Constructs a new EPercentPercent.
     * @exports EPercentPercent
     * @classdesc String interpolation
     * 
     * `"Hello, {name}" %% {"name": "Bob"}` denotes `"Hello, Bob"`
     * @implements IEPercentPercent
     * @constructor
     * @param {IEPercentPercent=} [properties] Properties to set
     */
    function EPercentPercent(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EPercentPercent p1.
     * @member {IPar|null|undefined} p1
     * @memberof EPercentPercent
     * @instance
     */
    EPercentPercent.prototype.p1 = null;

    /**
     * EPercentPercent p2.
     * @member {IPar|null|undefined} p2
     * @memberof EPercentPercent
     * @instance
     */
    EPercentPercent.prototype.p2 = null;

    /**
     * Creates a new EPercentPercent instance using the specified properties.
     * @function create
     * @memberof EPercentPercent
     * @static
     * @param {IEPercentPercent=} [properties] Properties to set
     * @returns {EPercentPercent} EPercentPercent instance
     */
    EPercentPercent.create = function create(properties) {
        return new EPercentPercent(properties);
    };

    /**
     * Encodes the specified EPercentPercent message. Does not implicitly {@link EPercentPercent.verify|verify} messages.
     * @function encode
     * @memberof EPercentPercent
     * @static
     * @param {IEPercentPercent} message EPercentPercent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EPercentPercent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EPercentPercent message, length delimited. Does not implicitly {@link EPercentPercent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EPercentPercent
     * @static
     * @param {IEPercentPercent} message EPercentPercent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EPercentPercent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EPercentPercent message from the specified reader or buffer.
     * @function decode
     * @memberof EPercentPercent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EPercentPercent} EPercentPercent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EPercentPercent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EPercentPercent();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EPercentPercent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EPercentPercent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EPercentPercent} EPercentPercent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EPercentPercent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EPercentPercent message.
     * @function verify
     * @memberof EPercentPercent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EPercentPercent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EPercentPercent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EPercentPercent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EPercentPercent} EPercentPercent
     */
    EPercentPercent.fromObject = function fromObject(object) {
        if (object instanceof $root.EPercentPercent)
            return object;
        var message = new $root.EPercentPercent();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EPercentPercent.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EPercentPercent.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EPercentPercent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EPercentPercent
     * @static
     * @param {EPercentPercent} message EPercentPercent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EPercentPercent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EPercentPercent to JSON.
     * @function toJSON
     * @memberof EPercentPercent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EPercentPercent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EPercentPercent;
})();

$root.EPlusPlus = (function() {

    /**
     * Properties of a EPlusPlus.
     * @exports IEPlusPlus
     * @interface IEPlusPlus
     * @property {IPar|null} [p1] EPlusPlus p1
     * @property {IPar|null} [p2] EPlusPlus p2
     */

    /**
     * Constructs a new EPlusPlus.
     * @exports EPlusPlus
     * @classdesc Represents a EPlusPlus.
     * @implements IEPlusPlus
     * @constructor
     * @param {IEPlusPlus=} [properties] Properties to set
     */
    function EPlusPlus(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EPlusPlus p1.
     * @member {IPar|null|undefined} p1
     * @memberof EPlusPlus
     * @instance
     */
    EPlusPlus.prototype.p1 = null;

    /**
     * EPlusPlus p2.
     * @member {IPar|null|undefined} p2
     * @memberof EPlusPlus
     * @instance
     */
    EPlusPlus.prototype.p2 = null;

    /**
     * Creates a new EPlusPlus instance using the specified properties.
     * @function create
     * @memberof EPlusPlus
     * @static
     * @param {IEPlusPlus=} [properties] Properties to set
     * @returns {EPlusPlus} EPlusPlus instance
     */
    EPlusPlus.create = function create(properties) {
        return new EPlusPlus(properties);
    };

    /**
     * Encodes the specified EPlusPlus message. Does not implicitly {@link EPlusPlus.verify|verify} messages.
     * @function encode
     * @memberof EPlusPlus
     * @static
     * @param {IEPlusPlus} message EPlusPlus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EPlusPlus.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EPlusPlus message, length delimited. Does not implicitly {@link EPlusPlus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EPlusPlus
     * @static
     * @param {IEPlusPlus} message EPlusPlus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EPlusPlus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EPlusPlus message from the specified reader or buffer.
     * @function decode
     * @memberof EPlusPlus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EPlusPlus} EPlusPlus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EPlusPlus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EPlusPlus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EPlusPlus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EPlusPlus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EPlusPlus} EPlusPlus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EPlusPlus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EPlusPlus message.
     * @function verify
     * @memberof EPlusPlus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EPlusPlus.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EPlusPlus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EPlusPlus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EPlusPlus} EPlusPlus
     */
    EPlusPlus.fromObject = function fromObject(object) {
        if (object instanceof $root.EPlusPlus)
            return object;
        var message = new $root.EPlusPlus();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EPlusPlus.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EPlusPlus.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EPlusPlus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EPlusPlus
     * @static
     * @param {EPlusPlus} message EPlusPlus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EPlusPlus.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EPlusPlus to JSON.
     * @function toJSON
     * @memberof EPlusPlus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EPlusPlus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EPlusPlus;
})();

$root.EMinusMinus = (function() {

    /**
     * Properties of a EMinusMinus.
     * @exports IEMinusMinus
     * @interface IEMinusMinus
     * @property {IPar|null} [p1] EMinusMinus p1
     * @property {IPar|null} [p2] EMinusMinus p2
     */

    /**
     * Constructs a new EMinusMinus.
     * @exports EMinusMinus
     * @classdesc Represents a EMinusMinus.
     * @implements IEMinusMinus
     * @constructor
     * @param {IEMinusMinus=} [properties] Properties to set
     */
    function EMinusMinus(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EMinusMinus p1.
     * @member {IPar|null|undefined} p1
     * @memberof EMinusMinus
     * @instance
     */
    EMinusMinus.prototype.p1 = null;

    /**
     * EMinusMinus p2.
     * @member {IPar|null|undefined} p2
     * @memberof EMinusMinus
     * @instance
     */
    EMinusMinus.prototype.p2 = null;

    /**
     * Creates a new EMinusMinus instance using the specified properties.
     * @function create
     * @memberof EMinusMinus
     * @static
     * @param {IEMinusMinus=} [properties] Properties to set
     * @returns {EMinusMinus} EMinusMinus instance
     */
    EMinusMinus.create = function create(properties) {
        return new EMinusMinus(properties);
    };

    /**
     * Encodes the specified EMinusMinus message. Does not implicitly {@link EMinusMinus.verify|verify} messages.
     * @function encode
     * @memberof EMinusMinus
     * @static
     * @param {IEMinusMinus} message EMinusMinus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMinusMinus.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.p1 != null && message.hasOwnProperty("p1"))
            $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.p2 != null && message.hasOwnProperty("p2"))
            $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EMinusMinus message, length delimited. Does not implicitly {@link EMinusMinus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EMinusMinus
     * @static
     * @param {IEMinusMinus} message EMinusMinus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EMinusMinus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a EMinusMinus message from the specified reader or buffer.
     * @function decode
     * @memberof EMinusMinus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EMinusMinus} EMinusMinus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMinusMinus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMinusMinus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.p1 = $root.Par.decode(reader, reader.uint32());
                break;
            case 2:
                message.p2 = $root.Par.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a EMinusMinus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EMinusMinus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EMinusMinus} EMinusMinus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EMinusMinus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a EMinusMinus message.
     * @function verify
     * @memberof EMinusMinus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EMinusMinus.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.p1 != null && message.hasOwnProperty("p1")) {
            var error = $root.Par.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        if (message.p2 != null && message.hasOwnProperty("p2")) {
            var error = $root.Par.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        return null;
    };

    /**
     * Creates a EMinusMinus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EMinusMinus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EMinusMinus} EMinusMinus
     */
    EMinusMinus.fromObject = function fromObject(object) {
        if (object instanceof $root.EMinusMinus)
            return object;
        var message = new $root.EMinusMinus();
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".EMinusMinus.p1: object expected");
            message.p1 = $root.Par.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".EMinusMinus.p2: object expected");
            message.p2 = $root.Par.fromObject(object.p2);
        }
        return message;
    };

    /**
     * Creates a plain object from a EMinusMinus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EMinusMinus
     * @static
     * @param {EMinusMinus} message EMinusMinus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EMinusMinus.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.p1 = null;
            object.p2 = null;
        }
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Par.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Par.toObject(message.p2, options);
        return object;
    };

    /**
     * Converts this EMinusMinus to JSON.
     * @function toJSON
     * @memberof EMinusMinus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EMinusMinus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EMinusMinus;
})();

$root.Connective = (function() {

    /**
     * Properties of a Connective.
     * @exports IConnective
     * @interface IConnective
     * @property {IConnectiveBody|null} [conn_and_body] Connective conn_and_body
     * @property {IConnectiveBody|null} [conn_or_body] Connective conn_or_body
     * @property {IPar|null} [conn_not_body] Connective conn_not_body
     * @property {IVarRef|null} [var_ref_body] Connective var_ref_body
     * @property {boolean|null} [conn_bool] Connective conn_bool
     * @property {boolean|null} [conn_int] Connective conn_int
     * @property {boolean|null} [conn_string] Connective conn_string
     * @property {boolean|null} [conn_uri] Connective conn_uri
     * @property {boolean|null} [conn_byte_array] Connective conn_byte_array
     */

    /**
     * Constructs a new Connective.
     * @exports Connective
     * @classdesc Represents a Connective.
     * @implements IConnective
     * @constructor
     * @param {IConnective=} [properties] Properties to set
     */
    function Connective(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Connective conn_and_body.
     * @member {IConnectiveBody|null|undefined} conn_and_body
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_and_body = null;

    /**
     * Connective conn_or_body.
     * @member {IConnectiveBody|null|undefined} conn_or_body
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_or_body = null;

    /**
     * Connective conn_not_body.
     * @member {IPar|null|undefined} conn_not_body
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_not_body = null;

    /**
     * Connective var_ref_body.
     * @member {IVarRef|null|undefined} var_ref_body
     * @memberof Connective
     * @instance
     */
    Connective.prototype.var_ref_body = null;

    /**
     * Connective conn_bool.
     * @member {boolean} conn_bool
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_bool = false;

    /**
     * Connective conn_int.
     * @member {boolean} conn_int
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_int = false;

    /**
     * Connective conn_string.
     * @member {boolean} conn_string
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_string = false;

    /**
     * Connective conn_uri.
     * @member {boolean} conn_uri
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_uri = false;

    /**
     * Connective conn_byte_array.
     * @member {boolean} conn_byte_array
     * @memberof Connective
     * @instance
     */
    Connective.prototype.conn_byte_array = false;

    // OneOf field names bound to virtual getters and setters
    var $oneOfFields;

    /**
     * Connective connective_instance.
     * @member {"conn_and_body"|"conn_or_body"|"conn_not_body"|"var_ref_body"|"conn_bool"|"conn_int"|"conn_string"|"conn_uri"|"conn_byte_array"|undefined} connective_instance
     * @memberof Connective
     * @instance
     */
    Object.defineProperty(Connective.prototype, "connective_instance", {
        get: $util.oneOfGetter($oneOfFields = ["conn_and_body", "conn_or_body", "conn_not_body", "var_ref_body", "conn_bool", "conn_int", "conn_string", "conn_uri", "conn_byte_array"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new Connective instance using the specified properties.
     * @function create
     * @memberof Connective
     * @static
     * @param {IConnective=} [properties] Properties to set
     * @returns {Connective} Connective instance
     */
    Connective.create = function create(properties) {
        return new Connective(properties);
    };

    /**
     * Encodes the specified Connective message. Does not implicitly {@link Connective.verify|verify} messages.
     * @function encode
     * @memberof Connective
     * @static
     * @param {IConnective} message Connective message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Connective.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conn_and_body != null && message.hasOwnProperty("conn_and_body"))
            $root.ConnectiveBody.encode(message.conn_and_body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conn_or_body != null && message.hasOwnProperty("conn_or_body"))
            $root.ConnectiveBody.encode(message.conn_or_body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.conn_not_body != null && message.hasOwnProperty("conn_not_body"))
            $root.Par.encode(message.conn_not_body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.var_ref_body != null && message.hasOwnProperty("var_ref_body"))
            $root.VarRef.encode(message.var_ref_body, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.conn_bool != null && message.hasOwnProperty("conn_bool"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.conn_bool);
        if (message.conn_int != null && message.hasOwnProperty("conn_int"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.conn_int);
        if (message.conn_string != null && message.hasOwnProperty("conn_string"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.conn_string);
        if (message.conn_uri != null && message.hasOwnProperty("conn_uri"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.conn_uri);
        if (message.conn_byte_array != null && message.hasOwnProperty("conn_byte_array"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.conn_byte_array);
        return writer;
    };

    /**
     * Encodes the specified Connective message, length delimited. Does not implicitly {@link Connective.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Connective
     * @static
     * @param {IConnective} message Connective message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Connective.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Connective message from the specified reader or buffer.
     * @function decode
     * @memberof Connective
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Connective} Connective
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Connective.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Connective();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conn_and_body = $root.ConnectiveBody.decode(reader, reader.uint32());
                break;
            case 2:
                message.conn_or_body = $root.ConnectiveBody.decode(reader, reader.uint32());
                break;
            case 3:
                message.conn_not_body = $root.Par.decode(reader, reader.uint32());
                break;
            case 4:
                message.var_ref_body = $root.VarRef.decode(reader, reader.uint32());
                break;
            case 5:
                message.conn_bool = reader.bool();
                break;
            case 6:
                message.conn_int = reader.bool();
                break;
            case 7:
                message.conn_string = reader.bool();
                break;
            case 8:
                message.conn_uri = reader.bool();
                break;
            case 9:
                message.conn_byte_array = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Connective message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Connective
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Connective} Connective
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Connective.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Connective message.
     * @function verify
     * @memberof Connective
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Connective.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        var properties = {};
        if (message.conn_and_body != null && message.hasOwnProperty("conn_and_body")) {
            properties.connective_instance = 1;
            {
                var error = $root.ConnectiveBody.verify(message.conn_and_body);
                if (error)
                    return "conn_and_body." + error;
            }
        }
        if (message.conn_or_body != null && message.hasOwnProperty("conn_or_body")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            {
                var error = $root.ConnectiveBody.verify(message.conn_or_body);
                if (error)
                    return "conn_or_body." + error;
            }
        }
        if (message.conn_not_body != null && message.hasOwnProperty("conn_not_body")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            {
                var error = $root.Par.verify(message.conn_not_body);
                if (error)
                    return "conn_not_body." + error;
            }
        }
        if (message.var_ref_body != null && message.hasOwnProperty("var_ref_body")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            {
                var error = $root.VarRef.verify(message.var_ref_body);
                if (error)
                    return "var_ref_body." + error;
            }
        }
        if (message.conn_bool != null && message.hasOwnProperty("conn_bool")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            if (typeof message.conn_bool !== "boolean")
                return "conn_bool: boolean expected";
        }
        if (message.conn_int != null && message.hasOwnProperty("conn_int")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            if (typeof message.conn_int !== "boolean")
                return "conn_int: boolean expected";
        }
        if (message.conn_string != null && message.hasOwnProperty("conn_string")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            if (typeof message.conn_string !== "boolean")
                return "conn_string: boolean expected";
        }
        if (message.conn_uri != null && message.hasOwnProperty("conn_uri")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            if (typeof message.conn_uri !== "boolean")
                return "conn_uri: boolean expected";
        }
        if (message.conn_byte_array != null && message.hasOwnProperty("conn_byte_array")) {
            if (properties.connective_instance === 1)
                return "connective_instance: multiple values";
            properties.connective_instance = 1;
            if (typeof message.conn_byte_array !== "boolean")
                return "conn_byte_array: boolean expected";
        }
        return null;
    };

    /**
     * Creates a Connective message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Connective
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Connective} Connective
     */
    Connective.fromObject = function fromObject(object) {
        if (object instanceof $root.Connective)
            return object;
        var message = new $root.Connective();
        if (object.conn_and_body != null) {
            if (typeof object.conn_and_body !== "object")
                throw TypeError(".Connective.conn_and_body: object expected");
            message.conn_and_body = $root.ConnectiveBody.fromObject(object.conn_and_body);
        }
        if (object.conn_or_body != null) {
            if (typeof object.conn_or_body !== "object")
                throw TypeError(".Connective.conn_or_body: object expected");
            message.conn_or_body = $root.ConnectiveBody.fromObject(object.conn_or_body);
        }
        if (object.conn_not_body != null) {
            if (typeof object.conn_not_body !== "object")
                throw TypeError(".Connective.conn_not_body: object expected");
            message.conn_not_body = $root.Par.fromObject(object.conn_not_body);
        }
        if (object.var_ref_body != null) {
            if (typeof object.var_ref_body !== "object")
                throw TypeError(".Connective.var_ref_body: object expected");
            message.var_ref_body = $root.VarRef.fromObject(object.var_ref_body);
        }
        if (object.conn_bool != null)
            message.conn_bool = Boolean(object.conn_bool);
        if (object.conn_int != null)
            message.conn_int = Boolean(object.conn_int);
        if (object.conn_string != null)
            message.conn_string = Boolean(object.conn_string);
        if (object.conn_uri != null)
            message.conn_uri = Boolean(object.conn_uri);
        if (object.conn_byte_array != null)
            message.conn_byte_array = Boolean(object.conn_byte_array);
        return message;
    };

    /**
     * Creates a plain object from a Connective message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Connective
     * @static
     * @param {Connective} message Connective
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Connective.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (message.conn_and_body != null && message.hasOwnProperty("conn_and_body")) {
            object.conn_and_body = $root.ConnectiveBody.toObject(message.conn_and_body, options);
            if (options.oneofs)
                object.connective_instance = "conn_and_body";
        }
        if (message.conn_or_body != null && message.hasOwnProperty("conn_or_body")) {
            object.conn_or_body = $root.ConnectiveBody.toObject(message.conn_or_body, options);
            if (options.oneofs)
                object.connective_instance = "conn_or_body";
        }
        if (message.conn_not_body != null && message.hasOwnProperty("conn_not_body")) {
            object.conn_not_body = $root.Par.toObject(message.conn_not_body, options);
            if (options.oneofs)
                object.connective_instance = "conn_not_body";
        }
        if (message.var_ref_body != null && message.hasOwnProperty("var_ref_body")) {
            object.var_ref_body = $root.VarRef.toObject(message.var_ref_body, options);
            if (options.oneofs)
                object.connective_instance = "var_ref_body";
        }
        if (message.conn_bool != null && message.hasOwnProperty("conn_bool")) {
            object.conn_bool = message.conn_bool;
            if (options.oneofs)
                object.connective_instance = "conn_bool";
        }
        if (message.conn_int != null && message.hasOwnProperty("conn_int")) {
            object.conn_int = message.conn_int;
            if (options.oneofs)
                object.connective_instance = "conn_int";
        }
        if (message.conn_string != null && message.hasOwnProperty("conn_string")) {
            object.conn_string = message.conn_string;
            if (options.oneofs)
                object.connective_instance = "conn_string";
        }
        if (message.conn_uri != null && message.hasOwnProperty("conn_uri")) {
            object.conn_uri = message.conn_uri;
            if (options.oneofs)
                object.connective_instance = "conn_uri";
        }
        if (message.conn_byte_array != null && message.hasOwnProperty("conn_byte_array")) {
            object.conn_byte_array = message.conn_byte_array;
            if (options.oneofs)
                object.connective_instance = "conn_byte_array";
        }
        return object;
    };

    /**
     * Converts this Connective to JSON.
     * @function toJSON
     * @memberof Connective
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Connective.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Connective;
})();

$root.VarRef = (function() {

    /**
     * Properties of a VarRef.
     * @exports IVarRef
     * @interface IVarRef
     * @property {number|null} [index] VarRef index
     * @property {number|null} [depth] VarRef depth
     */

    /**
     * Constructs a new VarRef.
     * @exports VarRef
     * @classdesc Represents a VarRef.
     * @implements IVarRef
     * @constructor
     * @param {IVarRef=} [properties] Properties to set
     */
    function VarRef(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VarRef index.
     * @member {number} index
     * @memberof VarRef
     * @instance
     */
    VarRef.prototype.index = 0;

    /**
     * VarRef depth.
     * @member {number} depth
     * @memberof VarRef
     * @instance
     */
    VarRef.prototype.depth = 0;

    /**
     * Creates a new VarRef instance using the specified properties.
     * @function create
     * @memberof VarRef
     * @static
     * @param {IVarRef=} [properties] Properties to set
     * @returns {VarRef} VarRef instance
     */
    VarRef.create = function create(properties) {
        return new VarRef(properties);
    };

    /**
     * Encodes the specified VarRef message. Does not implicitly {@link VarRef.verify|verify} messages.
     * @function encode
     * @memberof VarRef
     * @static
     * @param {IVarRef} message VarRef message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VarRef.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.index != null && message.hasOwnProperty("index"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.index);
        if (message.depth != null && message.hasOwnProperty("depth"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.depth);
        return writer;
    };

    /**
     * Encodes the specified VarRef message, length delimited. Does not implicitly {@link VarRef.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VarRef
     * @static
     * @param {IVarRef} message VarRef message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VarRef.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VarRef message from the specified reader or buffer.
     * @function decode
     * @memberof VarRef
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VarRef} VarRef
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VarRef.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VarRef();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.index = reader.sint32();
                break;
            case 2:
                message.depth = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VarRef message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VarRef
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VarRef} VarRef
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VarRef.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VarRef message.
     * @function verify
     * @memberof VarRef
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VarRef.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.index != null && message.hasOwnProperty("index"))
            if (!$util.isInteger(message.index))
                return "index: integer expected";
        if (message.depth != null && message.hasOwnProperty("depth"))
            if (!$util.isInteger(message.depth))
                return "depth: integer expected";
        return null;
    };

    /**
     * Creates a VarRef message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VarRef
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VarRef} VarRef
     */
    VarRef.fromObject = function fromObject(object) {
        if (object instanceof $root.VarRef)
            return object;
        var message = new $root.VarRef();
        if (object.index != null)
            message.index = object.index | 0;
        if (object.depth != null)
            message.depth = object.depth | 0;
        return message;
    };

    /**
     * Creates a plain object from a VarRef message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VarRef
     * @static
     * @param {VarRef} message VarRef
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VarRef.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.index = 0;
            object.depth = 0;
        }
        if (message.index != null && message.hasOwnProperty("index"))
            object.index = message.index;
        if (message.depth != null && message.hasOwnProperty("depth"))
            object.depth = message.depth;
        return object;
    };

    /**
     * Converts this VarRef to JSON.
     * @function toJSON
     * @memberof VarRef
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VarRef.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VarRef;
})();

$root.ConnectiveBody = (function() {

    /**
     * Properties of a ConnectiveBody.
     * @exports IConnectiveBody
     * @interface IConnectiveBody
     * @property {Array.<IPar>|null} [ps] ConnectiveBody ps
     */

    /**
     * Constructs a new ConnectiveBody.
     * @exports ConnectiveBody
     * @classdesc Represents a ConnectiveBody.
     * @implements IConnectiveBody
     * @constructor
     * @param {IConnectiveBody=} [properties] Properties to set
     */
    function ConnectiveBody(properties) {
        this.ps = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConnectiveBody ps.
     * @member {Array.<IPar>} ps
     * @memberof ConnectiveBody
     * @instance
     */
    ConnectiveBody.prototype.ps = $util.emptyArray;

    /**
     * Creates a new ConnectiveBody instance using the specified properties.
     * @function create
     * @memberof ConnectiveBody
     * @static
     * @param {IConnectiveBody=} [properties] Properties to set
     * @returns {ConnectiveBody} ConnectiveBody instance
     */
    ConnectiveBody.create = function create(properties) {
        return new ConnectiveBody(properties);
    };

    /**
     * Encodes the specified ConnectiveBody message. Does not implicitly {@link ConnectiveBody.verify|verify} messages.
     * @function encode
     * @memberof ConnectiveBody
     * @static
     * @param {IConnectiveBody} message ConnectiveBody message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectiveBody.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ps != null && message.ps.length)
            for (var i = 0; i < message.ps.length; ++i)
                $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ConnectiveBody message, length delimited. Does not implicitly {@link ConnectiveBody.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConnectiveBody
     * @static
     * @param {IConnectiveBody} message ConnectiveBody message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectiveBody.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConnectiveBody message from the specified reader or buffer.
     * @function decode
     * @memberof ConnectiveBody
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConnectiveBody} ConnectiveBody
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectiveBody.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectiveBody();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.ps && message.ps.length))
                    message.ps = [];
                message.ps.push($root.Par.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConnectiveBody message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConnectiveBody
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConnectiveBody} ConnectiveBody
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectiveBody.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConnectiveBody message.
     * @function verify
     * @memberof ConnectiveBody
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConnectiveBody.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ps != null && message.hasOwnProperty("ps")) {
            if (!Array.isArray(message.ps))
                return "ps: array expected";
            for (var i = 0; i < message.ps.length; ++i) {
                var error = $root.Par.verify(message.ps[i]);
                if (error)
                    return "ps." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ConnectiveBody message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConnectiveBody
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConnectiveBody} ConnectiveBody
     */
    ConnectiveBody.fromObject = function fromObject(object) {
        if (object instanceof $root.ConnectiveBody)
            return object;
        var message = new $root.ConnectiveBody();
        if (object.ps) {
            if (!Array.isArray(object.ps))
                throw TypeError(".ConnectiveBody.ps: array expected");
            message.ps = [];
            for (var i = 0; i < object.ps.length; ++i) {
                if (typeof object.ps[i] !== "object")
                    throw TypeError(".ConnectiveBody.ps: object expected");
                message.ps[i] = $root.Par.fromObject(object.ps[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ConnectiveBody message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConnectiveBody
     * @static
     * @param {ConnectiveBody} message ConnectiveBody
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConnectiveBody.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ps = [];
        if (message.ps && message.ps.length) {
            object.ps = [];
            for (var j = 0; j < message.ps.length; ++j)
                object.ps[j] = $root.Par.toObject(message.ps[j], options);
        }
        return object;
    };

    /**
     * Converts this ConnectiveBody to JSON.
     * @function toJSON
     * @memberof ConnectiveBody
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConnectiveBody.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConnectiveBody;
})();

$root.DeployId = (function() {

    /**
     * Properties of a DeployId.
     * @exports IDeployId
     * @interface IDeployId
     * @property {Uint8Array|null} [sig] DeployId sig
     */

    /**
     * Constructs a new DeployId.
     * @exports DeployId
     * @classdesc Represents a DeployId.
     * @implements IDeployId
     * @constructor
     * @param {IDeployId=} [properties] Properties to set
     */
    function DeployId(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeployId sig.
     * @member {Uint8Array} sig
     * @memberof DeployId
     * @instance
     */
    DeployId.prototype.sig = $util.newBuffer([]);

    /**
     * Creates a new DeployId instance using the specified properties.
     * @function create
     * @memberof DeployId
     * @static
     * @param {IDeployId=} [properties] Properties to set
     * @returns {DeployId} DeployId instance
     */
    DeployId.create = function create(properties) {
        return new DeployId(properties);
    };

    /**
     * Encodes the specified DeployId message. Does not implicitly {@link DeployId.verify|verify} messages.
     * @function encode
     * @memberof DeployId
     * @static
     * @param {IDeployId} message DeployId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeployId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sig != null && message.hasOwnProperty("sig"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sig);
        return writer;
    };

    /**
     * Encodes the specified DeployId message, length delimited. Does not implicitly {@link DeployId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeployId
     * @static
     * @param {IDeployId} message DeployId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeployId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeployId message from the specified reader or buffer.
     * @function decode
     * @memberof DeployId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeployId} DeployId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeployId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeployId();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sig = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeployId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeployId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeployId} DeployId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeployId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeployId message.
     * @function verify
     * @memberof DeployId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeployId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sig != null && message.hasOwnProperty("sig"))
            if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                return "sig: buffer expected";
        return null;
    };

    /**
     * Creates a DeployId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeployId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeployId} DeployId
     */
    DeployId.fromObject = function fromObject(object) {
        if (object instanceof $root.DeployId)
            return object;
        var message = new $root.DeployId();
        if (object.sig != null)
            if (typeof object.sig === "string")
                $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
            else if (object.sig.length)
                message.sig = object.sig;
        return message;
    };

    /**
     * Creates a plain object from a DeployId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeployId
     * @static
     * @param {DeployId} message DeployId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeployId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.sig = "";
            else {
                object.sig = [];
                if (options.bytes !== Array)
                    object.sig = $util.newBuffer(object.sig);
            }
        if (message.sig != null && message.hasOwnProperty("sig"))
            object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
        return object;
    };

    /**
     * Converts this DeployId to JSON.
     * @function toJSON
     * @memberof DeployId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeployId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeployId;
})();

$root.DeployerId = (function() {

    /**
     * Properties of a DeployerId.
     * @exports IDeployerId
     * @interface IDeployerId
     * @property {Uint8Array|null} [publicKey] DeployerId publicKey
     */

    /**
     * Constructs a new DeployerId.
     * @exports DeployerId
     * @classdesc Represents a DeployerId.
     * @implements IDeployerId
     * @constructor
     * @param {IDeployerId=} [properties] Properties to set
     */
    function DeployerId(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeployerId publicKey.
     * @member {Uint8Array} publicKey
     * @memberof DeployerId
     * @instance
     */
    DeployerId.prototype.publicKey = $util.newBuffer([]);

    /**
     * Creates a new DeployerId instance using the specified properties.
     * @function create
     * @memberof DeployerId
     * @static
     * @param {IDeployerId=} [properties] Properties to set
     * @returns {DeployerId} DeployerId instance
     */
    DeployerId.create = function create(properties) {
        return new DeployerId(properties);
    };

    /**
     * Encodes the specified DeployerId message. Does not implicitly {@link DeployerId.verify|verify} messages.
     * @function encode
     * @memberof DeployerId
     * @static
     * @param {IDeployerId} message DeployerId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeployerId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
        return writer;
    };

    /**
     * Encodes the specified DeployerId message, length delimited. Does not implicitly {@link DeployerId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeployerId
     * @static
     * @param {IDeployerId} message DeployerId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeployerId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeployerId message from the specified reader or buffer.
     * @function decode
     * @memberof DeployerId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeployerId} DeployerId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeployerId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeployerId();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publicKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeployerId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeployerId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeployerId} DeployerId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeployerId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeployerId message.
     * @function verify
     * @memberof DeployerId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeployerId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                return "publicKey: buffer expected";
        return null;
    };

    /**
     * Creates a DeployerId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeployerId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeployerId} DeployerId
     */
    DeployerId.fromObject = function fromObject(object) {
        if (object instanceof $root.DeployerId)
            return object;
        var message = new $root.DeployerId();
        if (object.publicKey != null)
            if (typeof object.publicKey === "string")
                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
            else if (object.publicKey.length)
                message.publicKey = object.publicKey;
        return message;
    };

    /**
     * Creates a plain object from a DeployerId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeployerId
     * @static
     * @param {DeployerId} message DeployerId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeployerId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.publicKey = "";
            else {
                object.publicKey = [];
                if (options.bytes !== Array)
                    object.publicKey = $util.newBuffer(object.publicKey);
            }
        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
        return object;
    };

    /**
     * Converts this DeployerId to JSON.
     * @function toJSON
     * @memberof DeployerId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeployerId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeployerId;
})();

$root.GUnforgeable = (function() {

    /**
     * Properties of a GUnforgeable.
     * @exports IGUnforgeable
     * @interface IGUnforgeable
     * @property {IGPrivate|null} [g_private_body] GUnforgeable g_private_body
     * @property {IGDeployId|null} [g_deploy_id_body] GUnforgeable g_deploy_id_body
     * @property {IGDeployerId|null} [g_deployer_id_body] GUnforgeable g_deployer_id_body
     */

    /**
     * Constructs a new GUnforgeable.
     * @exports GUnforgeable
     * @classdesc Represents a GUnforgeable.
     * @implements IGUnforgeable
     * @constructor
     * @param {IGUnforgeable=} [properties] Properties to set
     */
    function GUnforgeable(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GUnforgeable g_private_body.
     * @member {IGPrivate|null|undefined} g_private_body
     * @memberof GUnforgeable
     * @instance
     */
    GUnforgeable.prototype.g_private_body = null;

    /**
     * GUnforgeable g_deploy_id_body.
     * @member {IGDeployId|null|undefined} g_deploy_id_body
     * @memberof GUnforgeable
     * @instance
     */
    GUnforgeable.prototype.g_deploy_id_body = null;

    /**
     * GUnforgeable g_deployer_id_body.
     * @member {IGDeployerId|null|undefined} g_deployer_id_body
     * @memberof GUnforgeable
     * @instance
     */
    GUnforgeable.prototype.g_deployer_id_body = null;

    // OneOf field names bound to virtual getters and setters
    var $oneOfFields;

    /**
     * GUnforgeable unf_instance.
     * @member {"g_private_body"|"g_deploy_id_body"|"g_deployer_id_body"|undefined} unf_instance
     * @memberof GUnforgeable
     * @instance
     */
    Object.defineProperty(GUnforgeable.prototype, "unf_instance", {
        get: $util.oneOfGetter($oneOfFields = ["g_private_body", "g_deploy_id_body", "g_deployer_id_body"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new GUnforgeable instance using the specified properties.
     * @function create
     * @memberof GUnforgeable
     * @static
     * @param {IGUnforgeable=} [properties] Properties to set
     * @returns {GUnforgeable} GUnforgeable instance
     */
    GUnforgeable.create = function create(properties) {
        return new GUnforgeable(properties);
    };

    /**
     * Encodes the specified GUnforgeable message. Does not implicitly {@link GUnforgeable.verify|verify} messages.
     * @function encode
     * @memberof GUnforgeable
     * @static
     * @param {IGUnforgeable} message GUnforgeable message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GUnforgeable.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.g_private_body != null && message.hasOwnProperty("g_private_body"))
            $root.GPrivate.encode(message.g_private_body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.g_deploy_id_body != null && message.hasOwnProperty("g_deploy_id_body"))
            $root.GDeployId.encode(message.g_deploy_id_body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.g_deployer_id_body != null && message.hasOwnProperty("g_deployer_id_body"))
            $root.GDeployerId.encode(message.g_deployer_id_body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GUnforgeable message, length delimited. Does not implicitly {@link GUnforgeable.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GUnforgeable
     * @static
     * @param {IGUnforgeable} message GUnforgeable message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GUnforgeable.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GUnforgeable message from the specified reader or buffer.
     * @function decode
     * @memberof GUnforgeable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GUnforgeable} GUnforgeable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GUnforgeable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GUnforgeable();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.g_private_body = $root.GPrivate.decode(reader, reader.uint32());
                break;
            case 2:
                message.g_deploy_id_body = $root.GDeployId.decode(reader, reader.uint32());
                break;
            case 3:
                message.g_deployer_id_body = $root.GDeployerId.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GUnforgeable message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GUnforgeable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GUnforgeable} GUnforgeable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GUnforgeable.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GUnforgeable message.
     * @function verify
     * @memberof GUnforgeable
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GUnforgeable.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        var properties = {};
        if (message.g_private_body != null && message.hasOwnProperty("g_private_body")) {
            properties.unf_instance = 1;
            {
                var error = $root.GPrivate.verify(message.g_private_body);
                if (error)
                    return "g_private_body." + error;
            }
        }
        if (message.g_deploy_id_body != null && message.hasOwnProperty("g_deploy_id_body")) {
            if (properties.unf_instance === 1)
                return "unf_instance: multiple values";
            properties.unf_instance = 1;
            {
                var error = $root.GDeployId.verify(message.g_deploy_id_body);
                if (error)
                    return "g_deploy_id_body." + error;
            }
        }
        if (message.g_deployer_id_body != null && message.hasOwnProperty("g_deployer_id_body")) {
            if (properties.unf_instance === 1)
                return "unf_instance: multiple values";
            properties.unf_instance = 1;
            {
                var error = $root.GDeployerId.verify(message.g_deployer_id_body);
                if (error)
                    return "g_deployer_id_body." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GUnforgeable message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GUnforgeable
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GUnforgeable} GUnforgeable
     */
    GUnforgeable.fromObject = function fromObject(object) {
        if (object instanceof $root.GUnforgeable)
            return object;
        var message = new $root.GUnforgeable();
        if (object.g_private_body != null) {
            if (typeof object.g_private_body !== "object")
                throw TypeError(".GUnforgeable.g_private_body: object expected");
            message.g_private_body = $root.GPrivate.fromObject(object.g_private_body);
        }
        if (object.g_deploy_id_body != null) {
            if (typeof object.g_deploy_id_body !== "object")
                throw TypeError(".GUnforgeable.g_deploy_id_body: object expected");
            message.g_deploy_id_body = $root.GDeployId.fromObject(object.g_deploy_id_body);
        }
        if (object.g_deployer_id_body != null) {
            if (typeof object.g_deployer_id_body !== "object")
                throw TypeError(".GUnforgeable.g_deployer_id_body: object expected");
            message.g_deployer_id_body = $root.GDeployerId.fromObject(object.g_deployer_id_body);
        }
        return message;
    };

    /**
     * Creates a plain object from a GUnforgeable message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GUnforgeable
     * @static
     * @param {GUnforgeable} message GUnforgeable
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GUnforgeable.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (message.g_private_body != null && message.hasOwnProperty("g_private_body")) {
            object.g_private_body = $root.GPrivate.toObject(message.g_private_body, options);
            if (options.oneofs)
                object.unf_instance = "g_private_body";
        }
        if (message.g_deploy_id_body != null && message.hasOwnProperty("g_deploy_id_body")) {
            object.g_deploy_id_body = $root.GDeployId.toObject(message.g_deploy_id_body, options);
            if (options.oneofs)
                object.unf_instance = "g_deploy_id_body";
        }
        if (message.g_deployer_id_body != null && message.hasOwnProperty("g_deployer_id_body")) {
            object.g_deployer_id_body = $root.GDeployerId.toObject(message.g_deployer_id_body, options);
            if (options.oneofs)
                object.unf_instance = "g_deployer_id_body";
        }
        return object;
    };

    /**
     * Converts this GUnforgeable to JSON.
     * @function toJSON
     * @memberof GUnforgeable
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GUnforgeable.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GUnforgeable;
})();

$root.GPrivate = (function() {

    /**
     * Properties of a GPrivate.
     * @exports IGPrivate
     * @interface IGPrivate
     * @property {Uint8Array|null} [id] GPrivate id
     */

    /**
     * Constructs a new GPrivate.
     * @exports GPrivate
     * @classdesc Represents a GPrivate.
     * @implements IGPrivate
     * @constructor
     * @param {IGPrivate=} [properties] Properties to set
     */
    function GPrivate(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GPrivate id.
     * @member {Uint8Array} id
     * @memberof GPrivate
     * @instance
     */
    GPrivate.prototype.id = $util.newBuffer([]);

    /**
     * Creates a new GPrivate instance using the specified properties.
     * @function create
     * @memberof GPrivate
     * @static
     * @param {IGPrivate=} [properties] Properties to set
     * @returns {GPrivate} GPrivate instance
     */
    GPrivate.create = function create(properties) {
        return new GPrivate(properties);
    };

    /**
     * Encodes the specified GPrivate message. Does not implicitly {@link GPrivate.verify|verify} messages.
     * @function encode
     * @memberof GPrivate
     * @static
     * @param {IGPrivate} message GPrivate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GPrivate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
        return writer;
    };

    /**
     * Encodes the specified GPrivate message, length delimited. Does not implicitly {@link GPrivate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GPrivate
     * @static
     * @param {IGPrivate} message GPrivate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GPrivate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GPrivate message from the specified reader or buffer.
     * @function decode
     * @memberof GPrivate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GPrivate} GPrivate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GPrivate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GPrivate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GPrivate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GPrivate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GPrivate} GPrivate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GPrivate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GPrivate message.
     * @function verify
     * @memberof GPrivate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GPrivate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                return "id: buffer expected";
        return null;
    };

    /**
     * Creates a GPrivate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GPrivate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GPrivate} GPrivate
     */
    GPrivate.fromObject = function fromObject(object) {
        if (object instanceof $root.GPrivate)
            return object;
        var message = new $root.GPrivate();
        if (object.id != null)
            if (typeof object.id === "string")
                $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
            else if (object.id.length)
                message.id = object.id;
        return message;
    };

    /**
     * Creates a plain object from a GPrivate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GPrivate
     * @static
     * @param {GPrivate} message GPrivate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GPrivate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.id = "";
            else {
                object.id = [];
                if (options.bytes !== Array)
                    object.id = $util.newBuffer(object.id);
            }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
        return object;
    };

    /**
     * Converts this GPrivate to JSON.
     * @function toJSON
     * @memberof GPrivate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GPrivate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GPrivate;
})();

$root.GDeployId = (function() {

    /**
     * Properties of a GDeployId.
     * @exports IGDeployId
     * @interface IGDeployId
     * @property {Uint8Array|null} [sig] GDeployId sig
     */

    /**
     * Constructs a new GDeployId.
     * @exports GDeployId
     * @classdesc Represents a GDeployId.
     * @implements IGDeployId
     * @constructor
     * @param {IGDeployId=} [properties] Properties to set
     */
    function GDeployId(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GDeployId sig.
     * @member {Uint8Array} sig
     * @memberof GDeployId
     * @instance
     */
    GDeployId.prototype.sig = $util.newBuffer([]);

    /**
     * Creates a new GDeployId instance using the specified properties.
     * @function create
     * @memberof GDeployId
     * @static
     * @param {IGDeployId=} [properties] Properties to set
     * @returns {GDeployId} GDeployId instance
     */
    GDeployId.create = function create(properties) {
        return new GDeployId(properties);
    };

    /**
     * Encodes the specified GDeployId message. Does not implicitly {@link GDeployId.verify|verify} messages.
     * @function encode
     * @memberof GDeployId
     * @static
     * @param {IGDeployId} message GDeployId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GDeployId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sig != null && message.hasOwnProperty("sig"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sig);
        return writer;
    };

    /**
     * Encodes the specified GDeployId message, length delimited. Does not implicitly {@link GDeployId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GDeployId
     * @static
     * @param {IGDeployId} message GDeployId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GDeployId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GDeployId message from the specified reader or buffer.
     * @function decode
     * @memberof GDeployId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GDeployId} GDeployId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GDeployId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GDeployId();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sig = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GDeployId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GDeployId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GDeployId} GDeployId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GDeployId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GDeployId message.
     * @function verify
     * @memberof GDeployId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GDeployId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sig != null && message.hasOwnProperty("sig"))
            if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                return "sig: buffer expected";
        return null;
    };

    /**
     * Creates a GDeployId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GDeployId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GDeployId} GDeployId
     */
    GDeployId.fromObject = function fromObject(object) {
        if (object instanceof $root.GDeployId)
            return object;
        var message = new $root.GDeployId();
        if (object.sig != null)
            if (typeof object.sig === "string")
                $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
            else if (object.sig.length)
                message.sig = object.sig;
        return message;
    };

    /**
     * Creates a plain object from a GDeployId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GDeployId
     * @static
     * @param {GDeployId} message GDeployId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GDeployId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.sig = "";
            else {
                object.sig = [];
                if (options.bytes !== Array)
                    object.sig = $util.newBuffer(object.sig);
            }
        if (message.sig != null && message.hasOwnProperty("sig"))
            object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
        return object;
    };

    /**
     * Converts this GDeployId to JSON.
     * @function toJSON
     * @memberof GDeployId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GDeployId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GDeployId;
})();

$root.GDeployerId = (function() {

    /**
     * Properties of a GDeployerId.
     * @exports IGDeployerId
     * @interface IGDeployerId
     * @property {Uint8Array|null} [publicKey] GDeployerId publicKey
     */

    /**
     * Constructs a new GDeployerId.
     * @exports GDeployerId
     * @classdesc Represents a GDeployerId.
     * @implements IGDeployerId
     * @constructor
     * @param {IGDeployerId=} [properties] Properties to set
     */
    function GDeployerId(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GDeployerId publicKey.
     * @member {Uint8Array} publicKey
     * @memberof GDeployerId
     * @instance
     */
    GDeployerId.prototype.publicKey = $util.newBuffer([]);

    /**
     * Creates a new GDeployerId instance using the specified properties.
     * @function create
     * @memberof GDeployerId
     * @static
     * @param {IGDeployerId=} [properties] Properties to set
     * @returns {GDeployerId} GDeployerId instance
     */
    GDeployerId.create = function create(properties) {
        return new GDeployerId(properties);
    };

    /**
     * Encodes the specified GDeployerId message. Does not implicitly {@link GDeployerId.verify|verify} messages.
     * @function encode
     * @memberof GDeployerId
     * @static
     * @param {IGDeployerId} message GDeployerId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GDeployerId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
        return writer;
    };

    /**
     * Encodes the specified GDeployerId message, length delimited. Does not implicitly {@link GDeployerId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GDeployerId
     * @static
     * @param {IGDeployerId} message GDeployerId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GDeployerId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GDeployerId message from the specified reader or buffer.
     * @function decode
     * @memberof GDeployerId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GDeployerId} GDeployerId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GDeployerId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GDeployerId();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publicKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GDeployerId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GDeployerId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GDeployerId} GDeployerId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GDeployerId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GDeployerId message.
     * @function verify
     * @memberof GDeployerId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GDeployerId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                return "publicKey: buffer expected";
        return null;
    };

    /**
     * Creates a GDeployerId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GDeployerId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GDeployerId} GDeployerId
     */
    GDeployerId.fromObject = function fromObject(object) {
        if (object instanceof $root.GDeployerId)
            return object;
        var message = new $root.GDeployerId();
        if (object.publicKey != null)
            if (typeof object.publicKey === "string")
                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
            else if (object.publicKey.length)
                message.publicKey = object.publicKey;
        return message;
    };

    /**
     * Creates a plain object from a GDeployerId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GDeployerId
     * @static
     * @param {GDeployerId} message GDeployerId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GDeployerId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.publicKey = "";
            else {
                object.publicKey = [];
                if (options.bytes !== Array)
                    object.publicKey = $util.newBuffer(object.publicKey);
            }
        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
        return object;
    };

    /**
     * Converts this GDeployerId to JSON.
     * @function toJSON
     * @memberof GDeployerId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GDeployerId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GDeployerId;
})();

$root.ServiceError = (function() {

    /**
     * Properties of a ServiceError.
     * @exports IServiceError
     * @interface IServiceError
     * @property {Array.<string>|null} [messages] ServiceError messages
     */

    /**
     * Constructs a new ServiceError.
     * @exports ServiceError
     * @classdesc Represents a ServiceError.
     * @implements IServiceError
     * @constructor
     * @param {IServiceError=} [properties] Properties to set
     */
    function ServiceError(properties) {
        this.messages = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ServiceError messages.
     * @member {Array.<string>} messages
     * @memberof ServiceError
     * @instance
     */
    ServiceError.prototype.messages = $util.emptyArray;

    /**
     * Creates a new ServiceError instance using the specified properties.
     * @function create
     * @memberof ServiceError
     * @static
     * @param {IServiceError=} [properties] Properties to set
     * @returns {ServiceError} ServiceError instance
     */
    ServiceError.create = function create(properties) {
        return new ServiceError(properties);
    };

    /**
     * Encodes the specified ServiceError message. Does not implicitly {@link ServiceError.verify|verify} messages.
     * @function encode
     * @memberof ServiceError
     * @static
     * @param {IServiceError} message ServiceError message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServiceError.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.messages != null && message.messages.length)
            for (var i = 0; i < message.messages.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.messages[i]);
        return writer;
    };

    /**
     * Encodes the specified ServiceError message, length delimited. Does not implicitly {@link ServiceError.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ServiceError
     * @static
     * @param {IServiceError} message ServiceError message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServiceError.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ServiceError message from the specified reader or buffer.
     * @function decode
     * @memberof ServiceError
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServiceError} ServiceError
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServiceError.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceError();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.messages && message.messages.length))
                    message.messages = [];
                message.messages.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ServiceError message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ServiceError
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ServiceError} ServiceError
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServiceError.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ServiceError message.
     * @function verify
     * @memberof ServiceError
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ServiceError.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.messages != null && message.hasOwnProperty("messages")) {
            if (!Array.isArray(message.messages))
                return "messages: array expected";
            for (var i = 0; i < message.messages.length; ++i)
                if (!$util.isString(message.messages[i]))
                    return "messages: string[] expected";
        }
        return null;
    };

    /**
     * Creates a ServiceError message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ServiceError
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ServiceError} ServiceError
     */
    ServiceError.fromObject = function fromObject(object) {
        if (object instanceof $root.ServiceError)
            return object;
        var message = new $root.ServiceError();
        if (object.messages) {
            if (!Array.isArray(object.messages))
                throw TypeError(".ServiceError.messages: array expected");
            message.messages = [];
            for (var i = 0; i < object.messages.length; ++i)
                message.messages[i] = String(object.messages[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a ServiceError message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ServiceError
     * @static
     * @param {ServiceError} message ServiceError
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ServiceError.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.messages = [];
        if (message.messages && message.messages.length) {
            object.messages = [];
            for (var j = 0; j < message.messages.length; ++j)
                object.messages[j] = message.messages[j];
        }
        return object;
    };

    /**
     * Converts this ServiceError to JSON.
     * @function toJSON
     * @memberof ServiceError
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ServiceError.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ServiceError;
})();

$root.routing = (function() {

    /**
     * Namespace routing.
     * @exports routing
     * @namespace
     */
    var routing = {};

    routing.Node = (function() {

        /**
         * Properties of a Node.
         * @memberof routing
         * @interface INode
         * @property {Uint8Array|null} [id] Node id
         * @property {Uint8Array|null} [host] Node host
         * @property {number|null} [tcp_port] Node tcp_port
         * @property {number|null} [udp_port] Node udp_port
         */

        /**
         * Constructs a new Node.
         * @memberof routing
         * @classdesc Represents a Node.
         * @implements INode
         * @constructor
         * @param {routing.INode=} [properties] Properties to set
         */
        function Node(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Node id.
         * @member {Uint8Array} id
         * @memberof routing.Node
         * @instance
         */
        Node.prototype.id = $util.newBuffer([]);

        /**
         * Node host.
         * @member {Uint8Array} host
         * @memberof routing.Node
         * @instance
         */
        Node.prototype.host = $util.newBuffer([]);

        /**
         * Node tcp_port.
         * @member {number} tcp_port
         * @memberof routing.Node
         * @instance
         */
        Node.prototype.tcp_port = 0;

        /**
         * Node udp_port.
         * @member {number} udp_port
         * @memberof routing.Node
         * @instance
         */
        Node.prototype.udp_port = 0;

        /**
         * Creates a new Node instance using the specified properties.
         * @function create
         * @memberof routing.Node
         * @static
         * @param {routing.INode=} [properties] Properties to set
         * @returns {routing.Node} Node instance
         */
        Node.create = function create(properties) {
            return new Node(properties);
        };

        /**
         * Encodes the specified Node message. Does not implicitly {@link routing.Node.verify|verify} messages.
         * @function encode
         * @memberof routing.Node
         * @static
         * @param {routing.INode} message Node message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Node.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.host);
            if (message.tcp_port != null && message.hasOwnProperty("tcp_port"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tcp_port);
            if (message.udp_port != null && message.hasOwnProperty("udp_port"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.udp_port);
            return writer;
        };

        /**
         * Encodes the specified Node message, length delimited. Does not implicitly {@link routing.Node.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Node
         * @static
         * @param {routing.INode} message Node message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Node.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Node message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Node
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Node} Node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Node.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Node();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.host = reader.bytes();
                    break;
                case 3:
                    message.tcp_port = reader.uint32();
                    break;
                case 4:
                    message.udp_port = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Node message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Node
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Node} Node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Node.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Node message.
         * @function verify
         * @memberof routing.Node
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Node.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!(message.host && typeof message.host.length === "number" || $util.isString(message.host)))
                    return "host: buffer expected";
            if (message.tcp_port != null && message.hasOwnProperty("tcp_port"))
                if (!$util.isInteger(message.tcp_port))
                    return "tcp_port: integer expected";
            if (message.udp_port != null && message.hasOwnProperty("udp_port"))
                if (!$util.isInteger(message.udp_port))
                    return "udp_port: integer expected";
            return null;
        };

        /**
         * Creates a Node message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Node
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Node} Node
         */
        Node.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Node)
                return object;
            var message = new $root.routing.Node();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.host != null)
                if (typeof object.host === "string")
                    $util.base64.decode(object.host, message.host = $util.newBuffer($util.base64.length(object.host)), 0);
                else if (object.host.length)
                    message.host = object.host;
            if (object.tcp_port != null)
                message.tcp_port = object.tcp_port >>> 0;
            if (object.udp_port != null)
                message.udp_port = object.udp_port >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Node message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Node
         * @static
         * @param {routing.Node} message Node
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Node.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.host = "";
                else {
                    object.host = [];
                    if (options.bytes !== Array)
                        object.host = $util.newBuffer(object.host);
                }
                object.tcp_port = 0;
                object.udp_port = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = options.bytes === String ? $util.base64.encode(message.host, 0, message.host.length) : options.bytes === Array ? Array.prototype.slice.call(message.host) : message.host;
            if (message.tcp_port != null && message.hasOwnProperty("tcp_port"))
                object.tcp_port = message.tcp_port;
            if (message.udp_port != null && message.hasOwnProperty("udp_port"))
                object.udp_port = message.udp_port;
            return object;
        };

        /**
         * Converts this Node to JSON.
         * @function toJSON
         * @memberof routing.Node
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Node.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Node;
    })();

    routing.Header = (function() {

        /**
         * Properties of a Header.
         * @memberof routing
         * @interface IHeader
         * @property {routing.INode|null} [sender] Header sender
         * @property {string|null} [networkId] Header networkId
         */

        /**
         * Constructs a new Header.
         * @memberof routing
         * @classdesc Represents a Header.
         * @implements IHeader
         * @constructor
         * @param {routing.IHeader=} [properties] Properties to set
         */
        function Header(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Header sender.
         * @member {routing.INode|null|undefined} sender
         * @memberof routing.Header
         * @instance
         */
        Header.prototype.sender = null;

        /**
         * Header networkId.
         * @member {string} networkId
         * @memberof routing.Header
         * @instance
         */
        Header.prototype.networkId = "";

        /**
         * Creates a new Header instance using the specified properties.
         * @function create
         * @memberof routing.Header
         * @static
         * @param {routing.IHeader=} [properties] Properties to set
         * @returns {routing.Header} Header instance
         */
        Header.create = function create(properties) {
            return new Header(properties);
        };

        /**
         * Encodes the specified Header message. Does not implicitly {@link routing.Header.verify|verify} messages.
         * @function encode
         * @memberof routing.Header
         * @static
         * @param {routing.IHeader} message Header message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Header.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.routing.Node.encode(message.sender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.networkId);
            return writer;
        };

        /**
         * Encodes the specified Header message, length delimited. Does not implicitly {@link routing.Header.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Header
         * @static
         * @param {routing.IHeader} message Header message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Header.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Header message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Header
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Header} Header
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Header.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Header();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sender = $root.routing.Node.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.networkId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Header message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Header
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Header} Header
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Header.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Header message.
         * @function verify
         * @memberof routing.Header
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Header.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sender != null && message.hasOwnProperty("sender")) {
                var error = $root.routing.Node.verify(message.sender);
                if (error)
                    return "sender." + error;
            }
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                if (!$util.isString(message.networkId))
                    return "networkId: string expected";
            return null;
        };

        /**
         * Creates a Header message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Header
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Header} Header
         */
        Header.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Header)
                return object;
            var message = new $root.routing.Header();
            if (object.sender != null) {
                if (typeof object.sender !== "object")
                    throw TypeError(".routing.Header.sender: object expected");
                message.sender = $root.routing.Node.fromObject(object.sender);
            }
            if (object.networkId != null)
                message.networkId = String(object.networkId);
            return message;
        };

        /**
         * Creates a plain object from a Header message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Header
         * @static
         * @param {routing.Header} message Header
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Header.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sender = null;
                object.networkId = "";
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = $root.routing.Node.toObject(message.sender, options);
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                object.networkId = message.networkId;
            return object;
        };

        /**
         * Converts this Header to JSON.
         * @function toJSON
         * @memberof routing.Header
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Header.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Header;
    })();

    routing.Heartbeat = (function() {

        /**
         * Properties of a Heartbeat.
         * @memberof routing
         * @interface IHeartbeat
         */

        /**
         * Constructs a new Heartbeat.
         * @memberof routing
         * @classdesc Represents a Heartbeat.
         * @implements IHeartbeat
         * @constructor
         * @param {routing.IHeartbeat=} [properties] Properties to set
         */
        function Heartbeat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Heartbeat instance using the specified properties.
         * @function create
         * @memberof routing.Heartbeat
         * @static
         * @param {routing.IHeartbeat=} [properties] Properties to set
         * @returns {routing.Heartbeat} Heartbeat instance
         */
        Heartbeat.create = function create(properties) {
            return new Heartbeat(properties);
        };

        /**
         * Encodes the specified Heartbeat message. Does not implicitly {@link routing.Heartbeat.verify|verify} messages.
         * @function encode
         * @memberof routing.Heartbeat
         * @static
         * @param {routing.IHeartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Heartbeat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Heartbeat message, length delimited. Does not implicitly {@link routing.Heartbeat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Heartbeat
         * @static
         * @param {routing.IHeartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Heartbeat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Heartbeat message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Heartbeat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Heartbeat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Heartbeat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Heartbeat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Heartbeat message.
         * @function verify
         * @memberof routing.Heartbeat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Heartbeat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Heartbeat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Heartbeat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Heartbeat} Heartbeat
         */
        Heartbeat.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Heartbeat)
                return object;
            return new $root.routing.Heartbeat();
        };

        /**
         * Creates a plain object from a Heartbeat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Heartbeat
         * @static
         * @param {routing.Heartbeat} message Heartbeat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Heartbeat.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Heartbeat to JSON.
         * @function toJSON
         * @memberof routing.Heartbeat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Heartbeat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Heartbeat;
    })();

    routing.HeartbeatResponse = (function() {

        /**
         * Properties of a HeartbeatResponse.
         * @memberof routing
         * @interface IHeartbeatResponse
         */

        /**
         * Constructs a new HeartbeatResponse.
         * @memberof routing
         * @classdesc Represents a HeartbeatResponse.
         * @implements IHeartbeatResponse
         * @constructor
         * @param {routing.IHeartbeatResponse=} [properties] Properties to set
         */
        function HeartbeatResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HeartbeatResponse instance using the specified properties.
         * @function create
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {routing.IHeartbeatResponse=} [properties] Properties to set
         * @returns {routing.HeartbeatResponse} HeartbeatResponse instance
         */
        HeartbeatResponse.create = function create(properties) {
            return new HeartbeatResponse(properties);
        };

        /**
         * Encodes the specified HeartbeatResponse message. Does not implicitly {@link routing.HeartbeatResponse.verify|verify} messages.
         * @function encode
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {routing.IHeartbeatResponse} message HeartbeatResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartbeatResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HeartbeatResponse message, length delimited. Does not implicitly {@link routing.HeartbeatResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {routing.IHeartbeatResponse} message HeartbeatResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartbeatResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartbeatResponse message from the specified reader or buffer.
         * @function decode
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.HeartbeatResponse} HeartbeatResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartbeatResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.HeartbeatResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartbeatResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.HeartbeatResponse} HeartbeatResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartbeatResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartbeatResponse message.
         * @function verify
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartbeatResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a HeartbeatResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.HeartbeatResponse} HeartbeatResponse
         */
        HeartbeatResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.HeartbeatResponse)
                return object;
            return new $root.routing.HeartbeatResponse();
        };

        /**
         * Creates a plain object from a HeartbeatResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.HeartbeatResponse
         * @static
         * @param {routing.HeartbeatResponse} message HeartbeatResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartbeatResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this HeartbeatResponse to JSON.
         * @function toJSON
         * @memberof routing.HeartbeatResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartbeatResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeartbeatResponse;
    })();

    routing.ProtocolHandshake = (function() {

        /**
         * Properties of a ProtocolHandshake.
         * @memberof routing
         * @interface IProtocolHandshake
         * @property {Uint8Array|null} [nonce] ProtocolHandshake nonce
         */

        /**
         * Constructs a new ProtocolHandshake.
         * @memberof routing
         * @classdesc Represents a ProtocolHandshake.
         * @implements IProtocolHandshake
         * @constructor
         * @param {routing.IProtocolHandshake=} [properties] Properties to set
         */
        function ProtocolHandshake(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtocolHandshake nonce.
         * @member {Uint8Array} nonce
         * @memberof routing.ProtocolHandshake
         * @instance
         */
        ProtocolHandshake.prototype.nonce = $util.newBuffer([]);

        /**
         * Creates a new ProtocolHandshake instance using the specified properties.
         * @function create
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {routing.IProtocolHandshake=} [properties] Properties to set
         * @returns {routing.ProtocolHandshake} ProtocolHandshake instance
         */
        ProtocolHandshake.create = function create(properties) {
            return new ProtocolHandshake(properties);
        };

        /**
         * Encodes the specified ProtocolHandshake message. Does not implicitly {@link routing.ProtocolHandshake.verify|verify} messages.
         * @function encode
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {routing.IProtocolHandshake} message ProtocolHandshake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolHandshake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            return writer;
        };

        /**
         * Encodes the specified ProtocolHandshake message, length delimited. Does not implicitly {@link routing.ProtocolHandshake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {routing.IProtocolHandshake} message ProtocolHandshake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolHandshake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtocolHandshake message from the specified reader or buffer.
         * @function decode
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.ProtocolHandshake} ProtocolHandshake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolHandshake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ProtocolHandshake();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtocolHandshake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.ProtocolHandshake} ProtocolHandshake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolHandshake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtocolHandshake message.
         * @function verify
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtocolHandshake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            return null;
        };

        /**
         * Creates a ProtocolHandshake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.ProtocolHandshake} ProtocolHandshake
         */
        ProtocolHandshake.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.ProtocolHandshake)
                return object;
            var message = new $root.routing.ProtocolHandshake();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            return message;
        };

        /**
         * Creates a plain object from a ProtocolHandshake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.ProtocolHandshake
         * @static
         * @param {routing.ProtocolHandshake} message ProtocolHandshake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtocolHandshake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            return object;
        };

        /**
         * Converts this ProtocolHandshake to JSON.
         * @function toJSON
         * @memberof routing.ProtocolHandshake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtocolHandshake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtocolHandshake;
    })();

    routing.ProtocolHandshakeResponse = (function() {

        /**
         * Properties of a ProtocolHandshakeResponse.
         * @memberof routing
         * @interface IProtocolHandshakeResponse
         * @property {Uint8Array|null} [nonce] ProtocolHandshakeResponse nonce
         */

        /**
         * Constructs a new ProtocolHandshakeResponse.
         * @memberof routing
         * @classdesc Represents a ProtocolHandshakeResponse.
         * @implements IProtocolHandshakeResponse
         * @constructor
         * @param {routing.IProtocolHandshakeResponse=} [properties] Properties to set
         */
        function ProtocolHandshakeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtocolHandshakeResponse nonce.
         * @member {Uint8Array} nonce
         * @memberof routing.ProtocolHandshakeResponse
         * @instance
         */
        ProtocolHandshakeResponse.prototype.nonce = $util.newBuffer([]);

        /**
         * Creates a new ProtocolHandshakeResponse instance using the specified properties.
         * @function create
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {routing.IProtocolHandshakeResponse=} [properties] Properties to set
         * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse instance
         */
        ProtocolHandshakeResponse.create = function create(properties) {
            return new ProtocolHandshakeResponse(properties);
        };

        /**
         * Encodes the specified ProtocolHandshakeResponse message. Does not implicitly {@link routing.ProtocolHandshakeResponse.verify|verify} messages.
         * @function encode
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {routing.IProtocolHandshakeResponse} message ProtocolHandshakeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolHandshakeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            return writer;
        };

        /**
         * Encodes the specified ProtocolHandshakeResponse message, length delimited. Does not implicitly {@link routing.ProtocolHandshakeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {routing.IProtocolHandshakeResponse} message ProtocolHandshakeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolHandshakeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtocolHandshakeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolHandshakeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ProtocolHandshakeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtocolHandshakeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolHandshakeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtocolHandshakeResponse message.
         * @function verify
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtocolHandshakeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            return null;
        };

        /**
         * Creates a ProtocolHandshakeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse
         */
        ProtocolHandshakeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.ProtocolHandshakeResponse)
                return object;
            var message = new $root.routing.ProtocolHandshakeResponse();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            return message;
        };

        /**
         * Creates a plain object from a ProtocolHandshakeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.ProtocolHandshakeResponse
         * @static
         * @param {routing.ProtocolHandshakeResponse} message ProtocolHandshakeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtocolHandshakeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            return object;
        };

        /**
         * Converts this ProtocolHandshakeResponse to JSON.
         * @function toJSON
         * @memberof routing.ProtocolHandshakeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtocolHandshakeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtocolHandshakeResponse;
    })();

    routing.Packet = (function() {

        /**
         * Properties of a Packet.
         * @memberof routing
         * @interface IPacket
         * @property {string|null} [typeId] Packet typeId
         * @property {Uint8Array|null} [content] Packet content
         */

        /**
         * Constructs a new Packet.
         * @memberof routing
         * @classdesc Represents a Packet.
         * @implements IPacket
         * @constructor
         * @param {routing.IPacket=} [properties] Properties to set
         */
        function Packet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Packet typeId.
         * @member {string} typeId
         * @memberof routing.Packet
         * @instance
         */
        Packet.prototype.typeId = "";

        /**
         * Packet content.
         * @member {Uint8Array} content
         * @memberof routing.Packet
         * @instance
         */
        Packet.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new Packet instance using the specified properties.
         * @function create
         * @memberof routing.Packet
         * @static
         * @param {routing.IPacket=} [properties] Properties to set
         * @returns {routing.Packet} Packet instance
         */
        Packet.create = function create(properties) {
            return new Packet(properties);
        };

        /**
         * Encodes the specified Packet message. Does not implicitly {@link routing.Packet.verify|verify} messages.
         * @function encode
         * @memberof routing.Packet
         * @static
         * @param {routing.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified Packet message, length delimited. Does not implicitly {@link routing.Packet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Packet
         * @static
         * @param {routing.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Packet message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Packet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeId = reader.string();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Packet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Packet message.
         * @function verify
         * @memberof routing.Packet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Packet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isString(message.typeId))
                    return "typeId: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a Packet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Packet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Packet} Packet
         */
        Packet.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Packet)
                return object;
            var message = new $root.routing.Packet();
            if (object.typeId != null)
                message.typeId = String(object.typeId);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a Packet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Packet
         * @static
         * @param {routing.Packet} message Packet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Packet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeId = "";
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                object.typeId = message.typeId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this Packet to JSON.
         * @function toJSON
         * @memberof routing.Packet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Packet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Packet;
    })();

    routing.Disconnect = (function() {

        /**
         * Properties of a Disconnect.
         * @memberof routing
         * @interface IDisconnect
         */

        /**
         * Constructs a new Disconnect.
         * @memberof routing
         * @classdesc Represents a Disconnect.
         * @implements IDisconnect
         * @constructor
         * @param {routing.IDisconnect=} [properties] Properties to set
         */
        function Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Disconnect instance using the specified properties.
         * @function create
         * @memberof routing.Disconnect
         * @static
         * @param {routing.IDisconnect=} [properties] Properties to set
         * @returns {routing.Disconnect} Disconnect instance
         */
        Disconnect.create = function create(properties) {
            return new Disconnect(properties);
        };

        /**
         * Encodes the specified Disconnect message. Does not implicitly {@link routing.Disconnect.verify|verify} messages.
         * @function encode
         * @memberof routing.Disconnect
         * @static
         * @param {routing.IDisconnect} message Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Disconnect message, length delimited. Does not implicitly {@link routing.Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Disconnect
         * @static
         * @param {routing.IDisconnect} message Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Disconnect} Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Disconnect} Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Disconnect message.
         * @function verify
         * @memberof routing.Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Disconnect} Disconnect
         */
        Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Disconnect)
                return object;
            return new $root.routing.Disconnect();
        };

        /**
         * Creates a plain object from a Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Disconnect
         * @static
         * @param {routing.Disconnect} message Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Disconnect.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Disconnect to JSON.
         * @function toJSON
         * @memberof routing.Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Disconnect;
    })();

    routing.Protocol = (function() {

        /**
         * Properties of a Protocol.
         * @memberof routing
         * @interface IProtocol
         * @property {routing.IHeader|null} [header] Protocol header
         * @property {routing.IHeartbeat|null} [heartbeat] Protocol heartbeat
         * @property {routing.IProtocolHandshake|null} [protocol_handshake] Protocol protocol_handshake
         * @property {routing.IProtocolHandshakeResponse|null} [protocol_handshake_response] Protocol protocol_handshake_response
         * @property {routing.IPacket|null} [packet] Protocol packet
         * @property {routing.IDisconnect|null} [disconnect] Protocol disconnect
         */

        /**
         * Constructs a new Protocol.
         * @memberof routing
         * @classdesc Represents a Protocol.
         * @implements IProtocol
         * @constructor
         * @param {routing.IProtocol=} [properties] Properties to set
         */
        function Protocol(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Protocol header.
         * @member {routing.IHeader|null|undefined} header
         * @memberof routing.Protocol
         * @instance
         */
        Protocol.prototype.header = null;

        /**
         * Protocol heartbeat.
         * @member {routing.IHeartbeat|null|undefined} heartbeat
         * @memberof routing.Protocol
         * @instance
         */
        Protocol.prototype.heartbeat = null;

        /**
         * Protocol protocol_handshake.
         * @member {routing.IProtocolHandshake|null|undefined} protocol_handshake
         * @memberof routing.Protocol
         * @instance
         */
        Protocol.prototype.protocol_handshake = null;

        /**
         * Protocol protocol_handshake_response.
         * @member {routing.IProtocolHandshakeResponse|null|undefined} protocol_handshake_response
         * @memberof routing.Protocol
         * @instance
         */
        Protocol.prototype.protocol_handshake_response = null;

        /**
         * Protocol packet.
         * @member {routing.IPacket|null|undefined} packet
         * @memberof routing.Protocol
         * @instance
         */
        Protocol.prototype.packet = null;

        /**
         * Protocol disconnect.
         * @member {routing.IDisconnect|null|undefined} disconnect
         * @memberof routing.Protocol
         * @instance
         */
        Protocol.prototype.disconnect = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Protocol message.
         * @member {"heartbeat"|"protocol_handshake"|"protocol_handshake_response"|"packet"|"disconnect"|undefined} message
         * @memberof routing.Protocol
         * @instance
         */
        Object.defineProperty(Protocol.prototype, "message", {
            get: $util.oneOfGetter($oneOfFields = ["heartbeat", "protocol_handshake", "protocol_handshake_response", "packet", "disconnect"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Protocol instance using the specified properties.
         * @function create
         * @memberof routing.Protocol
         * @static
         * @param {routing.IProtocol=} [properties] Properties to set
         * @returns {routing.Protocol} Protocol instance
         */
        Protocol.create = function create(properties) {
            return new Protocol(properties);
        };

        /**
         * Encodes the specified Protocol message. Does not implicitly {@link routing.Protocol.verify|verify} messages.
         * @function encode
         * @memberof routing.Protocol
         * @static
         * @param {routing.IProtocol} message Protocol message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Protocol.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.header != null && message.hasOwnProperty("header"))
                $root.routing.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat"))
                $root.routing.Heartbeat.encode(message.heartbeat, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.protocol_handshake != null && message.hasOwnProperty("protocol_handshake"))
                $root.routing.ProtocolHandshake.encode(message.protocol_handshake, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.protocol_handshake_response != null && message.hasOwnProperty("protocol_handshake_response"))
                $root.routing.ProtocolHandshakeResponse.encode(message.protocol_handshake_response, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.packet != null && message.hasOwnProperty("packet"))
                $root.routing.Packet.encode(message.packet, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.disconnect != null && message.hasOwnProperty("disconnect"))
                $root.routing.Disconnect.encode(message.disconnect, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Protocol message, length delimited. Does not implicitly {@link routing.Protocol.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Protocol
         * @static
         * @param {routing.IProtocol} message Protocol message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Protocol.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Protocol message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Protocol
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Protocol} Protocol
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Protocol.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Protocol();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.routing.Header.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.heartbeat = $root.routing.Heartbeat.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.protocol_handshake = $root.routing.ProtocolHandshake.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.protocol_handshake_response = $root.routing.ProtocolHandshakeResponse.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.packet = $root.routing.Packet.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.disconnect = $root.routing.Disconnect.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Protocol message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Protocol
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Protocol} Protocol
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Protocol.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Protocol message.
         * @function verify
         * @memberof routing.Protocol
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Protocol.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.header != null && message.hasOwnProperty("header")) {
                var error = $root.routing.Header.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                properties.message = 1;
                {
                    var error = $root.routing.Heartbeat.verify(message.heartbeat);
                    if (error)
                        return "heartbeat." + error;
                }
            }
            if (message.protocol_handshake != null && message.hasOwnProperty("protocol_handshake")) {
                if (properties.message === 1)
                    return "message: multiple values";
                properties.message = 1;
                {
                    var error = $root.routing.ProtocolHandshake.verify(message.protocol_handshake);
                    if (error)
                        return "protocol_handshake." + error;
                }
            }
            if (message.protocol_handshake_response != null && message.hasOwnProperty("protocol_handshake_response")) {
                if (properties.message === 1)
                    return "message: multiple values";
                properties.message = 1;
                {
                    var error = $root.routing.ProtocolHandshakeResponse.verify(message.protocol_handshake_response);
                    if (error)
                        return "protocol_handshake_response." + error;
                }
            }
            if (message.packet != null && message.hasOwnProperty("packet")) {
                if (properties.message === 1)
                    return "message: multiple values";
                properties.message = 1;
                {
                    var error = $root.routing.Packet.verify(message.packet);
                    if (error)
                        return "packet." + error;
                }
            }
            if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                if (properties.message === 1)
                    return "message: multiple values";
                properties.message = 1;
                {
                    var error = $root.routing.Disconnect.verify(message.disconnect);
                    if (error)
                        return "disconnect." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Protocol message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Protocol
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Protocol} Protocol
         */
        Protocol.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Protocol)
                return object;
            var message = new $root.routing.Protocol();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".routing.Protocol.header: object expected");
                message.header = $root.routing.Header.fromObject(object.header);
            }
            if (object.heartbeat != null) {
                if (typeof object.heartbeat !== "object")
                    throw TypeError(".routing.Protocol.heartbeat: object expected");
                message.heartbeat = $root.routing.Heartbeat.fromObject(object.heartbeat);
            }
            if (object.protocol_handshake != null) {
                if (typeof object.protocol_handshake !== "object")
                    throw TypeError(".routing.Protocol.protocol_handshake: object expected");
                message.protocol_handshake = $root.routing.ProtocolHandshake.fromObject(object.protocol_handshake);
            }
            if (object.protocol_handshake_response != null) {
                if (typeof object.protocol_handshake_response !== "object")
                    throw TypeError(".routing.Protocol.protocol_handshake_response: object expected");
                message.protocol_handshake_response = $root.routing.ProtocolHandshakeResponse.fromObject(object.protocol_handshake_response);
            }
            if (object.packet != null) {
                if (typeof object.packet !== "object")
                    throw TypeError(".routing.Protocol.packet: object expected");
                message.packet = $root.routing.Packet.fromObject(object.packet);
            }
            if (object.disconnect != null) {
                if (typeof object.disconnect !== "object")
                    throw TypeError(".routing.Protocol.disconnect: object expected");
                message.disconnect = $root.routing.Disconnect.fromObject(object.disconnect);
            }
            return message;
        };

        /**
         * Creates a plain object from a Protocol message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Protocol
         * @static
         * @param {routing.Protocol} message Protocol
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Protocol.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.routing.Header.toObject(message.header, options);
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                object.heartbeat = $root.routing.Heartbeat.toObject(message.heartbeat, options);
                if (options.oneofs)
                    object.message = "heartbeat";
            }
            if (message.protocol_handshake != null && message.hasOwnProperty("protocol_handshake")) {
                object.protocol_handshake = $root.routing.ProtocolHandshake.toObject(message.protocol_handshake, options);
                if (options.oneofs)
                    object.message = "protocol_handshake";
            }
            if (message.protocol_handshake_response != null && message.hasOwnProperty("protocol_handshake_response")) {
                object.protocol_handshake_response = $root.routing.ProtocolHandshakeResponse.toObject(message.protocol_handshake_response, options);
                if (options.oneofs)
                    object.message = "protocol_handshake_response";
            }
            if (message.packet != null && message.hasOwnProperty("packet")) {
                object.packet = $root.routing.Packet.toObject(message.packet, options);
                if (options.oneofs)
                    object.message = "packet";
            }
            if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                object.disconnect = $root.routing.Disconnect.toObject(message.disconnect, options);
                if (options.oneofs)
                    object.message = "disconnect";
            }
            return object;
        };

        /**
         * Converts this Protocol to JSON.
         * @function toJSON
         * @memberof routing.Protocol
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Protocol.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Protocol;
    })();

    routing.TransportLayer = (function() {

        /**
         * Constructs a new TransportLayer service.
         * @memberof routing
         * @classdesc Represents a TransportLayer
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function TransportLayer(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (TransportLayer.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TransportLayer;

        /**
         * Creates new TransportLayer service using the specified rpc implementation.
         * @function create
         * @memberof routing.TransportLayer
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {TransportLayer} RPC service. Useful where requests and/or responses are streamed.
         */
        TransportLayer.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link routing.TransportLayer#send}.
         * @memberof routing.TransportLayer
         * @typedef SendCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {routing.TLResponse} [response] TLResponse
         */

        /**
         * Calls Send.
         * @function send
         * @memberof routing.TransportLayer
         * @instance
         * @param {routing.ITLRequest} request TLRequest message or plain object
         * @param {routing.TransportLayer.SendCallback} callback Node-style callback called with the error, if any, and TLResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TransportLayer.prototype.send = function send(request, callback) {
            return this.rpcCall(send, $root.routing.TLRequest, $root.routing.TLResponse, request, callback);
        }, "name", { value: "Send" });

        /**
         * Calls Send.
         * @function send
         * @memberof routing.TransportLayer
         * @instance
         * @param {routing.ITLRequest} request TLRequest message or plain object
         * @returns {Promise<routing.TLResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link routing.TransportLayer#stream}.
         * @memberof routing.TransportLayer
         * @typedef StreamCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {routing.TLResponse} [response] TLResponse
         */

        /**
         * Calls Stream.
         * @function stream
         * @memberof routing.TransportLayer
         * @instance
         * @param {routing.IChunk} request Chunk message or plain object
         * @param {routing.TransportLayer.StreamCallback} callback Node-style callback called with the error, if any, and TLResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TransportLayer.prototype.stream = function stream(request, callback) {
            return this.rpcCall(stream, $root.routing.Chunk, $root.routing.TLResponse, request, callback);
        }, "name", { value: "Stream" });

        /**
         * Calls Stream.
         * @function stream
         * @memberof routing.TransportLayer
         * @instance
         * @param {routing.IChunk} request Chunk message or plain object
         * @returns {Promise<routing.TLResponse>} Promise
         * @variation 2
         */

        return TransportLayer;
    })();

    routing.TLRequest = (function() {

        /**
         * Properties of a TLRequest.
         * @memberof routing
         * @interface ITLRequest
         * @property {routing.IProtocol|null} [protocol] TLRequest protocol
         */

        /**
         * Constructs a new TLRequest.
         * @memberof routing
         * @classdesc Represents a TLRequest.
         * @implements ITLRequest
         * @constructor
         * @param {routing.ITLRequest=} [properties] Properties to set
         */
        function TLRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TLRequest protocol.
         * @member {routing.IProtocol|null|undefined} protocol
         * @memberof routing.TLRequest
         * @instance
         */
        TLRequest.prototype.protocol = null;

        /**
         * Creates a new TLRequest instance using the specified properties.
         * @function create
         * @memberof routing.TLRequest
         * @static
         * @param {routing.ITLRequest=} [properties] Properties to set
         * @returns {routing.TLRequest} TLRequest instance
         */
        TLRequest.create = function create(properties) {
            return new TLRequest(properties);
        };

        /**
         * Encodes the specified TLRequest message. Does not implicitly {@link routing.TLRequest.verify|verify} messages.
         * @function encode
         * @memberof routing.TLRequest
         * @static
         * @param {routing.ITLRequest} message TLRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TLRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                $root.routing.Protocol.encode(message.protocol, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TLRequest message, length delimited. Does not implicitly {@link routing.TLRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.TLRequest
         * @static
         * @param {routing.ITLRequest} message TLRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TLRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TLRequest message from the specified reader or buffer.
         * @function decode
         * @memberof routing.TLRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.TLRequest} TLRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TLRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.TLRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.protocol = $root.routing.Protocol.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TLRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.TLRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.TLRequest} TLRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TLRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TLRequest message.
         * @function verify
         * @memberof routing.TLRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TLRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.protocol != null && message.hasOwnProperty("protocol")) {
                var error = $root.routing.Protocol.verify(message.protocol);
                if (error)
                    return "protocol." + error;
            }
            return null;
        };

        /**
         * Creates a TLRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.TLRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.TLRequest} TLRequest
         */
        TLRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.TLRequest)
                return object;
            var message = new $root.routing.TLRequest();
            if (object.protocol != null) {
                if (typeof object.protocol !== "object")
                    throw TypeError(".routing.TLRequest.protocol: object expected");
                message.protocol = $root.routing.Protocol.fromObject(object.protocol);
            }
            return message;
        };

        /**
         * Creates a plain object from a TLRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.TLRequest
         * @static
         * @param {routing.TLRequest} message TLRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TLRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.protocol = null;
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = $root.routing.Protocol.toObject(message.protocol, options);
            return object;
        };

        /**
         * Converts this TLRequest to JSON.
         * @function toJSON
         * @memberof routing.TLRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TLRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TLRequest;
    })();

    routing.InternalServerError = (function() {

        /**
         * Properties of an InternalServerError.
         * @memberof routing
         * @interface IInternalServerError
         * @property {Uint8Array|null} [error] InternalServerError error
         */

        /**
         * Constructs a new InternalServerError.
         * @memberof routing
         * @classdesc Represents an InternalServerError.
         * @implements IInternalServerError
         * @constructor
         * @param {routing.IInternalServerError=} [properties] Properties to set
         */
        function InternalServerError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InternalServerError error.
         * @member {Uint8Array} error
         * @memberof routing.InternalServerError
         * @instance
         */
        InternalServerError.prototype.error = $util.newBuffer([]);

        /**
         * Creates a new InternalServerError instance using the specified properties.
         * @function create
         * @memberof routing.InternalServerError
         * @static
         * @param {routing.IInternalServerError=} [properties] Properties to set
         * @returns {routing.InternalServerError} InternalServerError instance
         */
        InternalServerError.create = function create(properties) {
            return new InternalServerError(properties);
        };

        /**
         * Encodes the specified InternalServerError message. Does not implicitly {@link routing.InternalServerError.verify|verify} messages.
         * @function encode
         * @memberof routing.InternalServerError
         * @static
         * @param {routing.IInternalServerError} message InternalServerError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalServerError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.error);
            return writer;
        };

        /**
         * Encodes the specified InternalServerError message, length delimited. Does not implicitly {@link routing.InternalServerError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.InternalServerError
         * @static
         * @param {routing.IInternalServerError} message InternalServerError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalServerError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InternalServerError message from the specified reader or buffer.
         * @function decode
         * @memberof routing.InternalServerError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.InternalServerError} InternalServerError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalServerError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.InternalServerError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InternalServerError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.InternalServerError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.InternalServerError} InternalServerError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalServerError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InternalServerError message.
         * @function verify
         * @memberof routing.InternalServerError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InternalServerError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error"))
                if (!(message.error && typeof message.error.length === "number" || $util.isString(message.error)))
                    return "error: buffer expected";
            return null;
        };

        /**
         * Creates an InternalServerError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.InternalServerError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.InternalServerError} InternalServerError
         */
        InternalServerError.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.InternalServerError)
                return object;
            var message = new $root.routing.InternalServerError();
            if (object.error != null)
                if (typeof object.error === "string")
                    $util.base64.decode(object.error, message.error = $util.newBuffer($util.base64.length(object.error)), 0);
                else if (object.error.length)
                    message.error = object.error;
            return message;
        };

        /**
         * Creates a plain object from an InternalServerError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.InternalServerError
         * @static
         * @param {routing.InternalServerError} message InternalServerError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InternalServerError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.error = "";
                else {
                    object.error = [];
                    if (options.bytes !== Array)
                        object.error = $util.newBuffer(object.error);
                }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.bytes === String ? $util.base64.encode(message.error, 0, message.error.length) : options.bytes === Array ? Array.prototype.slice.call(message.error) : message.error;
            return object;
        };

        /**
         * Converts this InternalServerError to JSON.
         * @function toJSON
         * @memberof routing.InternalServerError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InternalServerError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InternalServerError;
    })();

    routing.Ack = (function() {

        /**
         * Properties of an Ack.
         * @memberof routing
         * @interface IAck
         * @property {routing.IHeader|null} [header] Ack header
         */

        /**
         * Constructs a new Ack.
         * @memberof routing
         * @classdesc Represents an Ack.
         * @implements IAck
         * @constructor
         * @param {routing.IAck=} [properties] Properties to set
         */
        function Ack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ack header.
         * @member {routing.IHeader|null|undefined} header
         * @memberof routing.Ack
         * @instance
         */
        Ack.prototype.header = null;

        /**
         * Creates a new Ack instance using the specified properties.
         * @function create
         * @memberof routing.Ack
         * @static
         * @param {routing.IAck=} [properties] Properties to set
         * @returns {routing.Ack} Ack instance
         */
        Ack.create = function create(properties) {
            return new Ack(properties);
        };

        /**
         * Encodes the specified Ack message. Does not implicitly {@link routing.Ack.verify|verify} messages.
         * @function encode
         * @memberof routing.Ack
         * @static
         * @param {routing.IAck} message Ack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.header != null && message.hasOwnProperty("header"))
                $root.routing.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Ack message, length delimited. Does not implicitly {@link routing.Ack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Ack
         * @static
         * @param {routing.IAck} message Ack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Ack message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Ack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Ack} Ack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Ack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.routing.Header.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Ack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Ack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Ack} Ack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Ack message.
         * @function verify
         * @memberof routing.Ack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.header != null && message.hasOwnProperty("header")) {
                var error = $root.routing.Header.verify(message.header);
                if (error)
                    return "header." + error;
            }
            return null;
        };

        /**
         * Creates an Ack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Ack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Ack} Ack
         */
        Ack.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Ack)
                return object;
            var message = new $root.routing.Ack();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".routing.Ack.header: object expected");
                message.header = $root.routing.Header.fromObject(object.header);
            }
            return message;
        };

        /**
         * Creates a plain object from an Ack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Ack
         * @static
         * @param {routing.Ack} message Ack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.routing.Header.toObject(message.header, options);
            return object;
        };

        /**
         * Converts this Ack to JSON.
         * @function toJSON
         * @memberof routing.Ack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ack;
    })();

    routing.TLResponse = (function() {

        /**
         * Properties of a TLResponse.
         * @memberof routing
         * @interface ITLResponse
         * @property {routing.IAck|null} [ack] TLResponse ack
         * @property {routing.IInternalServerError|null} [internalServerError] TLResponse internalServerError
         */

        /**
         * Constructs a new TLResponse.
         * @memberof routing
         * @classdesc Represents a TLResponse.
         * @implements ITLResponse
         * @constructor
         * @param {routing.ITLResponse=} [properties] Properties to set
         */
        function TLResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TLResponse ack.
         * @member {routing.IAck|null|undefined} ack
         * @memberof routing.TLResponse
         * @instance
         */
        TLResponse.prototype.ack = null;

        /**
         * TLResponse internalServerError.
         * @member {routing.IInternalServerError|null|undefined} internalServerError
         * @memberof routing.TLResponse
         * @instance
         */
        TLResponse.prototype.internalServerError = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TLResponse payload.
         * @member {"ack"|"internalServerError"|undefined} payload
         * @memberof routing.TLResponse
         * @instance
         */
        Object.defineProperty(TLResponse.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["ack", "internalServerError"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TLResponse instance using the specified properties.
         * @function create
         * @memberof routing.TLResponse
         * @static
         * @param {routing.ITLResponse=} [properties] Properties to set
         * @returns {routing.TLResponse} TLResponse instance
         */
        TLResponse.create = function create(properties) {
            return new TLResponse(properties);
        };

        /**
         * Encodes the specified TLResponse message. Does not implicitly {@link routing.TLResponse.verify|verify} messages.
         * @function encode
         * @memberof routing.TLResponse
         * @static
         * @param {routing.ITLResponse} message TLResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TLResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ack != null && message.hasOwnProperty("ack"))
                $root.routing.Ack.encode(message.ack, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.internalServerError != null && message.hasOwnProperty("internalServerError"))
                $root.routing.InternalServerError.encode(message.internalServerError, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TLResponse message, length delimited. Does not implicitly {@link routing.TLResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.TLResponse
         * @static
         * @param {routing.ITLResponse} message TLResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TLResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TLResponse message from the specified reader or buffer.
         * @function decode
         * @memberof routing.TLResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.TLResponse} TLResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TLResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.TLResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ack = $root.routing.Ack.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.internalServerError = $root.routing.InternalServerError.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TLResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.TLResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.TLResponse} TLResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TLResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TLResponse message.
         * @function verify
         * @memberof routing.TLResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TLResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ack != null && message.hasOwnProperty("ack")) {
                properties.payload = 1;
                {
                    var error = $root.routing.Ack.verify(message.ack);
                    if (error)
                        return "ack." + error;
                }
            }
            if (message.internalServerError != null && message.hasOwnProperty("internalServerError")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.routing.InternalServerError.verify(message.internalServerError);
                    if (error)
                        return "internalServerError." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TLResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.TLResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.TLResponse} TLResponse
         */
        TLResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.TLResponse)
                return object;
            var message = new $root.routing.TLResponse();
            if (object.ack != null) {
                if (typeof object.ack !== "object")
                    throw TypeError(".routing.TLResponse.ack: object expected");
                message.ack = $root.routing.Ack.fromObject(object.ack);
            }
            if (object.internalServerError != null) {
                if (typeof object.internalServerError !== "object")
                    throw TypeError(".routing.TLResponse.internalServerError: object expected");
                message.internalServerError = $root.routing.InternalServerError.fromObject(object.internalServerError);
            }
            return message;
        };

        /**
         * Creates a plain object from a TLResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.TLResponse
         * @static
         * @param {routing.TLResponse} message TLResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TLResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ack != null && message.hasOwnProperty("ack")) {
                object.ack = $root.routing.Ack.toObject(message.ack, options);
                if (options.oneofs)
                    object.payload = "ack";
            }
            if (message.internalServerError != null && message.hasOwnProperty("internalServerError")) {
                object.internalServerError = $root.routing.InternalServerError.toObject(message.internalServerError, options);
                if (options.oneofs)
                    object.payload = "internalServerError";
            }
            return object;
        };

        /**
         * Converts this TLResponse to JSON.
         * @function toJSON
         * @memberof routing.TLResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TLResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TLResponse;
    })();

    routing.ChunkHeader = (function() {

        /**
         * Properties of a ChunkHeader.
         * @memberof routing
         * @interface IChunkHeader
         * @property {routing.INode|null} [sender] ChunkHeader sender
         * @property {string|null} [typeId] ChunkHeader typeId
         * @property {boolean|null} [compressed] ChunkHeader compressed
         * @property {number|null} [contentLength] ChunkHeader contentLength
         * @property {string|null} [networkId] ChunkHeader networkId
         */

        /**
         * Constructs a new ChunkHeader.
         * @memberof routing
         * @classdesc Represents a ChunkHeader.
         * @implements IChunkHeader
         * @constructor
         * @param {routing.IChunkHeader=} [properties] Properties to set
         */
        function ChunkHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChunkHeader sender.
         * @member {routing.INode|null|undefined} sender
         * @memberof routing.ChunkHeader
         * @instance
         */
        ChunkHeader.prototype.sender = null;

        /**
         * ChunkHeader typeId.
         * @member {string} typeId
         * @memberof routing.ChunkHeader
         * @instance
         */
        ChunkHeader.prototype.typeId = "";

        /**
         * ChunkHeader compressed.
         * @member {boolean} compressed
         * @memberof routing.ChunkHeader
         * @instance
         */
        ChunkHeader.prototype.compressed = false;

        /**
         * ChunkHeader contentLength.
         * @member {number} contentLength
         * @memberof routing.ChunkHeader
         * @instance
         */
        ChunkHeader.prototype.contentLength = 0;

        /**
         * ChunkHeader networkId.
         * @member {string} networkId
         * @memberof routing.ChunkHeader
         * @instance
         */
        ChunkHeader.prototype.networkId = "";

        /**
         * Creates a new ChunkHeader instance using the specified properties.
         * @function create
         * @memberof routing.ChunkHeader
         * @static
         * @param {routing.IChunkHeader=} [properties] Properties to set
         * @returns {routing.ChunkHeader} ChunkHeader instance
         */
        ChunkHeader.create = function create(properties) {
            return new ChunkHeader(properties);
        };

        /**
         * Encodes the specified ChunkHeader message. Does not implicitly {@link routing.ChunkHeader.verify|verify} messages.
         * @function encode
         * @memberof routing.ChunkHeader
         * @static
         * @param {routing.IChunkHeader} message ChunkHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.routing.Node.encode(message.sender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeId);
            if (message.compressed != null && message.hasOwnProperty("compressed"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.compressed);
            if (message.contentLength != null && message.hasOwnProperty("contentLength"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentLength);
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.networkId);
            return writer;
        };

        /**
         * Encodes the specified ChunkHeader message, length delimited. Does not implicitly {@link routing.ChunkHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.ChunkHeader
         * @static
         * @param {routing.IChunkHeader} message ChunkHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChunkHeader message from the specified reader or buffer.
         * @function decode
         * @memberof routing.ChunkHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.ChunkHeader} ChunkHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ChunkHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sender = $root.routing.Node.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.typeId = reader.string();
                    break;
                case 3:
                    message.compressed = reader.bool();
                    break;
                case 4:
                    message.contentLength = reader.int32();
                    break;
                case 5:
                    message.networkId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChunkHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.ChunkHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.ChunkHeader} ChunkHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChunkHeader message.
         * @function verify
         * @memberof routing.ChunkHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChunkHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sender != null && message.hasOwnProperty("sender")) {
                var error = $root.routing.Node.verify(message.sender);
                if (error)
                    return "sender." + error;
            }
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isString(message.typeId))
                    return "typeId: string expected";
            if (message.compressed != null && message.hasOwnProperty("compressed"))
                if (typeof message.compressed !== "boolean")
                    return "compressed: boolean expected";
            if (message.contentLength != null && message.hasOwnProperty("contentLength"))
                if (!$util.isInteger(message.contentLength))
                    return "contentLength: integer expected";
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                if (!$util.isString(message.networkId))
                    return "networkId: string expected";
            return null;
        };

        /**
         * Creates a ChunkHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.ChunkHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.ChunkHeader} ChunkHeader
         */
        ChunkHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.ChunkHeader)
                return object;
            var message = new $root.routing.ChunkHeader();
            if (object.sender != null) {
                if (typeof object.sender !== "object")
                    throw TypeError(".routing.ChunkHeader.sender: object expected");
                message.sender = $root.routing.Node.fromObject(object.sender);
            }
            if (object.typeId != null)
                message.typeId = String(object.typeId);
            if (object.compressed != null)
                message.compressed = Boolean(object.compressed);
            if (object.contentLength != null)
                message.contentLength = object.contentLength | 0;
            if (object.networkId != null)
                message.networkId = String(object.networkId);
            return message;
        };

        /**
         * Creates a plain object from a ChunkHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.ChunkHeader
         * @static
         * @param {routing.ChunkHeader} message ChunkHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChunkHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sender = null;
                object.typeId = "";
                object.compressed = false;
                object.contentLength = 0;
                object.networkId = "";
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = $root.routing.Node.toObject(message.sender, options);
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                object.typeId = message.typeId;
            if (message.compressed != null && message.hasOwnProperty("compressed"))
                object.compressed = message.compressed;
            if (message.contentLength != null && message.hasOwnProperty("contentLength"))
                object.contentLength = message.contentLength;
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                object.networkId = message.networkId;
            return object;
        };

        /**
         * Converts this ChunkHeader to JSON.
         * @function toJSON
         * @memberof routing.ChunkHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChunkHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChunkHeader;
    })();

    routing.ChunkData = (function() {

        /**
         * Properties of a ChunkData.
         * @memberof routing
         * @interface IChunkData
         * @property {Uint8Array|null} [contentData] ChunkData contentData
         */

        /**
         * Constructs a new ChunkData.
         * @memberof routing
         * @classdesc Represents a ChunkData.
         * @implements IChunkData
         * @constructor
         * @param {routing.IChunkData=} [properties] Properties to set
         */
        function ChunkData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChunkData contentData.
         * @member {Uint8Array} contentData
         * @memberof routing.ChunkData
         * @instance
         */
        ChunkData.prototype.contentData = $util.newBuffer([]);

        /**
         * Creates a new ChunkData instance using the specified properties.
         * @function create
         * @memberof routing.ChunkData
         * @static
         * @param {routing.IChunkData=} [properties] Properties to set
         * @returns {routing.ChunkData} ChunkData instance
         */
        ChunkData.create = function create(properties) {
            return new ChunkData(properties);
        };

        /**
         * Encodes the specified ChunkData message. Does not implicitly {@link routing.ChunkData.verify|verify} messages.
         * @function encode
         * @memberof routing.ChunkData
         * @static
         * @param {routing.IChunkData} message ChunkData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contentData != null && message.hasOwnProperty("contentData"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contentData);
            return writer;
        };

        /**
         * Encodes the specified ChunkData message, length delimited. Does not implicitly {@link routing.ChunkData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.ChunkData
         * @static
         * @param {routing.IChunkData} message ChunkData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChunkData message from the specified reader or buffer.
         * @function decode
         * @memberof routing.ChunkData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.ChunkData} ChunkData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ChunkData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contentData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChunkData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.ChunkData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.ChunkData} ChunkData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChunkData message.
         * @function verify
         * @memberof routing.ChunkData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChunkData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contentData != null && message.hasOwnProperty("contentData"))
                if (!(message.contentData && typeof message.contentData.length === "number" || $util.isString(message.contentData)))
                    return "contentData: buffer expected";
            return null;
        };

        /**
         * Creates a ChunkData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.ChunkData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.ChunkData} ChunkData
         */
        ChunkData.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.ChunkData)
                return object;
            var message = new $root.routing.ChunkData();
            if (object.contentData != null)
                if (typeof object.contentData === "string")
                    $util.base64.decode(object.contentData, message.contentData = $util.newBuffer($util.base64.length(object.contentData)), 0);
                else if (object.contentData.length)
                    message.contentData = object.contentData;
            return message;
        };

        /**
         * Creates a plain object from a ChunkData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.ChunkData
         * @static
         * @param {routing.ChunkData} message ChunkData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChunkData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.contentData = "";
                else {
                    object.contentData = [];
                    if (options.bytes !== Array)
                        object.contentData = $util.newBuffer(object.contentData);
                }
            if (message.contentData != null && message.hasOwnProperty("contentData"))
                object.contentData = options.bytes === String ? $util.base64.encode(message.contentData, 0, message.contentData.length) : options.bytes === Array ? Array.prototype.slice.call(message.contentData) : message.contentData;
            return object;
        };

        /**
         * Converts this ChunkData to JSON.
         * @function toJSON
         * @memberof routing.ChunkData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChunkData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChunkData;
    })();

    routing.Chunk = (function() {

        /**
         * Properties of a Chunk.
         * @memberof routing
         * @interface IChunk
         * @property {routing.IChunkHeader|null} [header] Chunk header
         * @property {routing.IChunkData|null} [data] Chunk data
         */

        /**
         * Constructs a new Chunk.
         * @memberof routing
         * @classdesc Represents a Chunk.
         * @implements IChunk
         * @constructor
         * @param {routing.IChunk=} [properties] Properties to set
         */
        function Chunk(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Chunk header.
         * @member {routing.IChunkHeader|null|undefined} header
         * @memberof routing.Chunk
         * @instance
         */
        Chunk.prototype.header = null;

        /**
         * Chunk data.
         * @member {routing.IChunkData|null|undefined} data
         * @memberof routing.Chunk
         * @instance
         */
        Chunk.prototype.data = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Chunk content.
         * @member {"header"|"data"|undefined} content
         * @memberof routing.Chunk
         * @instance
         */
        Object.defineProperty(Chunk.prototype, "content", {
            get: $util.oneOfGetter($oneOfFields = ["header", "data"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Chunk instance using the specified properties.
         * @function create
         * @memberof routing.Chunk
         * @static
         * @param {routing.IChunk=} [properties] Properties to set
         * @returns {routing.Chunk} Chunk instance
         */
        Chunk.create = function create(properties) {
            return new Chunk(properties);
        };

        /**
         * Encodes the specified Chunk message. Does not implicitly {@link routing.Chunk.verify|verify} messages.
         * @function encode
         * @memberof routing.Chunk
         * @static
         * @param {routing.IChunk} message Chunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chunk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.header != null && message.hasOwnProperty("header"))
                $root.routing.ChunkHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                $root.routing.ChunkData.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Chunk message, length delimited. Does not implicitly {@link routing.Chunk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof routing.Chunk
         * @static
         * @param {routing.IChunk} message Chunk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chunk.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chunk message from the specified reader or buffer.
         * @function decode
         * @memberof routing.Chunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {routing.Chunk} Chunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chunk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Chunk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.routing.ChunkHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.data = $root.routing.ChunkData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chunk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof routing.Chunk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {routing.Chunk} Chunk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chunk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chunk message.
         * @function verify
         * @memberof routing.Chunk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chunk.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.header != null && message.hasOwnProperty("header")) {
                properties.content = 1;
                {
                    var error = $root.routing.ChunkHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                if (properties.content === 1)
                    return "content: multiple values";
                properties.content = 1;
                {
                    var error = $root.routing.ChunkData.verify(message.data);
                    if (error)
                        return "data." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Chunk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof routing.Chunk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {routing.Chunk} Chunk
         */
        Chunk.fromObject = function fromObject(object) {
            if (object instanceof $root.routing.Chunk)
                return object;
            var message = new $root.routing.Chunk();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".routing.Chunk.header: object expected");
                message.header = $root.routing.ChunkHeader.fromObject(object.header);
            }
            if (object.data != null) {
                if (typeof object.data !== "object")
                    throw TypeError(".routing.Chunk.data: object expected");
                message.data = $root.routing.ChunkData.fromObject(object.data);
            }
            return message;
        };

        /**
         * Creates a plain object from a Chunk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof routing.Chunk
         * @static
         * @param {routing.Chunk} message Chunk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Chunk.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.header != null && message.hasOwnProperty("header")) {
                object.header = $root.routing.ChunkHeader.toObject(message.header, options);
                if (options.oneofs)
                    object.content = "header";
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                object.data = $root.routing.ChunkData.toObject(message.data, options);
                if (options.oneofs)
                    object.content = "data";
            }
            return object;
        };

        /**
         * Converts this Chunk to JSON.
         * @function toJSON
         * @memberof routing.Chunk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Chunk.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Chunk;
    })();

    return routing;
})();

module.exports = $root;
